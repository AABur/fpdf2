<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fpdf API documentation</title>
<meta name="description" content="pyfpdf: FPDF for Python …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>fpdf</code></h1>
</header>
<section id="section-intro">
<p>pyfpdf: FPDF for Python</p>
<p>Simple PDF generation for Python. PyFPDF is a library for PDF document
generation under Python, ported from PHP (see <a href="http://www.fpdf.org/">FPDF</a>: "Free"-PDF, a
well-known PDFlib-extension replacement with many examples, scripts
and derivatives).</p>
<p>Compared with other PDF libraries, PyFPDF is simple, small and versatile, with
advanced capabilities, and is easy to learn, extend and maintain.</p>
<p>For introductory material see
<a href="http://pyfpdf.readthedocs.org/en/latest/">Read the Docs</a>, and for additional
documentation see the <code><a title="fpdf.fpdf" href="fpdf.html">fpdf.fpdf</a></code> submodule.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
&#34;&#34;&#34;pyfpdf: FPDF for Python

Simple PDF generation for Python. PyFPDF is a library for PDF document
generation under Python, ported from PHP (see [FPDF][1]: &#34;Free&#34;-PDF, a
well-known PDFlib-extension replacement with many examples, scripts
and derivatives).

Compared with other PDF libraries, PyFPDF is simple, small and versatile, with
advanced capabilities, and is easy to learn, extend and maintain.

  [1]: http://www.fpdf.org/

For introductory material see
[Read the Docs](http://pyfpdf.readthedocs.org/en/latest/), and for additional
documentation see the `fpdf.fpdf` submodule.

&#34;&#34;&#34;

from .fpdf import (
    FPDF_VERSION as _FPDF_VERSION,
    FPDF_CACHE_MODE as _FPDF_CACHE_MODE,
    FPDF_FONT_DIR as _FPDF_FONT_DIR,
    FPDF_CACHE_DIR as _FPDF_CACHE_DIR,
    SYSTEM_TTFONTS as _SYSTEM_TTFONTS,
)

FPDF_VERSION = _FPDF_VERSION
&#34;&#34;&#34;Current FPDF Version, also available via `__version__` (which is read by
`setup.py`):

&lt;pre&gt;
&gt;&gt;&gt; import fpdf
&gt;&gt;&gt; fpdf.__version__
&#39;1.7.3&#39;
&lt;/pre&gt;
&#34;&#34;&#34;

FPDF_CACHE_MODE = _FPDF_CACHE_MODE

FPDF_CACHE_DIR = _FPDF_CACHE_DIR
&#34;&#34;&#34;This is the directory where pickle files for TTF font files are kept
containing meta-data and stuffs.
&#34;&#34;&#34;

FPDF_FONT_DIR = _FPDF_FONT_DIR
&#34;&#34;&#34;This is the location of where to look for fonts.&#34;&#34;&#34;

SYSTEM_TTFONTS = _SYSTEM_TTFONTS
&#34;&#34;&#34;This is the directory searched for fonts when a font file path is not
given.
&#34;&#34;&#34;

from .fpdf import FPDF

__license__ = &#34;LGPL 3.0&#34;
&#34;&#34;&#34;LGPL 3.0 license&#34;&#34;&#34;
__version__ = FPDF_VERSION
&#34;&#34;&#34;Version as reflected in `setup.py` and PyPI.&#34;&#34;&#34;

try:
    from .html import HTMLMixin
except ImportError as e:
    import warnings

    warnings.warn(&#34;web2py gluon package not installed, required for html2pdf&#34;)

from .template import Template

__all__ = [
    # metadata
    &#34;__version__&#34;,
    &#34;__license__&#34;,
    # Classes
    &#34;FPDF&#34;,
    &#34;Template&#34;,
    &#34;HTMLMixin&#34;,
    # FPDF Constants
    &#34;FPDF_VERSION&#34;,
    &#34;FPDF_CACHE_MODE&#34;,
    &#34;FPDF_CACHE_DIR&#34;,
    &#34;FPDF_FONT_DIR&#34;,
    &#34;SYSTEM_TTFONTS&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fpdf.errors" href="errors.html">fpdf.errors</a></code></dt>
<dd>
<div class="desc"><p>FPDF Error classes</p></div>
</dd>
<dt><code class="name"><a title="fpdf.fonts" href="fonts.html">fpdf.fonts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.fpdf" href="fpdf.html">fpdf.fpdf</a></code></dt>
<dd>
<div class="desc"><p>fpdf module (in fpdf package housing FPDF class) …</p></div>
</dd>
<dt><code class="name"><a title="fpdf.html" href="html.html">fpdf.html</a></code></dt>
<dd>
<div class="desc"><p>HTML Renderer for FPDF.py</p></div>
</dd>
<dt><code class="name"><a title="fpdf.image_parsing" href="image_parsing.html">fpdf.image_parsing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.php" href="php.html">fpdf.php</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.template" href="template.html">fpdf.template</a></code></dt>
<dd>
<div class="desc"><p>PDF Template Helper for FPDF.py</p></div>
</dd>
<dt><code class="name"><a title="fpdf.ttfonts" href="ttfonts.html">fpdf.ttfonts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.util" href="util/index.html">fpdf.util</a></code></dt>
<dd>
<div class="desc"><p>Utility Functions (previously FPDF#methods)</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="fpdf.FPDF_CACHE_DIR"><code class="name">var <span class="ident">FPDF_CACHE_DIR</span></code></dt>
<dd>
<div class="desc"><p>This is the directory where pickle files for TTF font files are kept
containing meta-data and stuffs.</p></div>
</dd>
<dt id="fpdf.FPDF_FONT_DIR"><code class="name">var <span class="ident">FPDF_FONT_DIR</span></code></dt>
<dd>
<div class="desc"><p>This is the location of where to look for fonts.</p></div>
</dd>
<dt id="fpdf.FPDF_VERSION"><code class="name">var <span class="ident">FPDF_VERSION</span></code></dt>
<dd>
<div class="desc"><p>Current FPDF Version, also available via <code>__version__</code> (which is read by
<code>setup.py</code>):</p>
<pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; import fpdf
&gt;&gt;&gt; fpdf.__version__
'1.7.3'
&lt;/pre&gt;
</code></pre></div>
</dd>
<dt id="fpdf.SYSTEM_TTFONTS"><code class="name">var <span class="ident">SYSTEM_TTFONTS</span></code></dt>
<dd>
<div class="desc"><p>This is the directory searched for fonts when a font file path is not
given.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.FPDF"><code class="flex name class">
<span>class <span class="ident">FPDF</span></span>
<span>(</span><span>orientation='P', unit='mm', format='A4')</span>
</code></dt>
<dd>
<div class="desc"><p>PDF Generation class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FPDF(object):
    &#34;PDF Generation class&#34;

    def __init__(self, orientation=&#34;P&#34;, unit=&#34;mm&#34;, format=&#34;A4&#34;):
        # Initialization of properties
        self.offsets = {}  # array of object offsets
        self.page = 0  # current page number
        self.n = 2  # current object number
        self.buffer = bytearray()  # buffer holding in-memory PDF
        self.pages = {}  # array containing pages and metadata
        self.state = 0  # current document state
        self.fonts = {}  # array of used fonts
        self.font_files = {}  # array of font files
        self.diffs = {}  # array of encoding differences
        self.images = {}  # array of used images
        self.page_links = {}  # array of links in pages
        self.links = {}  # array of internal links
        self.in_footer = 0  # flag set when processing footer
        self.lasth = 0  # height of last cell printed
        self.font_family = &#34;&#34;  # current font family
        self.font_style = &#34;&#34;  # current font style
        self.font_size_pt = 12  # current font size in points
        self.font_stretching = 100  # current font stretching
        self.underline = 0  # underlining flag
        self.draw_color = &#34;0 G&#34;
        self.fill_color = &#34;0 g&#34;
        self.text_color = &#34;0 g&#34;
        # indicates whether fill and text colors are different
        self.color_flag = 0
        self.ws = 0  # word spacing
        self.angle = 0

        # Standard fonts
        self.core_fonts = {
            &#34;courier&#34;: &#34;Courier&#34;,
            &#34;courierB&#34;: &#34;Courier-Bold&#34;,
            &#34;courierI&#34;: &#34;Courier-Oblique&#34;,
            &#34;courierBI&#34;: &#34;Courier-BoldOblique&#34;,
            &#34;helvetica&#34;: &#34;Helvetica&#34;,
            &#34;helveticaB&#34;: &#34;Helvetica-Bold&#34;,
            &#34;helveticaI&#34;: &#34;Helvetica-Oblique&#34;,
            &#34;helveticaBI&#34;: &#34;Helvetica-BoldOblique&#34;,
            &#34;times&#34;: &#34;Times-Roman&#34;,
            &#34;timesB&#34;: &#34;Times-Bold&#34;,
            &#34;timesI&#34;: &#34;Times-Italic&#34;,
            &#34;timesBI&#34;: &#34;Times-BoldItalic&#34;,
            &#34;symbol&#34;: &#34;Symbol&#34;,
            &#34;zapfdingbats&#34;: &#34;ZapfDingbats&#34;,
        }
        self.core_fonts_encoding = &#34;latin-1&#34;

        # Scale factor
        if unit == &#34;pt&#34;:
            self.k = 1
        elif unit == &#34;mm&#34;:
            self.k = 72 / 25.4
        elif unit == &#34;cm&#34;:
            self.k = 72 / 2.54
        elif unit == &#34;in&#34;:
            self.k = 72.0
        else:
            fpdf_error(&#34;Incorrect unit: &#34; + unit)

        # Page format
        self.dw_pt, self.dh_pt = get_page_format(format, self.k)

        # Page orientation
        orientation = orientation.lower()
        if orientation in (&#34;p&#34;, &#34;portrait&#34;):
            self.def_orientation = &#34;P&#34;
            self.w_pt = self.dw_pt
            self.h_pt = self.dh_pt
        elif orientation in (&#34;l&#34;, &#34;landscape&#34;):
            self.def_orientation = &#34;L&#34;
            self.w_pt = self.dh_pt
            self.h_pt = self.dw_pt
        else:
            fpdf_error(&#34;Incorrect orientation: &#34; + orientation)
        self.cur_orientation = self.def_orientation
        self.w = self.w_pt / self.k
        self.h = self.h_pt / self.k

        # Page spacing
        # Page margins (1 cm)
        margin = 28.35 / self.k
        self.set_margins(margin, margin)
        self.c_margin = margin / 10.0  # Interior cell margin (1 mm)
        self.line_width = 0.567 / self.k  # line width (0.2 mm)
        self.set_auto_page_break(1, 2 * margin)  # Automatic page break
        self.set_display_mode(&#34;fullwidth&#34;)  # Full width display mode
        self.set_compression(True)  # Enable compression
        self.pdf_version = &#34;1.3&#34;  # Set default PDF version No.

    def check_page(fn):
        &#34;Decorator to protect drawing methods&#34;

        @wraps(fn)
        def wrapper(self, *args, **kwargs):
            if not self.page and not kwargs.get(&#34;split_only&#34;):
                fpdf_error(&#34;No page open, you need to call add_page() first&#34;)
            else:
                return fn(self, *args, **kwargs)

        return wrapper

    def set_margins(self, left, top, right=-1):
        &#34;Set left, top and right margins&#34;
        self.l_margin = left
        self.t_margin = top
        if right == -1:
            right = left
        self.r_margin = right

    def set_left_margin(self, margin):
        &#34;Set left margin&#34;
        self.l_margin = margin
        if self.page &gt; 0 and self.x &lt; margin:
            self.x = margin

    def set_top_margin(self, margin):
        &#34;Set top margin&#34;
        self.t_margin = margin

    def set_right_margin(self, margin):
        &#34;Set right margin&#34;
        self.r_margin = margin

    def set_auto_page_break(self, auto, margin=0):
        &#34;Set auto page break mode and triggering margin&#34;
        self.auto_page_break = auto
        self.b_margin = margin
        self.page_break_trigger = self.h - margin

    def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
        &#34;&#34;&#34;Set display mode in viewer

        The &#34;zoom&#34; argument may be &#39;fullpage&#39;, &#39;fullwidth&#39;, &#39;real&#39;,
        &#39;default&#39;, or a number, interpreted as a percentage.
        &#34;&#34;&#34;
        if zoom in [&#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;]:
            self.zoom_mode = zoom
        elif not isinstance(zoom, str):
            self.zoom_mode = zoom
        else:
            fpdf_error(&#34;Incorrect zoom display mode: &#34; + zoom)

        if layout in [&#34;single&#34;, &#34;continuous&#34;, &#34;two&#34;, &#34;default&#34;]:
            self.layout_mode = layout
        else:
            fpdf_error(&#34;Incorrect layout display mode: &#34; + layout)

    def set_compression(self, compress):
        &#34;Set page compression&#34;
        self.compress = compress

    def set_title(self, title):
        &#34;Title of document&#34;
        self.title = title

    def set_subject(self, subject):
        &#34;Subject of document&#34;
        self.subject = subject

    def set_author(self, author):
        &#34;Author of document&#34;
        self.author = author

    def set_keywords(self, keywords):
        &#34;Keywords of document&#34;
        self.keywords = keywords

    def set_creator(self, creator):
        &#34;Creator of document&#34;
        self.creator = creator

    def set_creation_date(self, date=None):
        &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
        self.creation_date = datetime.now() if date is None else date

    def set_doc_option(self, opt, value):
        &#34;Set document option&#34;
        if opt == &#34;core_fonts_encoding&#34;:
            self.core_fonts_encoding = value
        else:
            fpdf_error(&#39;Unknown document option &#34;%s&#34;&#39; % str(opt))

    def alias_nb_pages(self, alias=&#34;{nb}&#34;):
        &#34;Define an alias for total number of pages&#34;
        self.str_alias_nb_pages = alias
        return alias

    def open(self):
        &#34;Begin document&#34;
        self.state = 1

    def close(self):
        &#34;Terminate document&#34;
        if self.state == 3:
            return
        if self.page == 0:
            self.add_page()

        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0

        self._endpage()  # close page
        self._enddoc()  # close document

    def add_page(self, orientation=&#34;&#34;, format=&#34;&#34;, same=False):
        &#34;Start a new page, if same page format will be same as previous&#34;
        if self.state == 0:
            self.open()
        family = self.font_family
        style = self.font_style + &#34;U&#34; if self.underline else self.font_style
        size = self.font_size_pt
        lw = self.line_width
        dc = self.draw_color
        fc = self.fill_color
        tc = self.text_color
        cf = self.color_flag
        stretching = self.font_stretching
        if self.page &gt; 0:
            # Page footer
            self.in_footer = 1
            self.footer()
            self.in_footer = 0
            # close page
            self._endpage()

        # Start new page
        self._beginpage(orientation, format, same)
        self._out(&#34;2 J&#34;)  # Set line cap style to square
        self.line_width = lw  # Set line width
        self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

        # Set font
        if family:
            self.set_font(family, style, size)

        # Set colors
        self.draw_color = dc
        if dc != &#34;0 G&#34;:
            self._out(dc)
        self.fill_color = fc
        if fc != &#34;0 g&#34;:
            self._out(fc)
        self.text_color = tc
        self.color_flag = cf

        &#34;&#34;&#34; BEGIN Page header &#34;&#34;&#34;
        self.header()

        if self.line_width != lw:  # Restore line width
            self.line_width = lw
            self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

        if family:
            self.set_font(family, style, size)  # Restore font

        if self.draw_color != dc:  # Restore colors
            self.draw_color = dc
            self._out(dc)
        if self.fill_color != fc:
            self.fill_color = fc
            self._out(fc)
        self.text_color = tc
        self.color_flag = cf

        if stretching != 100:  # Restore stretching
            self.set_stretching(stretching)
        &#34;&#34;&#34; END Page header &#34;&#34;&#34;

    def header(self):
        &#34;Header to be implemented in your own inherited class&#34;
        pass

    def footer(self):
        &#34;Footer to be implemented in your own inherited class&#34;
        pass

    def page_no(self):
        &#34;Get current page number&#34;
        return self.page

    def set_draw_color(self, r, g=-1, b=-1):
        &#34;Set color for all stroking operations&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.draw_color = sprintf(&#34;%.3f G&#34;, r / 255.0)
        else:
            self.draw_color = sprintf(
                &#34;%.3f %.3f %.3f RG&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        if self.page &gt; 0:
            self._out(self.draw_color)

    def set_fill_color(self, r, g=-1, b=-1):
        &#34;Set color for all filling operations&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.fill_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
        else:
            self.fill_color = sprintf(
                &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        self.color_flag = self.fill_color != self.text_color
        if self.page &gt; 0:
            self._out(self.fill_color)

    def set_text_color(self, r, g=-1, b=-1):
        &#34;Set color for text&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.text_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
        else:
            self.text_color = sprintf(
                &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        self.color_flag = self.fill_color != self.text_color

    def get_string_width(self, s, normalized=False):
        &#34;Get width of a string in the current font&#34;
        # normalized is parameter for internal use
        s = s if normalized else self.normalize_text(s)
        cw = self.current_font[&#34;cw&#34;]
        w = 0
        l = len(s)
        if self.unifontsubset:
            for char in s:
                char = ord(char)
                if len(cw) &gt; char:
                    w += cw[char]
                elif self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]:
                    w += self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]
                else:
                    w += 500
        else:
            for i in range(0, l):
                w += cw.get(s[i], 0)
        if self.font_stretching != 100:
            w = w * self.font_stretching / 100.0
        return w * self.font_size / 1000.0

    def set_line_width(self, width):
        &#34;Set line width&#34;
        self.line_width = width
        if self.page &gt; 0:
            self._out(sprintf(&#34;%.2f w&#34;, width * self.k))

    @check_page
    def line(self, x1, y1, x2, y2):
        &#34;Draw a line&#34;
        self._out(
            sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S&#34;,
                x1 * self.k,
                (self.h - y1) * self.k,
                x2 * self.k,
                (self.h - y2) * self.k,
            )
        )

    def _set_dash(self, dash_length=False, space_length=False):
        if dash_length and space_length:
            s = sprintf(&#34;[%.3f %.3f] 0 d&#34;, dash_length * self.k, space_length * self.k)
        else:
            s = &#34;[] 0 d&#34;
        self._out(s)

    @check_page
    def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
        &#34;&#34;&#34;Draw a dashed line. Same interface as line() except:
        - dash_length: Length of the dash
        - space_length: Length of the space between dashes&#34;&#34;&#34;
        self._set_dash(dash_length, space_length)
        self.line(x1, y1, x2, y2)
        self._set_dash()

    @check_page
    def rect(self, x, y, w, h, style=None):
        &#34;Draw a rectangle&#34;
        style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
        op = style_to_operators.get(style, &#34;S&#34;)
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f re %s&#34;,
                x * self.k,
                (self.h - y) * self.k,
                w * self.k,
                -h * self.k,
                op,
            )
        )

    @check_page
    def ellipse(self, x, y, w, h, style=None):
        &#34;Draw a ellipse&#34;
        style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
        op = style_to_operators.get(style, &#34;S&#34;)

        cx = x + w / 2.0
        cy = y + h / 2.0
        rx = w / 2.0
        ry = h / 2.0

        lx = 4.0 / 3.0 * (math.sqrt(2) - 1) * rx
        ly = 4.0 / 3.0 * (math.sqrt(2) - 1) * ry

        self._out(
            sprintf(
                &#34;%.2f %.2f m %.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx + rx) * self.k,
                (self.h - cy) * self.k,
                (cx + rx) * self.k,
                (self.h - (cy - ly)) * self.k,
                (cx + lx) * self.k,
                (self.h - (cy - ry)) * self.k,
                cx * self.k,
                (self.h - (cy - ry)) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx - lx) * self.k,
                (self.h - (cy - ry)) * self.k,
                (cx - rx) * self.k,
                (self.h - (cy - ly)) * self.k,
                (cx - rx) * self.k,
                (self.h - cy) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx - rx) * self.k,
                (self.h - (cy + ly)) * self.k,
                (cx - lx) * self.k,
                (self.h - (cy + ry)) * self.k,
                cx * self.k,
                (self.h - (cy + ry)) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c %s&#34;,
                (cx + lx) * self.k,
                (self.h - (cy + ry)) * self.k,
                (cx + rx) * self.k,
                (self.h - (cy + ly)) * self.k,
                (cx + rx) * self.k,
                (self.h - cy) * self.k,
                op,
            )
        )

    def add_font(self, family, style=&#34;&#34;, fname=None, uni=False):
        &#34;Add a TrueType or Type1 font&#34;
        family = family.lower()
        if not fname:
            fname = family.replace(&#34; &#34;, &#34;&#34;) + style.lower() + &#34;.pkl&#34;

        if family == &#34;arial&#34;:
            family = &#34;helvetica&#34;
        style = style.upper()
        if style == &#34;IB&#34;:
            style = &#34;BI&#34;
        fontkey = family + style

        # Font already added!
        if fontkey in self.fonts:
            return
        if uni:
            global SYSTEM_TTFONTS, FPDF_CACHE_MODE, FPDF_CACHE_DIR
            if os.path.exists(fname):
                ttffilename = fname
            elif FPDF_FONT_DIR and os.path.exists(os.path.join(FPDF_FONT_DIR, fname)):
                ttffilename = os.path.join(FPDF_FONT_DIR, fname)
            elif SYSTEM_TTFONTS and os.path.exists(os.path.join(SYSTEM_TTFONTS, fname)):
                ttffilename = os.path.join(SYSTEM_TTFONTS, fname)
            else:
                raise RuntimeError(&#34;TTF Font file not found: %s&#34; % fname)
            name = &#34;&#34;  # noqa: F841
            if FPDF_CACHE_MODE == 0:
                unifilename = os.path.splitext(ttffilename)[0] + &#34;.pkl&#34;
            elif FPDF_CACHE_MODE == 2:
                unifilename = os.path.join(
                    FPDF_CACHE_DIR, _hashpath(ttffilename) + &#34;.pkl&#34;
                )
            else:
                unifilename = None

            font_dict = load_cache(unifilename)
            if font_dict is None:
                ttf = TTFontFile()
                ttf.getMetrics(ttffilename)
                desc = {
                    &#34;Ascent&#34;: int(round(ttf.ascent, 0)),
                    &#34;Descent&#34;: int(round(ttf.descent, 0)),
                    &#34;CapHeight&#34;: int(round(ttf.capHeight, 0)),
                    &#34;Flags&#34;: ttf.flags,
                    &#34;FontBBox&#34;: &#34;[%s %s %s %s]&#34;
                    % (
                        int(round(ttf.bbox[0], 0)),
                        int(round(ttf.bbox[1], 0)),
                        int(round(ttf.bbox[2], 0)),
                        int(round(ttf.bbox[3], 0)),
                    ),
                    &#34;ItalicAngle&#34;: int(ttf.italicAngle),
                    &#34;StemV&#34;: int(round(ttf.stemV, 0)),
                    &#34;MissingWidth&#34;: int(round(ttf.defaultWidth, 0)),
                }

                # Generate metrics .pkl file
                font_dict = {
                    &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
                    &#34;type&#34;: &#34;TTF&#34;,
                    &#34;desc&#34;: desc,
                    &#34;up&#34;: round(ttf.underlinePosition),
                    &#34;ut&#34;: round(ttf.underlineThickness),
                    &#34;ttffile&#34;: ttffilename,
                    &#34;fontkey&#34;: fontkey,
                    &#34;originalsize&#34;: os.stat(ttffilename).st_size,
                    &#34;cw&#34;: ttf.charWidths,
                }

                if unifilename:
                    try:
                        with open(unifilename, &#34;wb&#34;) as fh:
                            pickle.dump(font_dict, fh)
                    except IOError as e:
                        if not e.errno == errno.EACCES:
                            raise  # Not a permission error.
                del ttf

            # include numbers in the subset! (if alias present)
            have_page_alias = lambda: hasattr(self, &#34;str_alias_nb_pages&#34;)
            sbarr = list(range(0, 57 if have_page_alias() else 32))

            self.fonts[fontkey] = {
                &#34;i&#34;: len(self.fonts) + 1,
                &#34;type&#34;: font_dict[&#34;type&#34;],
                &#34;name&#34;: font_dict[&#34;name&#34;],
                &#34;desc&#34;: font_dict[&#34;desc&#34;],
                &#34;up&#34;: font_dict[&#34;up&#34;],
                &#34;ut&#34;: font_dict[&#34;ut&#34;],
                &#34;cw&#34;: font_dict[&#34;cw&#34;],
                &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
                &#34;fontkey&#34;: fontkey,
                &#34;subset&#34;: sbarr,
                &#34;unifilename&#34;: unifilename,
            }
            self.font_files[fontkey] = {
                &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;ttffile&#34;: ttffilename,
            }
            self.font_files[fname] = {&#34;type&#34;: &#34;TTF&#34;}
        else:
            with open(fname, &#34;rb&#34;) as fontfile:
                font_dict = pickle.load(fontfile)
            self.fonts[fontkey] = {&#34;i&#34;: len(self.fonts) + 1}
            self.fonts[fontkey].update(font_dict)
            diff = font_dict.get(&#34;diff&#34;)
            if diff:
                # Search existing encodings
                d = 0
                nb = len(self.diffs)
                for i in range(1, nb + 1):
                    if self.diffs[i] == diff:
                        d = i
                        break
                if d == 0:
                    d = nb + 1
                    self.diffs[d] = diff
                self.fonts[fontkey][&#34;diff&#34;] = d
            filename = font_dict.get(&#34;filename&#34;)
            if filename:
                if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                    originalsize = font_dict[&#34;originalsize&#34;]
                    self.font_files[filename] = {&#34;length1&#34;: originalsize}
                else:
                    self.font_files[filename] = {
                        &#34;length1&#34;: font_dict[&#34;size1&#34;],
                        &#34;length2&#34;: font_dict[&#34;size2&#34;],
                    }

    def set_font(self, family, style=&#34;&#34;, size=0):
        &#34;Select a font; size given in points&#34;
        family = family.lower()
        if family == &#34;&#34;:
            family = self.font_family
        if family == &#34;arial&#34;:
            family = &#34;helvetica&#34;
        elif family == &#34;symbol&#34; or family == &#34;zapfdingbats&#34;:
            style = &#34;&#34;
        style = style.upper()
        if &#34;U&#34; in style:
            self.underline = 1
            style = style.replace(&#34;U&#34;, &#34;&#34;)
        else:
            self.underline = 0
        if style == &#34;IB&#34;:
            style = &#34;BI&#34;
        if size == 0:
            size = self.font_size_pt

        # Test if font is already selected
        if (
            self.font_family == family
            and self.font_style == style
            and self.font_size_pt == size
        ):
            return

        # Test if used for the first time
        fontkey = family + style
        if fontkey not in self.fonts:
            # Check if one of standard fonts
            if fontkey in self.core_fonts:
                if fontkey not in fpdf_charwidths:
                    # Load metric file
                    name = os.path.join(FPDF_FONT_DIR, family)
                    if family == &#34;times&#34; or family == &#34;helvetica&#34;:
                        name += style.lower()
                    with open(name + &#34;.font&#34;) as file:
                        exec(compile(file.read(), name + &#34;.font&#34;, &#34;exec&#34;))
                    if fontkey not in fpdf_charwidths:
                        fpdf_error(&#34;Could not include font metric file for&#34; + fontkey)
                i = len(self.fonts) + 1
                self.fonts[fontkey] = {
                    &#34;i&#34;: i,
                    &#34;type&#34;: &#34;core&#34;,
                    &#34;name&#34;: self.core_fonts[fontkey],
                    &#34;up&#34;: -100,
                    &#34;ut&#34;: 50,
                    &#34;cw&#34;: fpdf_charwidths[fontkey],
                }
            else:
                fpdf_error(&#34;Undefined font: &#34; + family + &#34; &#34; + style)

        # Select it
        self.font_family = family
        self.font_style = style
        self.font_size_pt = size
        self.font_size = size / self.k
        self.current_font = self.fonts[fontkey]
        self.unifontsubset = self.fonts[fontkey][&#34;type&#34;] == &#34;TTF&#34;
        if self.page &gt; 0:
            self._out(
                sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
            )

    def set_font_size(self, size):
        &#34;Set font size in points&#34;
        if self.font_size_pt == size:
            return
        self.font_size_pt = size
        self.font_size = size / self.k
        if self.page &gt; 0:
            self._out(
                sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
            )

    def set_stretching(self, factor):
        &#34;Set from stretch factor percents (default: 100.0)&#34;
        if self.font_stretching == factor:
            return
        self.font_stretching = factor
        if self.page &gt; 0:
            self._out(sprintf(&#34;BT %.2f Tz ET&#34;, self.font_stretching))

    def add_link(self):
        &#34;Create a new internal link&#34;
        n = len(self.links) + 1
        self.links[n] = (0, 0)
        return n

    def set_link(self, link, y=0, page=-1):
        &#34;Set destination of internal link&#34;
        if y == -1:
            y = self.y
        if page == -1:
            page = self.page

        self.links[link] = [page, y]

    def link(self, x, y, w, h, link, alt_text=&#34;&#34;):
        &#34;Put a link on the page&#34;
        if self.page not in self.page_links:
            self.page_links[self.page] = []
        self.page_links[self.page] += [
            (x * self.k, self.h_pt - y * self.k, w * self.k, h * self.k, link, alt_text)
        ]

    @check_page
    def text(self, x, y, txt=&#34;&#34;):
        &#34;Output a string&#34;
        txt = self.normalize_text(txt)
        if self.unifontsubset:
            txt2 = UTF8ToUTF16BE(escape_parens(txt), False)
            for uni in UTF8StringToArray(txt):
                self.current_font[&#34;subset&#34;].append(uni)
        else:
            txt2 = escape_parens(txt)
        s = sprintf(
            &#34;BT %.2f %.2f Td (%s) Tj ET&#34;, x * self.k, (self.h - y) * self.k, txt2
        )
        if self.underline and txt != &#34;&#34;:
            s += &#34; &#34; + self._dounderline(x, y, txt)
        if self.color_flag:
            s = &#34;q &#34; + self.text_color + &#34; &#34; + s + &#34; Q&#34;
        self._out(s)

    @check_page
    def rotate(self, angle, x=None, y=None):
        warnings.warn(
            &#34;rotate() can produces malformed PDFs and is deprecated. Use the rotation() context manager instead.&#34;,
            PendingDeprecationWarning,
        )
        if x is None:
            x = self.x
        if y is None:
            y = self.y

        if self.angle != 0:
            self._out(&#34;Q&#34;)
        self.angle = angle
        if angle != 0:
            angle *= math.pi / 180
            c = math.cos(angle)
            s = math.sin(angle)
            cx = x * self.k
            cy = (self.h - y) * self.k
            s = sprintf(
                &#34;q %.5F %.5F %.5F %.5F %.2F %.2F &#34; + &#34;cm 1 0 0 1 %.2F %.2F cm&#34;,
                c,
                s,
                -s,
                c,
                cx,
                cy,
                -cx,
                -cy,
            )
            self._out(s)

    @check_page
    @contextmanager
    def rotation(self, angle, x=None, y=None):
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        angle *= math.pi / 180
        c, s = math.cos(angle), math.sin(angle)
        cx, cy = x * self.k, (self.h - y) * self.k
        self._out(
            sprintf(
                &#34;q %.5F %.5F %.5F %.5F %.2F %.2F cm 1 0 0 1 %.2F %.2F cm\n&#34;,
                c,
                s,
                -s,
                c,
                cx,
                cy,
                -cx,
                -cy,
            )
        )
        yield
        self._out(&#34;Q\n&#34;)

    @property
    def accept_page_break(self):
        &#34;Accept automatic page break or not&#34;
        return self.auto_page_break

    @check_page
    def cell(self, w, h=0, txt=&#34;&#34;, border=0, ln=0, align=&#34;&#34;, fill=0, link=&#34;&#34;):
        &#34;Output a cell, return boolean if triggered auto page break&#34;
        page_break_triggered = False
        txt = self.normalize_text(txt)
        k = self.k
        if (
            self.y + h &gt; self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        ):

            # Automatic page break
            page_break_triggered = True
            x = self.x
            ws = self.ws
            if ws &gt; 0:
                self.ws = 0
                self._out(&#34;0 Tw&#34;)
            self.add_page(same=True)
            self.x = x  # restore x but not y after drawing header

            if ws &gt; 0:
                self.ws = ws
                self._out(sprintf(&#34;%.3f Tw&#34;, ws * k))
        if w == 0:
            w = self.w - self.r_margin - self.x
        s = &#34;&#34;

        if fill == 1 or border == 1:
            if fill == 1:
                if border == 1:
                    op = &#34;B&#34;
                else:
                    op = &#34;f&#34;
            else:
                op = &#34;S&#34;
            s = sprintf(
                &#34;%.2f %.2f %.2f %.2f re %s &#34;,
                self.x * k,
                (self.h - self.y) * k,
                w * k,
                -h * k,
                op,
            )

        if isinstance(border, str):
            x = self.x
            y = self.y
            if &#34;L&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - y) * k,
                    x * k,
                    (self.h - (y + h)) * k,
                )
            if &#34;T&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - y) * k,
                    (x + w) * k,
                    (self.h - y) * k,
                )
            if &#34;R&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    (x + w) * k,
                    (self.h - y) * k,
                    (x + w) * k,
                    (self.h - (y + h)) * k,
                )
            if &#34;B&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - (y + h)) * k,
                    (x + w) * k,
                    (self.h - (y + h)) * k,
                )

        if txt != &#34;&#34;:
            if align == &#34;R&#34;:
                dx = w - self.c_margin - self.get_string_width(txt, True)
            elif align == &#34;C&#34;:
                dx = (w - self.get_string_width(txt, True)) / 2.0
            else:
                dx = self.c_margin
            if self.color_flag:
                s += &#34;q &#34; + self.text_color + &#34; &#34;

            # If multibyte, Tw has no effect - do word spacing using an
            # adjustment before each space
            if self.ws and self.unifontsubset:
                for uni in UTF8StringToArray(txt):
                    self.current_font[&#34;subset&#34;].append(uni)
                space = escape_parens(UTF8ToUTF16BE(&#34; &#34;, False))

                s += sprintf(
                    &#34;BT 0 Tw %.2F %.2F Td [&#34;,
                    (self.x + dx) * k,
                    (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
                )

                t = txt.split(&#34; &#34;)
                numt = len(t)
                for i in range(numt):
                    tx = t[i]
                    tx = enclose_in_parens(escape_parens(UTF8ToUTF16BE(tx, False)))
                    s += sprintf(&#34;%s &#34;, tx)
                    if (i + 1) &lt; numt:
                        adj = -(self.ws * self.k) * 1000 / self.font_size_pt
                        s += sprintf(&#34;%d(%s) &#34;, adj, space)
                s += &#34;] TJ&#34;
                s += &#34; ET&#34;
            else:
                if self.unifontsubset:
                    txt2 = escape_parens(UTF8ToUTF16BE(txt, False))
                    for uni in UTF8StringToArray(txt):
                        self.current_font[&#34;subset&#34;].append(uni)
                else:
                    txt2 = escape_parens(txt)

                s += sprintf(
                    &#34;BT %.2f %.2f Td (%s) Tj ET&#34;,
                    (self.x + dx) * k,
                    (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
                    txt2,
                )

            if self.underline:
                s += &#34; &#34; + self._dounderline(
                    self.x + dx, self.y + (0.5 * h) + (0.3 * self.font_size), txt
                )
            if self.color_flag:
                s += &#34; Q&#34;
            if link:
                self.link(
                    self.x + dx,
                    self.y + (0.5 * h) - (0.5 * self.font_size),
                    self.get_string_width(txt, True),
                    self.font_size,
                    link,
                )

        if s:
            self._out(s)
        self.lasth = h

        if ln &gt; 0:
            self.y += h  # Go to next line
            if ln == 1:
                self.x = self.l_margin
        else:
            self.x += w

        return page_break_triggered

    @check_page
    def multi_cell(
        self, w, h, txt=&#34;&#34;, border=0, align=&#34;J&#34;, fill=0, split_only=False, link=&#34;&#34;, ln=0
    ):
        &#34;&#34;&#34;Output text with automatic or explicit line breaks, returns
        boolean if page break triggered in output mode
        &#34;&#34;&#34;
        page_break_triggered = False
        if split_only:
            _out, _add_page = self._out, self.add_page
            self._out = lambda *args, **kwargs: None
            self.add_page = lambda *args, **kwargs: None

        # Store this information for manipulating position.
        location = (self.get_x(), self.get_y())

        # If width is 0, set width to available width between margins
        if w == 0:
            w = self.w - self.r_margin - self.x
        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size

        # Calculate text length
        txt = self.normalize_text(txt)
        s = txt.replace(&#34;\r&#34;, &#34;&#34;)
        normalized_string_length = len(s)
        if normalized_string_length &gt; 0 and s[-1] == &#34;\n&#34;:
            normalized_string_length -= 1

        b = 0
        if border:
            if border == 1:
                border = &#34;LTRB&#34;
                b = &#34;LRT&#34;
                b2 = &#34;LR&#34;
            else:
                b2 = &#34;&#34;
                if &#34;L&#34; in border:
                    b2 += &#34;L&#34;
                if &#34;R&#34; in border:
                    b2 += &#34;R&#34;
                if &#34;T&#34; in border:
                    b = b2 + &#34;T&#34;
                else:
                    b = b2

        character_widths = self.current_font[&#34;cw&#34;]
        text_cells = []
        sep = -1
        i = 0
        j = 0
        l = 0
        ns = 0
        nl = 1
        while i &lt; normalized_string_length:
            # Get next character
            c = s[i]

            # Explicit line break
            if c == &#34;\n&#34;:
                if self.ws &gt; 0:
                    self.ws = 0
                    self._out(&#34;0 Tw&#34;)

                new_page = self.cell(
                    w,
                    h=h,
                    txt=substr(s, j, i - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, i - j))

                i += 1
                sep = -1
                j = i
                l = 0
                ns = 0
                nl += 1
                if border and nl == 2:
                    b = b2
                continue

            if c == &#34; &#34;:
                sep = i
                ls = l
                ns += 1
            if self.unifontsubset:
                l += self.get_string_width(c, True) / self.font_size * 1000.0
            else:
                l += character_widths.get(c, 0)

            # Automatic line break
            if l &gt; wmax:
                if sep == -1:
                    if i == j:
                        i += 1
                    if self.ws &gt; 0:
                        self.ws = 0
                        self._out(&#34;0 Tw&#34;)

                    new_page = self.cell(
                        w,
                        h=h,
                        txt=substr(s, j, i - j),
                        border=b,
                        ln=2,
                        align=align,
                        fill=fill,
                        link=link,
                    )
                    page_break_triggered = page_break_triggered or new_page
                    text_cells.append(substr(s, j, i - j))

                else:
                    if align == &#34;J&#34;:
                        if ns &gt; 1:
                            self.ws = (wmax - ls) / 1000.0 * self.font_size / (ns - 1)
                        else:
                            self.ws = 0
                        self._out(sprintf(&#34;%.3f Tw&#34;, self.ws * self.k))

                    new_page = self.cell(
                        w,
                        h=h,
                        txt=substr(s, j, sep - j),
                        border=b,
                        ln=2,
                        align=align,
                        fill=fill,
                        link=link,
                    )
                    page_break_triggered = page_break_triggered or new_page
                    text_cells.append(substr(s, j, sep - j))

                    i = sep + 1
                sep = -1
                j = i
                l = 0
                ns = 0
                nl += 1
                if border and nl == 2:
                    b = b2
            else:
                i += 1

        # Last chunk
        if self.ws &gt; 0:
            self.ws = 0
            self._out(&#34;0 Tw&#34;)
        if border and &#34;B&#34; in border:
            b += &#34;B&#34;

        new_page = self.cell(
            w,
            h=h,
            txt=substr(s, j, i - j),
            border=b,
            ln=2,
            align=align,
            fill=fill,
            link=link,
        )
        page_break_triggered = page_break_triggered or new_page
        text_cells.append(substr(s, j, i - j))

        location_options = {
            0: lambda: self.set_xy(location[0] + w, location[1]),
            1: lambda: self.set_x(self.l_margin),  # could control y
            2: lambda: None,
        }
        location_options.get(ln, lambda: None)()

        if split_only:
            # restore writing functions
            self._out, self.add_page = _out, _add_page
            self.set_xy(*location)  # restore location
            return text_cells

        return page_break_triggered

    @check_page
    def write(self, h, txt=&#34;&#34;, link=&#34;&#34;):
        &#34;Output text in flowing mode&#34;
        txt = self.normalize_text(txt)
        cw = self.current_font[&#34;cw&#34;]
        w = self.w - self.r_margin - self.x
        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
        s = txt.replace(&#34;\r&#34;, &#34;&#34;)
        nb = len(s)
        sep = -1
        i = 0
        j = 0
        l = 0
        nl = 1
        while i &lt; nb:
            # Get next character
            c = s[i]
            if c == &#34;\n&#34;:
                # Explicit line break
                self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
                i += 1
                sep = -1
                j = i
                l = 0
                if nl == 1:
                    self.x = self.l_margin
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                nl += 1
                continue
            if c == &#34; &#34;:
                sep = i
            if self.unifontsubset:
                l += self.get_string_width(c, True) / self.font_size * 1000.0
            else:
                l += cw.get(c, 0)
            if l &gt; wmax:
                # Automatic line break
                if sep == -1:
                    if self.x &gt; self.l_margin:
                        # Move to next line
                        self.x = self.l_margin
                        self.y += h
                        w = self.w - self.r_margin - self.x
                        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                        i += 1
                        nl += 1
                        continue
                    if i == j:
                        i += 1
                    self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
                else:
                    self.cell(w, h, substr(s, j, sep - j), 0, 2, &#34;&#34;, 0, link)
                    i = sep + 1
                sep = -1
                j = i
                l = 0
                if nl == 1:
                    self.x = self.l_margin
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                nl += 1
            else:
                i += 1
        # Last chunk
        if i != j:
            self.cell(l / 1000.0 * self.font_size, h, substr(s, j), 0, 0, &#34;&#34;, 0, link)

    @check_page
    def image(
        self,
        name,
        x=None,
        y=None,
        w=0,
        h=0,
        type=&#34;&#34;,
        link=&#34;&#34;,
    ):
        # def image(self, name, x = None, y = None, w = 0, h = 0, type = &#39;&#39;, link = &#39;&#39;):  # noqa: E501
        &#34;Put an image on the page&#34;
        if name not in self.images:
            info = get_img_info(image_parsing_load_resource(name))
            info[&#34;i&#34;] = len(self.images) + 1
            self.images[name] = info
        else:
            info = self.images[name]

        # Automatic width and height calculation if needed
        if w == 0 and h == 0:
            # Put image at 72 dpi
            w = info[&#34;w&#34;] / self.k
            h = info[&#34;h&#34;] / self.k
        elif w == 0:
            w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
        elif h == 0:
            h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

        # Flowing mode
        if y is None:
            if (
                self.y + h &gt; self.page_break_trigger
                and not self.in_footer
                and self.accept_page_break
            ):
                # Automatic page break
                x = self.x
                self.add_page(same=True)
                self.x = x
            y = self.y
            self.y += h

        if x is None:
            x = self.x
        self._out(
            sprintf(
                &#34;q %.2f 0 0 %.2f %.2f %.2f cm /I%d Do Q&#34;,
                w * self.k,
                h * self.k,
                x * self.k,
                (self.h - (y + h)) * self.k,
                info[&#34;i&#34;],
            )
        )
        if link:
            self.link(x, y, w, h, link)

        return info

    @check_page
    def ln(self, h=None):
        &#34;Line Feed; default value is last cell height&#34;
        self.x = self.l_margin
        if h is None:
            self.y += self.lasth
        else:
            self.y += h

    def get_x(self):
        &#34;Get x position&#34;
        return self.x

    def set_x(self, x):
        &#34;Set x position&#34;
        if x &gt;= 0:
            self.x = x
        else:
            self.x = self.w + x

    def get_y(self):
        &#34;Get y position&#34;
        return self.y

    def set_y(self, y):
        &#34;Set y position and reset x&#34;
        self.x = self.l_margin
        if y &gt;= 0:
            self.y = y
        else:
            self.y = self.h + y

    def set_xy(self, x, y):
        &#34;Set x and y positions&#34;
        self.set_y(y)
        self.set_x(x)

    def output(self, name=&#34;&#34;, dest=&#34;&#34;):
        &#34;&#34;&#34;Output PDF to some destination

        By default the PDF is written to sys.stdout. If a name is given, the
        PDF is written to a new file. If dest=&#39;S&#39; is given, the PDF data is
        returned as a byte string.&#34;&#34;&#34;

        # Finish document if necessary
        if self.state &lt; 3:
            self.close()
        dest = dest.upper()
        if dest == &#34;&#34;:
            if name == &#34;&#34;:
                dest = &#34;I&#34;
            else:
                dest = &#34;F&#34;
        if dest in (&#34;I&#34;, &#34;D&#34;):
            # Python &lt; 3 writes byte data transparently without &#34;buffer&#34;
            stdout = getattr(sys.stdout, &#34;buffer&#34;, sys.stdout)
            stdout.write(self.buffer)
        elif dest == &#34;F&#34;:
            # Save to local file
            with open(name, &#34;wb&#34;) as f:
                f.write(self.buffer)
        # Return as a byte string
        elif dest == &#34;S&#34;:
            return self.buffer
        else:
            fpdf_error(&#34;Incorrect output destination: &#34; + dest)

    def normalize_text(self, txt):
        &#34;Check that text input is in the correct format/encoding&#34;
        # - for TTF unicode fonts: unicode object (utf8 encoding)
        # - for built-in fonts: string instances (encoding: latin-1, cp1252)
        if not self.unifontsubset and self.core_fonts_encoding:
            return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
        return txt

    def _putpages(self):
        nb = self.page
        if hasattr(self, &#34;str_alias_nb_pages&#34;):
            # Replace number of pages in fonts using subsets (unicode)
            alias = UTF8ToUTF16BE(self.str_alias_nb_pages, False)
            r = UTF8ToUTF16BE(str(nb), False)
            for n in range(1, nb + 1):
                self.pages[n][&#34;content&#34;] = self.pages[n][&#34;content&#34;].replace(alias, r)
            # Now repeat for no pages in non-subset fonts
            for n in range(1, nb + 1):
                self.pages[n][&#34;content&#34;].replace(
                    self.str_alias_nb_pages.encode(), str(nb).encode()
                )
        if self.def_orientation == &#34;P&#34;:
            dw_pt = self.dw_pt
            dh_pt = self.dh_pt
        else:
            dw_pt = self.dh_pt
            dh_pt = self.dw_pt
        if self.compress:
            filter = &#34;/Filter /FlateDecode &#34;
        else:
            filter = &#34;&#34;
        for n in range(1, nb + 1):
            # page object from pages[n]
            # page object from pages[n]#w_pt
            # page object from pages[n]#h_pt
            # page object from page_links[n] if page_links and page_links[n]
            # Page
            self._newobj()
            self._out(&#34;&lt;&lt;/Type /Page&#34;)
            self._out(&#34;/Parent 1 0 R&#34;)
            w_pt = self.pages[n][&#34;w_pt&#34;]
            h_pt = self.pages[n][&#34;h_pt&#34;]
            if w_pt != dw_pt or h_pt != dh_pt:
                self._out(sprintf(&#34;/MediaBox [0 0 %.2f %.2f]&#34;, w_pt, h_pt))
            self._out(&#34;/Resources 2 0 R&#34;)

            if self.page_links and n in self.page_links:
                # Links
                annots = &#34;/Annots [&#34;
                for pl in self.page_links[n]:
                    # first four things in &#39;link&#39; list are coordinates?
                    rect = sprintf(
                        &#34;%.2f %.2f %.2f %.2f&#34;,
                        pl[0],
                        pl[1],
                        pl[0] + pl[2],
                        pl[1] - pl[3],
                    )

                    # start the annotation entry
                    annots += (
                        &#34;&lt;&lt;/Type /Annot /Subtype /Link /Rect [&#34;
                        + rect
                        + &#34;] /Border [0 0 0] &#34;
                    )

                    # HTML ending of annotation entry
                    if isinstance(pl[4], str):
                        annots += (
                            &#34;/A &lt;&lt;/S /URI /URI &#34; + enclose_in_parens(pl[4]) + &#34;&gt;&gt;&gt;&gt;&#34;
                        )

                    # Dest type ending of annotation entry
                    else:
                        assert (
                            pl[4] in self.links
                        ), &#34;Page {} has a link with an invalid index: {} (doc #links={})&#34;.format(
                            n, pl[4], len(self.links)
                        )
                        l = self.links[pl[4]]
                        # if l[0] in self.orientation_changes: h = w_pt
                        # else:                                h = h_pt
                        annots += sprintf(
                            &#34;/Dest [%d 0 R /XYZ 0 %.2f null]&gt;&gt;&#34;,
                            1 + 2 * l[0],
                            h_pt - l[1] * self.k,
                        )

                # End links list
                self._out(annots + &#34;]&#34;)
            if self.pdf_version &gt; &#34;1.3&#34;:
                self._out(&#34;/Group &lt;&lt;/Type /Group /S /Transparency&#34; &#34;/CS /DeviceRGB&gt;&gt;&#34;)
            self._out(&#34;/Contents &#34; + str(self.n + 1) + &#34; 0 R&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

            # Page content
            content = self.pages[n][&#34;content&#34;]
            if self.compress:
                p = zlib.compress(content)
            else:
                p = content
            self._newobj()
            self._out(&#34;&lt;&lt;&#34; + filter + &#34;/Length &#34; + str(len(p)) + &#34;&gt;&gt;&#34;)
            self._out(pdf_stream(p))
            self._out(&#34;endobj&#34;)
        # Pages root
        self.offsets[1] = len(self.buffer)
        self._out(&#34;1 0 obj&#34;)
        self._out(&#34;&lt;&lt;/Type /Pages&#34;)
        kids = &#34;/Kids [&#34;
        for i in range(0, nb):
            kids += str(3 + 2 * i) + &#34; 0 R &#34;
        self._out(kids + &#34;]&#34;)
        self._out(&#34;/Count &#34; + str(nb))
        self._out(sprintf(&#34;/MediaBox [0 0 %.2f %.2f]&#34;, dw_pt, dh_pt))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _putfonts(self):
        nf = self.n
        for diff in self.diffs:
            # Encodings
            self._newobj()
            self._out(
                (
                    &#34;&lt;&lt;/Type /Encoding /BaseEncoding /WinAnsiEncoding &#34;
                    + &#34;/Differences [&#34;
                    + self.diffs[diff]
                    + &#34;]&gt;&gt;&#34;
                )
            )
            self._out(&#34;endobj&#34;)

        for name, info in self.font_files.items():
            if &#34;type&#34; in info and info[&#34;type&#34;] != &#34;TTF&#34;:
                # Font file embedding
                self._newobj()
                self.font_files[name][&#34;n&#34;] = self.n
                with open(os.path.join(FPDF_FONT_DIR, name), &#34;rb&#34;, 1) as f:
                    font = f.read()
                compressed = substr(name, -2) == &#34;.z&#34;
                if not compressed and &#34;length2&#34; in info:
                    header = ord(font[0]) == 128
                    if header:
                        # Strip first binary header
                        font = substr(font, 6)
                    if header and ord(font[info[&#34;length1&#34;]]) == 128:
                        # Strip second binary header
                        font = substr(font, 0, info[&#34;length1&#34;]) + substr(
                            font, info[&#34;length1&#34;] + 6
                        )

                self._out(&#34;&lt;&lt;/Length &#34; + str(len(font)))
                if compressed:
                    self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;/Length1 &#34; + str(info[&#34;length1&#34;]))
                if &#34;length2&#34; in info:
                    self._out(
                        &#34;/Length2 &#34; + str(info[&#34;length2&#34;]) + &#34; /Length3 0&#34;
                    )  # noqa: E501
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(font))
                self._out(&#34;endobj&#34;)

        # Font objects
        flist = [(x[1][&#34;i&#34;], x[0], x[1]) for x in self.fonts.items()]
        flist.sort()
        for idx, k, font in flist:
            self.fonts[k][&#34;n&#34;] = self.n + 1
            my_type = font[&#34;type&#34;]
            name = font[&#34;name&#34;]
            # Standard font
            if my_type == &#34;core&#34;:
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/BaseFont /&#34; + name)
                self._out(&#34;/Subtype /Type1&#34;)
                if name != &#34;Symbol&#34; and name != &#34;ZapfDingbats&#34;:
                    self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

            # Additional Type1 or TrueType font
            elif my_type == &#34;Type1&#34; or my_type == &#34;TrueType&#34;:
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/BaseFont /&#34; + name)
                self._out(&#34;/Subtype /&#34; + my_type)
                self._out(&#34;/FirstChar 32 /LastChar 255&#34;)
                self._out(&#34;/Widths &#34; + str(self.n + 1) + &#34; 0 R&#34;)
                self._out(&#34;/FontDescriptor &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                if font[&#34;enc&#34;]:
                    if &#34;diff&#34; in font:
                        self._out(
                            &#34;/Encoding &#34; + str(nf + font[&#34;diff&#34;]) + &#34; 0 R&#34;
                        )  # noqa: E501
                    else:
                        self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Widths
                self._newobj()
                cw = font[&#34;cw&#34;]
                s = &#34;[&#34;
                for i in range(32, 256):
                    # Get doesn&#39;t raise exception;
                    # returns 0 instead of None if not set
                    s += str(cw.get(chr(i), 0)) + &#34; &#34;
                self._out(s + &#34;]&#34;)
                self._out(&#34;endobj&#34;)

                # Descriptor
                self._newobj()
                s = &#34;&lt;&lt;/Type /FontDescriptor /FontName /&#34; + name
                for k in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    s += &#34; /%s %s&#34; % (k, font[&#34;desc&#34;][k])

                filename = font[&#34;file&#34;]
                if filename:
                    s += &#34; /FontFile&#34;
                    if my_type != &#34;Type1&#34;:
                        s += &#34;2&#34;
                    s += &#34; &#34; + str(self.font_files[filename][&#34;n&#34;]) + &#34; 0 R&#34;
                self._out(s + &#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)
            elif my_type == &#34;TTF&#34;:
                self.fonts[k][&#34;n&#34;] = self.n + 1
                ttf = TTFontFile()
                fontname = &#34;MPDFAA&#34; + &#34;+&#34; + font[&#34;name&#34;]
                subset = font[&#34;subset&#34;]
                del subset[0]
                ttfontstream = ttf.makeSubset(font[&#34;ttffile&#34;], subset)
                ttfontsize = len(ttfontstream)
                fontstream = zlib.compress(ttfontstream)
                codeToGlyph = ttf.codeToGlyph
                # del codeToGlyph[0]

                # Type0 Font
                # A composite font - a font composed of other fonts,
                # organized hierarchically
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /Type0&#34;)
                self._out(&#34;/BaseFont /&#34; + fontname + &#34;&#34;)
                self._out(&#34;/Encoding /Identity-H&#34;)
                self._out(&#34;/DescendantFonts [&#34; + str(self.n + 1) + &#34; 0 R&#34; + &#34;]&#34;)
                self._out(&#34;/ToUnicode &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # CIDFontType2
                # A CIDFont whose glyph descriptions are based on
                # TrueType font technology
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /CIDFontType2&#34;)
                self._out(&#34;/BaseFont /&#34; + fontname + &#34;&#34;)
                self._out(&#34;/CIDSystemInfo &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;/FontDescriptor &#34; + str(self.n + 3) + &#34; 0 R&#34;)
                if font[&#34;desc&#34;].get(&#34;MissingWidth&#34;):
                    self._out(&#34;/DW %d&#34; % font[&#34;desc&#34;][&#34;MissingWidth&#34;])
                self._putTTfontwidths(font, ttf.maxUni)
                self._out(&#34;/CIDToGIDMap &#34; + str(self.n + 4) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # ToUnicode
                self._newobj()
                toUni = (
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    &#34;1 beginbfrange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt; &lt;0000&gt;\n&#34;
                    &#34;endbfrange\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(toUni)) + &#34;&gt;&gt;&#34;)
                self._out(pdf_stream(toUni))
                self._out(&#34;endobj&#34;)

                # CIDSystemInfo dictionary
                self._newobj()
                self._out(&#34;&lt;&lt;/Registry (Adobe)&#34;)
                self._out(&#34;/Ordering (UCS)&#34;)
                self._out(&#34;/Supplement 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Font descriptor
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /FontDescriptor&#34;)
                self._out(&#34;/FontName /&#34; + fontname)
                for kd in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    v = font[&#34;desc&#34;][kd]
                    if kd == &#34;Flags&#34;:
                        v = v | 4
                        v = v &amp; ~32  # SYMBOLIC font flag
                    self._out(&#34; /%s %s&#34; % (kd, v))
                self._out(&#34;/FontFile2 &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Embed CIDToGIDMap
                # A specification of the mapping from CIDs to glyph indices
                cidtogidmap = &#34;&#34;
                cidtogidmap = [&#34;\x00&#34;] * 256 * 256 * 2
                for cc, glyph in codeToGlyph.items():
                    cidtogidmap[cc * 2] = chr(glyph &gt;&gt; 8)
                    cidtogidmap[cc * 2 + 1] = chr(glyph &amp; 0xFF)
                cidtogidmap = &#34;&#34;.join(cidtogidmap)
                # manage binary data as latin1 until PEP461-like function is implemented
                cidtogidmap = zlib.compress(cidtogidmap.encode(&#34;latin1&#34;))
                self._newobj()
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(cidtogidmap)) + &#34;&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(cidtogidmap))
                self._out(&#34;endobj&#34;)

                # Font file
                self._newobj()
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(fontstream)))
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;/Length1 &#34; + str(ttfontsize))
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(fontstream))
                self._out(&#34;endobj&#34;)
                del ttf
            else:
                # Allow for additional types
                mtd = &#34;_put&#34; + my_type.lower()
                # check if self has a attr mtd which is callable (method)
                if not callable(getattr(self, mtd, None)):
                    fpdf_error(&#34;Unsupported font type: &#34; + my_type)
                self.mtd(font)

    def _putTTfontwidths(self, font, maxUni):
        if font[&#34;unifilename&#34;]:
            ops = os.path.splitext
            cw127fname = ops(font[&#34;unifilename&#34;])[0] + &#34;.cw127.pkl&#34;
        else:
            cw127fname = None
        font_dict = load_cache(cw127fname)
        if font_dict is None:
            rangeid = 0
            range_ = {}
            range_interval = {}
            prevcid = -2
            prevwidth = -1
            interval = False
            startcid = 1
        else:
            rangeid = font_dict[&#34;rangeid&#34;]
            range_ = font_dict[&#34;range&#34;]
            prevcid = font_dict[&#34;prevcid&#34;]
            prevwidth = font_dict[&#34;prevwidth&#34;]
            interval = font_dict[&#34;interval&#34;]
            range_interval = font_dict[&#34;range_interval&#34;]
            startcid = 128
        cwlen = maxUni + 1

        # for each character
        subset = set(font[&#34;subset&#34;])
        for cid in range(startcid, cwlen):
            if cid == 128 and cw127fname and not os.path.exists(cw127fname):
                try:
                    with open(cw127fname, &#34;wb&#34;) as fh:
                        font_dict = {}
                        font_dict[&#34;rangeid&#34;] = rangeid
                        font_dict[&#34;prevcid&#34;] = prevcid
                        font_dict[&#34;prevwidth&#34;] = prevwidth
                        font_dict[&#34;interval&#34;] = interval
                        font_dict[&#34;range_interval&#34;] = range_interval
                        font_dict[&#34;range&#34;] = range_
                        pickle.dump(font_dict, fh)
                except IOError as e:
                    if not e.errno == errno.EACCES:
                        raise  # Not a permission error.

            if cid &gt; 255 and (cid not in subset):
                continue
            width = font[&#34;cw&#34;][cid]
            if width == 0:
                continue
            if width == 65535:
                width = 0

            if &#34;dw&#34; not in font or (font[&#34;dw&#34;] and width != font[&#34;dw&#34;]):
                if cid == (prevcid + 1):
                    if width == prevwidth:
                        if width == range_[rangeid][0]:
                            range_.setdefault(rangeid, []).append(width)
                        else:
                            range_[rangeid].pop()
                            # new range
                            rangeid = prevcid
                            range_[rangeid] = [prevwidth, width]
                        interval = True
                        range_interval[rangeid] = True
                    else:
                        if interval:
                            # new range
                            rangeid = cid
                            range_[rangeid] = [width]
                        else:
                            range_[rangeid].append(width)
                        interval = False
                else:
                    rangeid = cid
                    range_[rangeid] = [width]
                    interval = False
                prevcid = cid
                prevwidth = width
        prevk = -1
        nextk = -1
        prevint = False

        ri = range_interval
        for k, ws in sorted(range_.items()):
            cws = len(ws)
            if k == nextk and not prevint and (k not in ri or cws &lt; 3):
                if k in ri:
                    del ri[k]
                range_[prevk] = range_[prevk] + range_[k]
                del range_[k]
            else:
                prevk = k
            nextk = k + cws
            if k in ri:
                prevint = cws &gt; 3
                del ri[k]
                nextk -= 1
            else:
                prevint = False
        w = []
        for k, ws in sorted(range_.items()):
            if len(set(ws)) == 1:
                w.append(&#34; %s %s %s&#34; % (k, k + len(ws) - 1, ws[0]))
            else:
                w.append(&#34; %s [ %s ]\n&#34; % (k, &#34; &#34;.join([str(int(h)) for h in ws])))
        self._out(&#34;/W [%s]&#34; % &#34;&#34;.join(w))

    def _putimages(self):
        filter = &#34;&#34; if not self.compress else &#34;/Filter /FlateDecode &#34;  # noqa: F841

        i = [(x[1][&#34;i&#34;], x[1]) for x in self.images.items()]
        i.sort()
        for idx, info in i:
            self._putimage(info)
            del info[&#34;data&#34;]
            if &#34;smask&#34; in info:
                del info[&#34;smask&#34;]

    def _putimage(self, info):
        if &#34;data&#34; in info:
            self._newobj()
            info[&#34;n&#34;] = self.n
            self._out(&#34;&lt;&lt;/Type /XObject&#34;)
            self._out(&#34;/Subtype /Image&#34;)
            self._out(&#34;/Width &#34; + str(info[&#34;w&#34;]))
            self._out(&#34;/Height &#34; + str(info[&#34;h&#34;]))

            if info[&#34;cs&#34;] == &#34;Indexed&#34;:
                self._out(
                    &#34;/ColorSpace [/Indexed /DeviceRGB &#34;
                    + str(len(info[&#34;pal&#34;]) // 3 - 1)
                    + &#34; &#34;
                    + str(self.n + 1)
                    + &#34; 0 R]&#34;
                )
            else:
                self._out(&#34;/ColorSpace /&#34; + info[&#34;cs&#34;])
                if info[&#34;cs&#34;] == &#34;DeviceCMYK&#34;:
                    self._out(&#34;/Decode [1 0 1 0 1 0 1 0]&#34;)

            self._out(&#34;/BitsPerComponent &#34; + str(info[&#34;bpc&#34;]))

            if &#34;f&#34; in info:
                self._out(&#34;/Filter /&#34; + info[&#34;f&#34;])
            if &#34;dp&#34; in info:
                self._out(&#34;/DecodeParms &lt;&lt;&#34; + info[&#34;dp&#34;] + &#34;&gt;&gt;&#34;)

            if &#34;trns&#34; in info and isinstance(info[&#34;trns&#34;], list):
                trns = &#34;&#34;
                for i in range(0, len(info[&#34;trns&#34;])):
                    trns += str(info[&#34;trns&#34;][i]) + &#34; &#34; + str(info[&#34;trns&#34;][i]) + &#34; &#34;
                self._out(&#34;/Mask [&#34; + trns + &#34;]&#34;)

            if &#34;smask&#34; in info:
                self._out(&#34;/SMask &#34; + str(self.n + 1) + &#34; 0 R&#34;)

            self._out(&#34;/Length &#34; + str(len(info[&#34;data&#34;])) + &#34;&gt;&gt;&#34;)
            self._out(pdf_stream(info[&#34;data&#34;]))
            self._out(&#34;endobj&#34;)

            # Soft mask
            if &#34;smask&#34; in info:
                dp = (
                    &#34;/Predictor 15 /Colors 1 /BitsPerComponent 8 &#34;
                    + &#34;/Columns &#34;
                    + str(info[&#34;w&#34;])
                )
                smask = {
                    &#34;w&#34;: info[&#34;w&#34;],
                    &#34;h&#34;: info[&#34;h&#34;],
                    &#34;cs&#34;: &#34;DeviceGray&#34;,
                    &#34;bpc&#34;: 8,
                    &#34;f&#34;: info[&#34;f&#34;],
                    &#34;dp&#34;: dp,
                    &#34;data&#34;: info[&#34;smask&#34;],
                }
                self._putimage(smask)

            # Palette
            if info[&#34;cs&#34;] == &#34;Indexed&#34;:
                self._newobj()
                filter = self.compress and &#34;/Filter /FlateDecode &#34; or &#34;&#34;
                if self.compress:
                    pal = zlib.compress(info[&#34;pal&#34;])
                else:
                    pal = info[&#34;pal&#34;]
                self._out(&#34;&lt;&lt;&#34; + filter + &#34;/Length &#34; + str(len(pal)) + &#34;&gt;&gt;&#34;)
                self._out(pdf_stream(pal))
                self._out(&#34;endobj&#34;)

    def _putxobjectdict(self):
        i = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.images.values()]
        i.sort()
        for idx, n in i:
            self._out(&#34;/I&#34; + str(idx) + &#34; &#34; + str(n) + &#34; 0 R&#34;)

    def _putresourcedict(self):
        self._out(&#34;/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]&#34;)
        self._out(&#34;/Font &lt;&lt;&#34;)
        f = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.fonts.values()]
        f.sort()
        for idx, n in f:
            self._out(&#34;/F&#34; + str(idx) + &#34; &#34; + pdf_ref(n))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;/XObject &lt;&lt;&#34;)
        self._putxobjectdict()
        self._out(&#34;&gt;&gt;&#34;)

    def _putresources(self):
        with self._trace_size(&#34;resources.fonts&#34;):
            self._putfonts()
        with self._trace_size(&#34;resources.images&#34;):
            self._putimages()

        # Resource dictionary
        with self._trace_size(&#34;resources.dict&#34;):
            self.offsets[2] = len(self.buffer)
            self._out(&#34;2 0 obj&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._putresourcedict()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

    def _putinfo(self):
        ts = lambda a: enclose_in_parens(a)

        info_d = o_dict()
        # info_d[pdf_name(&#39;producer&#39;)] = ts(&#39;PyFPDF &#39; + FPDF_VERSION + \
        #     &#39; https://github.com/alexanderankin/pyfpdf&#39;)
        info_d[pdf_name(&#34;title&#34;)] = ts(getattr(self, &#34;title&#34;, None))
        info_d[pdf_name(&#34;subject&#34;)] = ts(getattr(self, &#34;subject&#34;, None))
        info_d[pdf_name(&#34;author&#34;)] = ts(getattr(self, &#34;author&#34;, None))
        info_d[pdf_name(&#34;keywords&#34;)] = ts(getattr(self, &#34;keywords&#34;, None))
        info_d[pdf_name(&#34;creator&#34;)] = ts(getattr(self, &#34;creator&#34;, None))

        if hasattr(self, &#34;creation_date&#34;):
            try:
                creation_date = self.creation_date
                date_string = creation_date.strftime(&#34;%Y%m%d%H%M%S&#34;)
            except Exception as e:
                fpdf_error(&#34;Could not format date: &#34; + str(creation_date))
        else:
            date_string = datetime.now().strftime(&#34;%Y%m%d%H%M%S&#34;)
        info_d[pdf_name(&#34;CreationDate&#34;)] = ts(&#34;D:&#34; + date_string)

        self._out(pdf_d(info_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;, has_empty_fields=True))

    def _putcatalog(self):
        catalog_d = o_dict()
        catalog_d[pdf_name(&#34;type&#34;)] = pdf_name(&#34;catalog&#34;)
        catalog_d[pdf_name(&#34;pages&#34;)] = pdf_ref(1)

        zoom_configs = {
            &#34;default&#34;: [&#34;/Fit&#34;],  # TODO FIXME
            &#34;fullpage&#34;: [&#34;/Fit&#34;],
            &#34;fullwidth&#34;: [&#34;/FitH&#34;, &#34;null&#34;],
            &#34;real&#34;: [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, &#34;1&#34;],
        }
        zoom_config = [pdf_ref(3)]
        zoom_config.extend(zoom_configs.get(self.zoom_mode, []))

        # zoom_config is a number, not one of the allowed strings
        if not zoom_config:
            zoom_config = [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, str(self.zoom_mode / 100)]

        catalog_d[pdf_name(&#34;OpenAction&#34;)] = pdf_l(zoom_config)

        layout_names = {
            &#34;single&#34;: pdf_name(&#34;SinglePage&#34;),
            &#34;continuous&#34;: pdf_name(&#34;OneColumn&#34;),
            &#34;two&#34;: pdf_name(&#34;TwoColumnLeft&#34;),
        }

        if self.layout_mode in layout_names:
            catalog_d[pdf_name(&#34;PageLayout&#34;)] = layout_names[self.layout_mode]

        self._out(pdf_d(catalog_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;))

    def _putheader(self):
        self._out(&#34;%PDF-&#34; + self.pdf_version)

    def _puttrailer(self):
        self._out(&#34;/Size &#34; + str(self.n + 1))
        self._out(&#34;/Root &#34; + pdf_ref(self.n))
        self._out(&#34;/Info &#34; + pdf_ref(self.n - 1))

    def _enddoc(self):
        LOGGER.debug(&#34;Final doc sections size summary:&#34;)
        with self._trace_size(&#34;header&#34;):
            self._putheader()
        with self._trace_size(&#34;pages&#34;):
            self._putpages()
        self._putresources()  # trace_size is performed inside
        # Info
        with self._trace_size(&#34;info&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putinfo()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Catalog
        with self._trace_size(&#34;catalog&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putcatalog()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Cross-ref
        with self._trace_size(&#34;xref&#34;):
            o = len(self.buffer)
            self._out(&#34;xref&#34;)
            self._out(&#34;0 &#34; + (str(self.n + 1)))
            self._out(&#34;0000000000 65535 f &#34;)
            for i in range(1, self.n + 1):
                self._out(sprintf(&#34;%010d 00000 n &#34;, self.offsets[i]))
        # Trailer
        with self._trace_size(&#34;trailer&#34;):
            self._out(&#34;trailer&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._puttrailer()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;startxref&#34;)
            self._out(o)
        self._out(&#34;%%EOF&#34;)
        self.state = 3

    def _beginpage(self, orientation, format, same):
        self.page += 1
        self.pages[self.page] = {&#34;content&#34;: bytearray()}
        self.state = 2
        self.x = self.l_margin
        self.y = self.t_margin
        self.font_family = &#34;&#34;
        self.font_stretching = 100
        if not same:
            # Page format
            if format:
                # Change page format
                fw_pt, fh_pt = get_page_format(format, self.k)
            else:
                # Set to default format
                fw_pt = self.dw_pt
                fh_pt = self.dh_pt
            fh = fh_pt / self.k
            # Page orientation
            if not orientation:
                orientation = self.def_orientation
            else:
                orientation = orientation[0].upper()
            if orientation == &#34;P&#34;:
                self.w_pt = fw_pt
                self.h_pt = fh_pt
            else:
                self.w_pt = fh_pt
                self.h_pt = fw_pt
            self.w = self.w_pt / self.k
            self.h = self.h_pt / self.k
            self.page_break_trigger = self.h - self.b_margin
            self.cur_orientation = orientation
        self.pages[self.page][&#34;w_pt&#34;] = self.w_pt
        self.pages[self.page][&#34;h_pt&#34;] = self.h_pt

    def _endpage(self):
        # End of page contents
        self.state = 1

    def _newobj(self):
        # Begin a new object
        self.n += 1
        self.offsets[self.n] = len(self.buffer)
        self._out(str(self.n) + &#34; 0 obj&#34;)

    def _dounderline(self, x, y, txt):
        # Underline text
        up = self.current_font[&#34;up&#34;]
        ut = self.current_font[&#34;ut&#34;]
        w = self.get_string_width(txt, True) + self.ws * txt.count(&#34; &#34;)
        return sprintf(
            &#34;%.2f %.2f %.2f %.2f re f&#34;,
            x * self.k,
            (self.h - (y - up / 1000.0 * self.font_size)) * self.k,
            w * self.k,
            -ut / 1000.0 * self.font_size_pt,
        )

    def _out(self, s):
        # Add a line to the document
        if isinstance(s, bytes):
            # manage binary data as latin1 until PEP461-like function is
            # implemented
            s = s.decode(&#34;latin1&#34;)
        elif not isinstance(s, str):
            s = str(s)
        if self.state == 2:
            # self.pages[self.page][&#34;content&#34;] += (s + &#34;\n&#34;)
            self.pages[self.page][&#34;content&#34;] += s.encode(&#34;latin1&#34;) + b&#34;\n&#34;
        else:
            self.buffer += s.encode(&#34;latin1&#34;) + b&#34;\n&#34;

    @check_page
    def interleaved2of5(self, txt, x, y, w=1.0, h=10.0):
        &#34;Barcode I2of5 (numeric), adds a 0 if odd lenght&#34;
        narrow = w / 3.0
        wide = w

        # wide/narrow codes for the digits
        bar_char = {
            &#34;0&#34;: &#34;nnwwn&#34;,
            &#34;1&#34;: &#34;wnnnw&#34;,
            &#34;2&#34;: &#34;nwnnw&#34;,
            &#34;3&#34;: &#34;wwnnn&#34;,
            &#34;4&#34;: &#34;nnwnw&#34;,
            &#34;5&#34;: &#34;wnwnn&#34;,
            &#34;6&#34;: &#34;nwwnn&#34;,
            &#34;7&#34;: &#34;nnnww&#34;,
            &#34;8&#34;: &#34;wnnwn&#34;,
            &#34;9&#34;: &#34;nwnwn&#34;,
            &#34;A&#34;: &#34;nn&#34;,
            &#34;Z&#34;: &#34;wn&#34;,
        }

        self.set_fill_color(0)
        code = txt
        # add leading zero if code-length is odd
        if len(code) % 2 != 0:
            code = &#34;0&#34; + code

        # add start and stop codes
        code = &#34;AA&#34; + code.lower() + &#34;ZA&#34;

        for i in range(0, len(code), 2):
            # choose next pair of digits
            char_bar = code[i]
            char_space = code[i + 1]
            # check whether it is a valid digit
            if not char_bar in bar_char.keys():
                raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_bar)
            if not char_space in bar_char.keys():
                raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_space)

            # create a wide/narrow-seq (first digit=bars, second digit=spaces)
            seq = &#34;&#34;
            for s in range(0, len(bar_char[char_bar])):
                seq += bar_char[char_bar][s] + bar_char[char_space][s]

            for bar in range(0, len(seq)):
                # set line_width depending on value
                if seq[bar] == &#34;n&#34;:
                    line_width = narrow
                else:
                    line_width = wide

                # draw every second value, the other is represented by space
                if bar % 2 == 0:
                    self.rect(x, y, line_width, h, &#34;F&#34;)

                x += line_width

    @check_page
    def code39(self, txt, x, y, w=1.5, h=5.0):
        &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
        dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3.0}
        chars = {
            &#34;0&#34;: &#34;nnnwwnwnn&#34;,
            &#34;1&#34;: &#34;wnnwnnnnw&#34;,
            &#34;2&#34;: &#34;nnwwnnnnw&#34;,
            &#34;3&#34;: &#34;wnwwnnnnn&#34;,
            &#34;4&#34;: &#34;nnnwwnnnw&#34;,
            &#34;5&#34;: &#34;wnnwwnnnn&#34;,
            &#34;6&#34;: &#34;nnwwwnnnn&#34;,
            &#34;7&#34;: &#34;nnnwnnwnw&#34;,
            &#34;8&#34;: &#34;wnnwnnwnn&#34;,
            &#34;9&#34;: &#34;nnwwnnwnn&#34;,
            &#34;A&#34;: &#34;wnnnnwnnw&#34;,
            &#34;B&#34;: &#34;nnwnnwnnw&#34;,
            &#34;C&#34;: &#34;wnwnnwnnn&#34;,
            &#34;D&#34;: &#34;nnnnwwnnw&#34;,
            &#34;E&#34;: &#34;wnnnwwnnn&#34;,
            &#34;F&#34;: &#34;nnwnwwnnn&#34;,
            &#34;G&#34;: &#34;nnnnnwwnw&#34;,
            &#34;H&#34;: &#34;wnnnnwwnn&#34;,
            &#34;I&#34;: &#34;nnwnnwwnn&#34;,
            &#34;J&#34;: &#34;nnnnwwwnn&#34;,
            &#34;K&#34;: &#34;wnnnnnnww&#34;,
            &#34;L&#34;: &#34;nnwnnnnww&#34;,
            &#34;M&#34;: &#34;wnwnnnnwn&#34;,
            &#34;N&#34;: &#34;nnnnwnnww&#34;,
            &#34;O&#34;: &#34;wnnnwnnwn&#34;,
            &#34;P&#34;: &#34;nnwnwnnwn&#34;,
            &#34;Q&#34;: &#34;nnnnnnwww&#34;,
            &#34;R&#34;: &#34;wnnnnnwwn&#34;,
            &#34;S&#34;: &#34;nnwnnnwwn&#34;,
            &#34;T&#34;: &#34;nnnnwnwwn&#34;,
            &#34;U&#34;: &#34;wwnnnnnnw&#34;,
            &#34;V&#34;: &#34;nwwnnnnnw&#34;,
            &#34;W&#34;: &#34;wwwnnnnnn&#34;,
            &#34;X&#34;: &#34;nwnnwnnnw&#34;,
            &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
            &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
            &#34;-&#34;: &#34;nwnnnnwnw&#34;,
            &#34;.&#34;: &#34;wwnnnnwnn&#34;,
            &#34; &#34;: &#34;nwwnnnwnn&#34;,
            &#34;*&#34;: &#34;nwnnwnwnn&#34;,
            &#34;$&#34;: &#34;nwnwnwnnn&#34;,
            &#34;/&#34;: &#34;nwnwnnnwn&#34;,
            &#34;+&#34;: &#34;nwnnnwnwn&#34;,
            &#34;%&#34;: &#34;nnnwnwnwn&#34;,
        }
        self.set_fill_color(0)
        for c in txt.upper():
            if c not in chars:
                raise RuntimeError(&#39;Invalid char &#34;%s&#34; for Code39&#39; % c)
            for i, d in enumerate(chars[c]):
                if i % 2 == 0:
                    self.rect(x, y, dim[d], h, &#34;F&#34;)
                x += dim[d]
            x += dim[&#34;n&#34;]

    @check_page
    @contextmanager
    def rect_clip(self, x, y, w, h):
        self._out(
            sprintf(
                &#34;q %.2f %.2f %.2f %.2f re W n\n&#34;,
                x * self.k,
                (self.h - (y + h)) * self.k,
                w * self.k,
                h * self.k,
            )
        )
        yield
        self._out(&#34;Q\n&#34;)

    @contextmanager
    def _trace_size(self, label):
        prev_size = len(self.buffer)
        yield
        LOGGER.debug(&#34;- %s.size: %s&#34;, label, _sizeof_fmt(len(self.buffer) - prev_size))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.FPDF.accept_page_break"><code class="name">var <span class="ident">accept_page_break</span></code></dt>
<dd>
<div class="desc"><p>Accept automatic page break or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def accept_page_break(self):
    &#34;Accept automatic page break or not&#34;
    return self.auto_page_break</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.FPDF.add_font"><code class="name flex">
<span>def <span class="ident">add_font</span></span>(<span>self, family, style='', fname=None, uni=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a TrueType or Type1 font</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_font(self, family, style=&#34;&#34;, fname=None, uni=False):
    &#34;Add a TrueType or Type1 font&#34;
    family = family.lower()
    if not fname:
        fname = family.replace(&#34; &#34;, &#34;&#34;) + style.lower() + &#34;.pkl&#34;

    if family == &#34;arial&#34;:
        family = &#34;helvetica&#34;
    style = style.upper()
    if style == &#34;IB&#34;:
        style = &#34;BI&#34;
    fontkey = family + style

    # Font already added!
    if fontkey in self.fonts:
        return
    if uni:
        global SYSTEM_TTFONTS, FPDF_CACHE_MODE, FPDF_CACHE_DIR
        if os.path.exists(fname):
            ttffilename = fname
        elif FPDF_FONT_DIR and os.path.exists(os.path.join(FPDF_FONT_DIR, fname)):
            ttffilename = os.path.join(FPDF_FONT_DIR, fname)
        elif SYSTEM_TTFONTS and os.path.exists(os.path.join(SYSTEM_TTFONTS, fname)):
            ttffilename = os.path.join(SYSTEM_TTFONTS, fname)
        else:
            raise RuntimeError(&#34;TTF Font file not found: %s&#34; % fname)
        name = &#34;&#34;  # noqa: F841
        if FPDF_CACHE_MODE == 0:
            unifilename = os.path.splitext(ttffilename)[0] + &#34;.pkl&#34;
        elif FPDF_CACHE_MODE == 2:
            unifilename = os.path.join(
                FPDF_CACHE_DIR, _hashpath(ttffilename) + &#34;.pkl&#34;
            )
        else:
            unifilename = None

        font_dict = load_cache(unifilename)
        if font_dict is None:
            ttf = TTFontFile()
            ttf.getMetrics(ttffilename)
            desc = {
                &#34;Ascent&#34;: int(round(ttf.ascent, 0)),
                &#34;Descent&#34;: int(round(ttf.descent, 0)),
                &#34;CapHeight&#34;: int(round(ttf.capHeight, 0)),
                &#34;Flags&#34;: ttf.flags,
                &#34;FontBBox&#34;: &#34;[%s %s %s %s]&#34;
                % (
                    int(round(ttf.bbox[0], 0)),
                    int(round(ttf.bbox[1], 0)),
                    int(round(ttf.bbox[2], 0)),
                    int(round(ttf.bbox[3], 0)),
                ),
                &#34;ItalicAngle&#34;: int(ttf.italicAngle),
                &#34;StemV&#34;: int(round(ttf.stemV, 0)),
                &#34;MissingWidth&#34;: int(round(ttf.defaultWidth, 0)),
            }

            # Generate metrics .pkl file
            font_dict = {
                &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;desc&#34;: desc,
                &#34;up&#34;: round(ttf.underlinePosition),
                &#34;ut&#34;: round(ttf.underlineThickness),
                &#34;ttffile&#34;: ttffilename,
                &#34;fontkey&#34;: fontkey,
                &#34;originalsize&#34;: os.stat(ttffilename).st_size,
                &#34;cw&#34;: ttf.charWidths,
            }

            if unifilename:
                try:
                    with open(unifilename, &#34;wb&#34;) as fh:
                        pickle.dump(font_dict, fh)
                except IOError as e:
                    if not e.errno == errno.EACCES:
                        raise  # Not a permission error.
            del ttf

        # include numbers in the subset! (if alias present)
        have_page_alias = lambda: hasattr(self, &#34;str_alias_nb_pages&#34;)
        sbarr = list(range(0, 57 if have_page_alias() else 32))

        self.fonts[fontkey] = {
            &#34;i&#34;: len(self.fonts) + 1,
            &#34;type&#34;: font_dict[&#34;type&#34;],
            &#34;name&#34;: font_dict[&#34;name&#34;],
            &#34;desc&#34;: font_dict[&#34;desc&#34;],
            &#34;up&#34;: font_dict[&#34;up&#34;],
            &#34;ut&#34;: font_dict[&#34;ut&#34;],
            &#34;cw&#34;: font_dict[&#34;cw&#34;],
            &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
            &#34;fontkey&#34;: fontkey,
            &#34;subset&#34;: sbarr,
            &#34;unifilename&#34;: unifilename,
        }
        self.font_files[fontkey] = {
            &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
            &#34;type&#34;: &#34;TTF&#34;,
            &#34;ttffile&#34;: ttffilename,
        }
        self.font_files[fname] = {&#34;type&#34;: &#34;TTF&#34;}
    else:
        with open(fname, &#34;rb&#34;) as fontfile:
            font_dict = pickle.load(fontfile)
        self.fonts[fontkey] = {&#34;i&#34;: len(self.fonts) + 1}
        self.fonts[fontkey].update(font_dict)
        diff = font_dict.get(&#34;diff&#34;)
        if diff:
            # Search existing encodings
            d = 0
            nb = len(self.diffs)
            for i in range(1, nb + 1):
                if self.diffs[i] == diff:
                    d = i
                    break
            if d == 0:
                d = nb + 1
                self.diffs[d] = diff
            self.fonts[fontkey][&#34;diff&#34;] = d
        filename = font_dict.get(&#34;filename&#34;)
        if filename:
            if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                originalsize = font_dict[&#34;originalsize&#34;]
                self.font_files[filename] = {&#34;length1&#34;: originalsize}
            else:
                self.font_files[filename] = {
                    &#34;length1&#34;: font_dict[&#34;size1&#34;],
                    &#34;length2&#34;: font_dict[&#34;size2&#34;],
                }</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new internal link</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_link(self):
    &#34;Create a new internal link&#34;
    n = len(self.links) + 1
    self.links[n] = (0, 0)
    return n</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self, orientation='', format='', same=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a new page, if same page format will be same as previous</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page(self, orientation=&#34;&#34;, format=&#34;&#34;, same=False):
    &#34;Start a new page, if same page format will be same as previous&#34;
    if self.state == 0:
        self.open()
    family = self.font_family
    style = self.font_style + &#34;U&#34; if self.underline else self.font_style
    size = self.font_size_pt
    lw = self.line_width
    dc = self.draw_color
    fc = self.fill_color
    tc = self.text_color
    cf = self.color_flag
    stretching = self.font_stretching
    if self.page &gt; 0:
        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0
        # close page
        self._endpage()

    # Start new page
    self._beginpage(orientation, format, same)
    self._out(&#34;2 J&#34;)  # Set line cap style to square
    self.line_width = lw  # Set line width
    self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

    # Set font
    if family:
        self.set_font(family, style, size)

    # Set colors
    self.draw_color = dc
    if dc != &#34;0 G&#34;:
        self._out(dc)
    self.fill_color = fc
    if fc != &#34;0 g&#34;:
        self._out(fc)
    self.text_color = tc
    self.color_flag = cf

    &#34;&#34;&#34; BEGIN Page header &#34;&#34;&#34;
    self.header()

    if self.line_width != lw:  # Restore line width
        self.line_width = lw
        self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

    if family:
        self.set_font(family, style, size)  # Restore font

    if self.draw_color != dc:  # Restore colors
        self.draw_color = dc
        self._out(dc)
    if self.fill_color != fc:
        self.fill_color = fc
        self._out(fc)
    self.text_color = tc
    self.color_flag = cf

    if stretching != 100:  # Restore stretching
        self.set_stretching(stretching)
    &#34;&#34;&#34; END Page header &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.alias_nb_pages"><code class="name flex">
<span>def <span class="ident">alias_nb_pages</span></span>(<span>self, alias='{nb}')</span>
</code></dt>
<dd>
<div class="desc"><p>Define an alias for total number of pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alias_nb_pages(self, alias=&#34;{nb}&#34;):
    &#34;Define an alias for total number of pages&#34;
    self.str_alias_nb_pages = alias
    return alias</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.cell"><code class="name flex">
<span>def <span class="ident">cell</span></span>(<span>self, w, h=0, txt='', border=0, ln=0, align='', fill=0, link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output a cell, return boolean if triggered auto page break</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def cell(self, w, h=0, txt=&#34;&#34;, border=0, ln=0, align=&#34;&#34;, fill=0, link=&#34;&#34;):
    &#34;Output a cell, return boolean if triggered auto page break&#34;
    page_break_triggered = False
    txt = self.normalize_text(txt)
    k = self.k
    if (
        self.y + h &gt; self.page_break_trigger
        and not self.in_footer
        and self.accept_page_break
    ):

        # Automatic page break
        page_break_triggered = True
        x = self.x
        ws = self.ws
        if ws &gt; 0:
            self.ws = 0
            self._out(&#34;0 Tw&#34;)
        self.add_page(same=True)
        self.x = x  # restore x but not y after drawing header

        if ws &gt; 0:
            self.ws = ws
            self._out(sprintf(&#34;%.3f Tw&#34;, ws * k))
    if w == 0:
        w = self.w - self.r_margin - self.x
    s = &#34;&#34;

    if fill == 1 or border == 1:
        if fill == 1:
            if border == 1:
                op = &#34;B&#34;
            else:
                op = &#34;f&#34;
        else:
            op = &#34;S&#34;
        s = sprintf(
            &#34;%.2f %.2f %.2f %.2f re %s &#34;,
            self.x * k,
            (self.h - self.y) * k,
            w * k,
            -h * k,
            op,
        )

    if isinstance(border, str):
        x = self.x
        y = self.y
        if &#34;L&#34; in border:
            s += sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                x * k,
                (self.h - y) * k,
                x * k,
                (self.h - (y + h)) * k,
            )
        if &#34;T&#34; in border:
            s += sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                x * k,
                (self.h - y) * k,
                (x + w) * k,
                (self.h - y) * k,
            )
        if &#34;R&#34; in border:
            s += sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                (x + w) * k,
                (self.h - y) * k,
                (x + w) * k,
                (self.h - (y + h)) * k,
            )
        if &#34;B&#34; in border:
            s += sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                x * k,
                (self.h - (y + h)) * k,
                (x + w) * k,
                (self.h - (y + h)) * k,
            )

    if txt != &#34;&#34;:
        if align == &#34;R&#34;:
            dx = w - self.c_margin - self.get_string_width(txt, True)
        elif align == &#34;C&#34;:
            dx = (w - self.get_string_width(txt, True)) / 2.0
        else:
            dx = self.c_margin
        if self.color_flag:
            s += &#34;q &#34; + self.text_color + &#34; &#34;

        # If multibyte, Tw has no effect - do word spacing using an
        # adjustment before each space
        if self.ws and self.unifontsubset:
            for uni in UTF8StringToArray(txt):
                self.current_font[&#34;subset&#34;].append(uni)
            space = escape_parens(UTF8ToUTF16BE(&#34; &#34;, False))

            s += sprintf(
                &#34;BT 0 Tw %.2F %.2F Td [&#34;,
                (self.x + dx) * k,
                (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
            )

            t = txt.split(&#34; &#34;)
            numt = len(t)
            for i in range(numt):
                tx = t[i]
                tx = enclose_in_parens(escape_parens(UTF8ToUTF16BE(tx, False)))
                s += sprintf(&#34;%s &#34;, tx)
                if (i + 1) &lt; numt:
                    adj = -(self.ws * self.k) * 1000 / self.font_size_pt
                    s += sprintf(&#34;%d(%s) &#34;, adj, space)
            s += &#34;] TJ&#34;
            s += &#34; ET&#34;
        else:
            if self.unifontsubset:
                txt2 = escape_parens(UTF8ToUTF16BE(txt, False))
                for uni in UTF8StringToArray(txt):
                    self.current_font[&#34;subset&#34;].append(uni)
            else:
                txt2 = escape_parens(txt)

            s += sprintf(
                &#34;BT %.2f %.2f Td (%s) Tj ET&#34;,
                (self.x + dx) * k,
                (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
                txt2,
            )

        if self.underline:
            s += &#34; &#34; + self._dounderline(
                self.x + dx, self.y + (0.5 * h) + (0.3 * self.font_size), txt
            )
        if self.color_flag:
            s += &#34; Q&#34;
        if link:
            self.link(
                self.x + dx,
                self.y + (0.5 * h) - (0.5 * self.font_size),
                self.get_string_width(txt, True),
                self.font_size,
                link,
            )

    if s:
        self._out(s)
    self.lasth = h

    if ln &gt; 0:
        self.y += h  # Go to next line
        if ln == 1:
            self.x = self.l_margin
    else:
        self.x += w

    return page_break_triggered</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.check_page"><code class="name flex">
<span>def <span class="ident">check_page</span></span>(<span>fn)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to protect drawing methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_page(fn):
    &#34;Decorator to protect drawing methods&#34;

    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        if not self.page and not kwargs.get(&#34;split_only&#34;):
            fpdf_error(&#34;No page open, you need to call add_page() first&#34;)
        else:
            return fn(self, *args, **kwargs)

    return wrapper</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminate document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;Terminate document&#34;
    if self.state == 3:
        return
    if self.page == 0:
        self.add_page()

    # Page footer
    self.in_footer = 1
    self.footer()
    self.in_footer = 0

    self._endpage()  # close page
    self._enddoc()  # close document</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.code39"><code class="name flex">
<span>def <span class="ident">code39</span></span>(<span>self, txt, x, y, w=1.5, h=5.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Barcode 3of9</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def code39(self, txt, x, y, w=1.5, h=5.0):
    &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
    dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3.0}
    chars = {
        &#34;0&#34;: &#34;nnnwwnwnn&#34;,
        &#34;1&#34;: &#34;wnnwnnnnw&#34;,
        &#34;2&#34;: &#34;nnwwnnnnw&#34;,
        &#34;3&#34;: &#34;wnwwnnnnn&#34;,
        &#34;4&#34;: &#34;nnnwwnnnw&#34;,
        &#34;5&#34;: &#34;wnnwwnnnn&#34;,
        &#34;6&#34;: &#34;nnwwwnnnn&#34;,
        &#34;7&#34;: &#34;nnnwnnwnw&#34;,
        &#34;8&#34;: &#34;wnnwnnwnn&#34;,
        &#34;9&#34;: &#34;nnwwnnwnn&#34;,
        &#34;A&#34;: &#34;wnnnnwnnw&#34;,
        &#34;B&#34;: &#34;nnwnnwnnw&#34;,
        &#34;C&#34;: &#34;wnwnnwnnn&#34;,
        &#34;D&#34;: &#34;nnnnwwnnw&#34;,
        &#34;E&#34;: &#34;wnnnwwnnn&#34;,
        &#34;F&#34;: &#34;nnwnwwnnn&#34;,
        &#34;G&#34;: &#34;nnnnnwwnw&#34;,
        &#34;H&#34;: &#34;wnnnnwwnn&#34;,
        &#34;I&#34;: &#34;nnwnnwwnn&#34;,
        &#34;J&#34;: &#34;nnnnwwwnn&#34;,
        &#34;K&#34;: &#34;wnnnnnnww&#34;,
        &#34;L&#34;: &#34;nnwnnnnww&#34;,
        &#34;M&#34;: &#34;wnwnnnnwn&#34;,
        &#34;N&#34;: &#34;nnnnwnnww&#34;,
        &#34;O&#34;: &#34;wnnnwnnwn&#34;,
        &#34;P&#34;: &#34;nnwnwnnwn&#34;,
        &#34;Q&#34;: &#34;nnnnnnwww&#34;,
        &#34;R&#34;: &#34;wnnnnnwwn&#34;,
        &#34;S&#34;: &#34;nnwnnnwwn&#34;,
        &#34;T&#34;: &#34;nnnnwnwwn&#34;,
        &#34;U&#34;: &#34;wwnnnnnnw&#34;,
        &#34;V&#34;: &#34;nwwnnnnnw&#34;,
        &#34;W&#34;: &#34;wwwnnnnnn&#34;,
        &#34;X&#34;: &#34;nwnnwnnnw&#34;,
        &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
        &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
        &#34;-&#34;: &#34;nwnnnnwnw&#34;,
        &#34;.&#34;: &#34;wwnnnnwnn&#34;,
        &#34; &#34;: &#34;nwwnnnwnn&#34;,
        &#34;*&#34;: &#34;nwnnwnwnn&#34;,
        &#34;$&#34;: &#34;nwnwnwnnn&#34;,
        &#34;/&#34;: &#34;nwnwnnnwn&#34;,
        &#34;+&#34;: &#34;nwnnnwnwn&#34;,
        &#34;%&#34;: &#34;nnnwnwnwn&#34;,
    }
    self.set_fill_color(0)
    for c in txt.upper():
        if c not in chars:
            raise RuntimeError(&#39;Invalid char &#34;%s&#34; for Code39&#39; % c)
        for i, d in enumerate(chars[c]):
            if i % 2 == 0:
                self.rect(x, y, dim[d], h, &#34;F&#34;)
            x += dim[d]
        x += dim[&#34;n&#34;]</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.dashed_line"><code class="name flex">
<span>def <span class="ident">dashed_line</span></span>(<span>self, x1, y1, x2, y2, dash_length=1, space_length=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a dashed line. Same interface as line() except:
- dash_length: Length of the dash
- space_length: Length of the space between dashes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
    &#34;&#34;&#34;Draw a dashed line. Same interface as line() except:
    - dash_length: Length of the dash
    - space_length: Length of the space between dashes&#34;&#34;&#34;
    self._set_dash(dash_length, space_length)
    self.line(x1, y1, x2, y2)
    self._set_dash()</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def ellipse(self, x, y, w, h, style=None):
    &#34;Draw a ellipse&#34;
    style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
    op = style_to_operators.get(style, &#34;S&#34;)

    cx = x + w / 2.0
    cy = y + h / 2.0
    rx = w / 2.0
    ry = h / 2.0

    lx = 4.0 / 3.0 * (math.sqrt(2) - 1) * rx
    ly = 4.0 / 3.0 * (math.sqrt(2) - 1) * ry

    self._out(
        sprintf(
            &#34;%.2f %.2f m %.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
            (cx + rx) * self.k,
            (self.h - cy) * self.k,
            (cx + rx) * self.k,
            (self.h - (cy - ly)) * self.k,
            (cx + lx) * self.k,
            (self.h - (cy - ry)) * self.k,
            cx * self.k,
            (self.h - (cy - ry)) * self.k,
        )
    )
    self._out(
        sprintf(
            &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
            (cx - lx) * self.k,
            (self.h - (cy - ry)) * self.k,
            (cx - rx) * self.k,
            (self.h - (cy - ly)) * self.k,
            (cx - rx) * self.k,
            (self.h - cy) * self.k,
        )
    )
    self._out(
        sprintf(
            &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
            (cx - rx) * self.k,
            (self.h - (cy + ly)) * self.k,
            (cx - lx) * self.k,
            (self.h - (cy + ry)) * self.k,
            cx * self.k,
            (self.h - (cy + ry)) * self.k,
        )
    )
    self._out(
        sprintf(
            &#34;%.2f %.2f %.2f %.2f %.2f %.2f c %s&#34;,
            (cx + lx) * self.k,
            (self.h - (cy + ry)) * self.k,
            (cx + rx) * self.k,
            (self.h - (cy + ly)) * self.k,
            (cx + rx) * self.k,
            (self.h - cy) * self.k,
            op,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.footer"><code class="name flex">
<span>def <span class="ident">footer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Footer to be implemented in your own inherited class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def footer(self):
    &#34;Footer to be implemented in your own inherited class&#34;
    pass</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_string_width"><code class="name flex">
<span>def <span class="ident">get_string_width</span></span>(<span>self, s, normalized=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get width of a string in the current font</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string_width(self, s, normalized=False):
    &#34;Get width of a string in the current font&#34;
    # normalized is parameter for internal use
    s = s if normalized else self.normalize_text(s)
    cw = self.current_font[&#34;cw&#34;]
    w = 0
    l = len(s)
    if self.unifontsubset:
        for char in s:
            char = ord(char)
            if len(cw) &gt; char:
                w += cw[char]
            elif self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]:
                w += self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]
            else:
                w += 500
    else:
        for i in range(0, l):
            w += cw.get(s[i], 0)
    if self.font_stretching != 100:
        w = w * self.font_stretching / 100.0
    return w * self.font_size / 1000.0</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_x"><code class="name flex">
<span>def <span class="ident">get_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get x position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x(self):
    &#34;Get x position&#34;
    return self.x</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get y position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_y(self):
    &#34;Get y position&#34;
    return self.y</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Header to be implemented in your own inherited class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self):
    &#34;Header to be implemented in your own inherited class&#34;
    pass</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self, name, x=None, y=None, w=0, h=0, type='', link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Put an image on the page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def image(
    self,
    name,
    x=None,
    y=None,
    w=0,
    h=0,
    type=&#34;&#34;,
    link=&#34;&#34;,
):
    # def image(self, name, x = None, y = None, w = 0, h = 0, type = &#39;&#39;, link = &#39;&#39;):  # noqa: E501
    &#34;Put an image on the page&#34;
    if name not in self.images:
        info = get_img_info(image_parsing_load_resource(name))
        info[&#34;i&#34;] = len(self.images) + 1
        self.images[name] = info
    else:
        info = self.images[name]

    # Automatic width and height calculation if needed
    if w == 0 and h == 0:
        # Put image at 72 dpi
        w = info[&#34;w&#34;] / self.k
        h = info[&#34;h&#34;] / self.k
    elif w == 0:
        w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
    elif h == 0:
        h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

    # Flowing mode
    if y is None:
        if (
            self.y + h &gt; self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        ):
            # Automatic page break
            x = self.x
            self.add_page(same=True)
            self.x = x
        y = self.y
        self.y += h

    if x is None:
        x = self.x
    self._out(
        sprintf(
            &#34;q %.2f 0 0 %.2f %.2f %.2f cm /I%d Do Q&#34;,
            w * self.k,
            h * self.k,
            x * self.k,
            (self.h - (y + h)) * self.k,
            info[&#34;i&#34;],
        )
    )
    if link:
        self.link(x, y, w, h, link)

    return info</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.interleaved2of5"><code class="name flex">
<span>def <span class="ident">interleaved2of5</span></span>(<span>self, txt, x, y, w=1.0, h=10.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Barcode I2of5 (numeric), adds a 0 if odd lenght</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def interleaved2of5(self, txt, x, y, w=1.0, h=10.0):
    &#34;Barcode I2of5 (numeric), adds a 0 if odd lenght&#34;
    narrow = w / 3.0
    wide = w

    # wide/narrow codes for the digits
    bar_char = {
        &#34;0&#34;: &#34;nnwwn&#34;,
        &#34;1&#34;: &#34;wnnnw&#34;,
        &#34;2&#34;: &#34;nwnnw&#34;,
        &#34;3&#34;: &#34;wwnnn&#34;,
        &#34;4&#34;: &#34;nnwnw&#34;,
        &#34;5&#34;: &#34;wnwnn&#34;,
        &#34;6&#34;: &#34;nwwnn&#34;,
        &#34;7&#34;: &#34;nnnww&#34;,
        &#34;8&#34;: &#34;wnnwn&#34;,
        &#34;9&#34;: &#34;nwnwn&#34;,
        &#34;A&#34;: &#34;nn&#34;,
        &#34;Z&#34;: &#34;wn&#34;,
    }

    self.set_fill_color(0)
    code = txt
    # add leading zero if code-length is odd
    if len(code) % 2 != 0:
        code = &#34;0&#34; + code

    # add start and stop codes
    code = &#34;AA&#34; + code.lower() + &#34;ZA&#34;

    for i in range(0, len(code), 2):
        # choose next pair of digits
        char_bar = code[i]
        char_space = code[i + 1]
        # check whether it is a valid digit
        if not char_bar in bar_char.keys():
            raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_bar)
        if not char_space in bar_char.keys():
            raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_space)

        # create a wide/narrow-seq (first digit=bars, second digit=spaces)
        seq = &#34;&#34;
        for s in range(0, len(bar_char[char_bar])):
            seq += bar_char[char_bar][s] + bar_char[char_space][s]

        for bar in range(0, len(seq)):
            # set line_width depending on value
            if seq[bar] == &#34;n&#34;:
                line_width = narrow
            else:
                line_width = wide

            # draw every second value, the other is represented by space
            if bar % 2 == 0:
                self.rect(x, y, line_width, h, &#34;F&#34;)

            x += line_width</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>self, x1, y1, x2, y2)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def line(self, x1, y1, x2, y2):
    &#34;Draw a line&#34;
    self._out(
        sprintf(
            &#34;%.2f %.2f m %.2f %.2f l S&#34;,
            x1 * self.k,
            (self.h - y1) * self.k,
            x2 * self.k,
            (self.h - y2) * self.k,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, x, y, w, h, link, alt_text='')</span>
</code></dt>
<dd>
<div class="desc"><p>Put a link on the page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, x, y, w, h, link, alt_text=&#34;&#34;):
    &#34;Put a link on the page&#34;
    if self.page not in self.page_links:
        self.page_links[self.page] = []
    self.page_links[self.page] += [
        (x * self.k, self.h_pt - y * self.k, w * self.k, h * self.k, link, alt_text)
    ]</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.ln"><code class="name flex">
<span>def <span class="ident">ln</span></span>(<span>self, h=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Line Feed; default value is last cell height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def ln(self, h=None):
    &#34;Line Feed; default value is last cell height&#34;
    self.x = self.l_margin
    if h is None:
        self.y += self.lasth
    else:
        self.y += h</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.multi_cell"><code class="name flex">
<span>def <span class="ident">multi_cell</span></span>(<span>self, w, h, txt='', border=0, align='J', fill=0, split_only=False, link='', ln=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Output text with automatic or explicit line breaks, returns
boolean if page break triggered in output mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def multi_cell(
    self, w, h, txt=&#34;&#34;, border=0, align=&#34;J&#34;, fill=0, split_only=False, link=&#34;&#34;, ln=0
):
    &#34;&#34;&#34;Output text with automatic or explicit line breaks, returns
    boolean if page break triggered in output mode
    &#34;&#34;&#34;
    page_break_triggered = False
    if split_only:
        _out, _add_page = self._out, self.add_page
        self._out = lambda *args, **kwargs: None
        self.add_page = lambda *args, **kwargs: None

    # Store this information for manipulating position.
    location = (self.get_x(), self.get_y())

    # If width is 0, set width to available width between margins
    if w == 0:
        w = self.w - self.r_margin - self.x
    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size

    # Calculate text length
    txt = self.normalize_text(txt)
    s = txt.replace(&#34;\r&#34;, &#34;&#34;)
    normalized_string_length = len(s)
    if normalized_string_length &gt; 0 and s[-1] == &#34;\n&#34;:
        normalized_string_length -= 1

    b = 0
    if border:
        if border == 1:
            border = &#34;LTRB&#34;
            b = &#34;LRT&#34;
            b2 = &#34;LR&#34;
        else:
            b2 = &#34;&#34;
            if &#34;L&#34; in border:
                b2 += &#34;L&#34;
            if &#34;R&#34; in border:
                b2 += &#34;R&#34;
            if &#34;T&#34; in border:
                b = b2 + &#34;T&#34;
            else:
                b = b2

    character_widths = self.current_font[&#34;cw&#34;]
    text_cells = []
    sep = -1
    i = 0
    j = 0
    l = 0
    ns = 0
    nl = 1
    while i &lt; normalized_string_length:
        # Get next character
        c = s[i]

        # Explicit line break
        if c == &#34;\n&#34;:
            if self.ws &gt; 0:
                self.ws = 0
                self._out(&#34;0 Tw&#34;)

            new_page = self.cell(
                w,
                h=h,
                txt=substr(s, j, i - j),
                border=b,
                ln=2,
                align=align,
                fill=fill,
                link=link,
            )
            page_break_triggered = page_break_triggered or new_page
            text_cells.append(substr(s, j, i - j))

            i += 1
            sep = -1
            j = i
            l = 0
            ns = 0
            nl += 1
            if border and nl == 2:
                b = b2
            continue

        if c == &#34; &#34;:
            sep = i
            ls = l
            ns += 1
        if self.unifontsubset:
            l += self.get_string_width(c, True) / self.font_size * 1000.0
        else:
            l += character_widths.get(c, 0)

        # Automatic line break
        if l &gt; wmax:
            if sep == -1:
                if i == j:
                    i += 1
                if self.ws &gt; 0:
                    self.ws = 0
                    self._out(&#34;0 Tw&#34;)

                new_page = self.cell(
                    w,
                    h=h,
                    txt=substr(s, j, i - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, i - j))

            else:
                if align == &#34;J&#34;:
                    if ns &gt; 1:
                        self.ws = (wmax - ls) / 1000.0 * self.font_size / (ns - 1)
                    else:
                        self.ws = 0
                    self._out(sprintf(&#34;%.3f Tw&#34;, self.ws * self.k))

                new_page = self.cell(
                    w,
                    h=h,
                    txt=substr(s, j, sep - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, sep - j))

                i = sep + 1
            sep = -1
            j = i
            l = 0
            ns = 0
            nl += 1
            if border and nl == 2:
                b = b2
        else:
            i += 1

    # Last chunk
    if self.ws &gt; 0:
        self.ws = 0
        self._out(&#34;0 Tw&#34;)
    if border and &#34;B&#34; in border:
        b += &#34;B&#34;

    new_page = self.cell(
        w,
        h=h,
        txt=substr(s, j, i - j),
        border=b,
        ln=2,
        align=align,
        fill=fill,
        link=link,
    )
    page_break_triggered = page_break_triggered or new_page
    text_cells.append(substr(s, j, i - j))

    location_options = {
        0: lambda: self.set_xy(location[0] + w, location[1]),
        1: lambda: self.set_x(self.l_margin),  # could control y
        2: lambda: None,
    }
    location_options.get(ln, lambda: None)()

    if split_only:
        # restore writing functions
        self._out, self.add_page = _out, _add_page
        self.set_xy(*location)  # restore location
        return text_cells

    return page_break_triggered</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.normalize_text"><code class="name flex">
<span>def <span class="ident">normalize_text</span></span>(<span>self, txt)</span>
</code></dt>
<dd>
<div class="desc"><p>Check that text input is in the correct format/encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_text(self, txt):
    &#34;Check that text input is in the correct format/encoding&#34;
    # - for TTF unicode fonts: unicode object (utf8 encoding)
    # - for built-in fonts: string instances (encoding: latin-1, cp1252)
    if not self.unifontsubset and self.core_fonts_encoding:
        return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
    return txt</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Begin document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self):
    &#34;Begin document&#34;
    self.state = 1</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.output"><code class="name flex">
<span>def <span class="ident">output</span></span>(<span>self, name='', dest='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output PDF to some destination</p>
<p>By default the PDF is written to sys.stdout. If a name is given, the
PDF is written to a new file. If dest='S' is given, the PDF data is
returned as a byte string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output(self, name=&#34;&#34;, dest=&#34;&#34;):
    &#34;&#34;&#34;Output PDF to some destination

    By default the PDF is written to sys.stdout. If a name is given, the
    PDF is written to a new file. If dest=&#39;S&#39; is given, the PDF data is
    returned as a byte string.&#34;&#34;&#34;

    # Finish document if necessary
    if self.state &lt; 3:
        self.close()
    dest = dest.upper()
    if dest == &#34;&#34;:
        if name == &#34;&#34;:
            dest = &#34;I&#34;
        else:
            dest = &#34;F&#34;
    if dest in (&#34;I&#34;, &#34;D&#34;):
        # Python &lt; 3 writes byte data transparently without &#34;buffer&#34;
        stdout = getattr(sys.stdout, &#34;buffer&#34;, sys.stdout)
        stdout.write(self.buffer)
    elif dest == &#34;F&#34;:
        # Save to local file
        with open(name, &#34;wb&#34;) as f:
            f.write(self.buffer)
    # Return as a byte string
    elif dest == &#34;S&#34;:
        return self.buffer
    else:
        fpdf_error(&#34;Incorrect output destination: &#34; + dest)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.page_no"><code class="name flex">
<span>def <span class="ident">page_no</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current page number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_no(self):
    &#34;Get current page number&#34;
    return self.page</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a rectangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def rect(self, x, y, w, h, style=None):
    &#34;Draw a rectangle&#34;
    style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
    op = style_to_operators.get(style, &#34;S&#34;)
    self._out(
        sprintf(
            &#34;%.2f %.2f %.2f %.2f re %s&#34;,
            x * self.k,
            (self.h - y) * self.k,
            w * self.k,
            -h * self.k,
            op,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rect_clip"><code class="name flex">
<span>def <span class="ident">rect_clip</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rect_clip(self, x, y, w, h):
    self._out(
        sprintf(
            &#34;q %.2f %.2f %.2f %.2f re W n\n&#34;,
            x * self.k,
            (self.h - (y + h)) * self.k,
            w * self.k,
            h * self.k,
        )
    )
    yield
    self._out(&#34;Q\n&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def rotate(self, angle, x=None, y=None):
    warnings.warn(
        &#34;rotate() can produces malformed PDFs and is deprecated. Use the rotation() context manager instead.&#34;,
        PendingDeprecationWarning,
    )
    if x is None:
        x = self.x
    if y is None:
        y = self.y

    if self.angle != 0:
        self._out(&#34;Q&#34;)
    self.angle = angle
    if angle != 0:
        angle *= math.pi / 180
        c = math.cos(angle)
        s = math.sin(angle)
        cx = x * self.k
        cy = (self.h - y) * self.k
        s = sprintf(
            &#34;q %.5F %.5F %.5F %.5F %.2F %.2F &#34; + &#34;cm 1 0 0 1 %.2F %.2F cm&#34;,
            c,
            s,
            -s,
            c,
            cx,
            cy,
            -cx,
            -cy,
        )
        self._out(s)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rotation"><code class="name flex">
<span>def <span class="ident">rotation</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rotation(self, angle, x=None, y=None):
    if x is None:
        x = self.x
    if y is None:
        y = self.y
    angle *= math.pi / 180
    c, s = math.cos(angle), math.sin(angle)
    cx, cy = x * self.k, (self.h - y) * self.k
    self._out(
        sprintf(
            &#34;q %.5F %.5F %.5F %.5F %.2F %.2F cm 1 0 0 1 %.2F %.2F cm\n&#34;,
            c,
            s,
            -s,
            c,
            cx,
            cy,
            -cx,
            -cy,
        )
    )
    yield
    self._out(&#34;Q\n&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_author"><code class="name flex">
<span>def <span class="ident">set_author</span></span>(<span>self, author)</span>
</code></dt>
<dd>
<div class="desc"><p>Author of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_author(self, author):
    &#34;Author of document&#34;
    self.author = author</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_auto_page_break"><code class="name flex">
<span>def <span class="ident">set_auto_page_break</span></span>(<span>self, auto, margin=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set auto page break mode and triggering margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_auto_page_break(self, auto, margin=0):
    &#34;Set auto page break mode and triggering margin&#34;
    self.auto_page_break = auto
    self.b_margin = margin
    self.page_break_trigger = self.h - margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_compression"><code class="name flex">
<span>def <span class="ident">set_compression</span></span>(<span>self, compress)</span>
</code></dt>
<dd>
<div class="desc"><p>Set page compression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compression(self, compress):
    &#34;Set page compression&#34;
    self.compress = compress</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_creation_date"><code class="name flex">
<span>def <span class="ident">set_creation_date</span></span>(<span>self, date=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets Creation of Date time, or current time if None given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creation_date(self, date=None):
    &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
    self.creation_date = datetime.now() if date is None else date</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_creator"><code class="name flex">
<span>def <span class="ident">set_creator</span></span>(<span>self, creator)</span>
</code></dt>
<dd>
<div class="desc"><p>Creator of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creator(self, creator):
    &#34;Creator of document&#34;
    self.creator = creator</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_display_mode"><code class="name flex">
<span>def <span class="ident">set_display_mode</span></span>(<span>self, zoom, layout='continuous')</span>
</code></dt>
<dd>
<div class="desc"><p>Set display mode in viewer</p>
<p>The "zoom" argument may be 'fullpage', 'fullwidth', 'real',
'default', or a number, interpreted as a percentage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
    &#34;&#34;&#34;Set display mode in viewer

    The &#34;zoom&#34; argument may be &#39;fullpage&#39;, &#39;fullwidth&#39;, &#39;real&#39;,
    &#39;default&#39;, or a number, interpreted as a percentage.
    &#34;&#34;&#34;
    if zoom in [&#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;]:
        self.zoom_mode = zoom
    elif not isinstance(zoom, str):
        self.zoom_mode = zoom
    else:
        fpdf_error(&#34;Incorrect zoom display mode: &#34; + zoom)

    if layout in [&#34;single&#34;, &#34;continuous&#34;, &#34;two&#34;, &#34;default&#34;]:
        self.layout_mode = layout
    else:
        fpdf_error(&#34;Incorrect layout display mode: &#34; + layout)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_doc_option"><code class="name flex">
<span>def <span class="ident">set_doc_option</span></span>(<span>self, opt, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set document option</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_doc_option(self, opt, value):
    &#34;Set document option&#34;
    if opt == &#34;core_fonts_encoding&#34;:
        self.core_fonts_encoding = value
    else:
        fpdf_error(&#39;Unknown document option &#34;%s&#34;&#39; % str(opt))</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_draw_color"><code class="name flex">
<span>def <span class="ident">set_draw_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for all stroking operations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_draw_color(self, r, g=-1, b=-1):
    &#34;Set color for all stroking operations&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.draw_color = sprintf(&#34;%.3f G&#34;, r / 255.0)
    else:
        self.draw_color = sprintf(
            &#34;%.3f %.3f %.3f RG&#34;, r / 255.0, g / 255.0, b / 255.0
        )
    if self.page &gt; 0:
        self._out(self.draw_color)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_fill_color"><code class="name flex">
<span>def <span class="ident">set_fill_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for all filling operations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fill_color(self, r, g=-1, b=-1):
    &#34;Set color for all filling operations&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.fill_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
    else:
        self.fill_color = sprintf(
            &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
        )
    self.color_flag = self.fill_color != self.text_color
    if self.page &gt; 0:
        self._out(self.fill_color)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self, family, style='', size=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Select a font; size given in points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font(self, family, style=&#34;&#34;, size=0):
    &#34;Select a font; size given in points&#34;
    family = family.lower()
    if family == &#34;&#34;:
        family = self.font_family
    if family == &#34;arial&#34;:
        family = &#34;helvetica&#34;
    elif family == &#34;symbol&#34; or family == &#34;zapfdingbats&#34;:
        style = &#34;&#34;
    style = style.upper()
    if &#34;U&#34; in style:
        self.underline = 1
        style = style.replace(&#34;U&#34;, &#34;&#34;)
    else:
        self.underline = 0
    if style == &#34;IB&#34;:
        style = &#34;BI&#34;
    if size == 0:
        size = self.font_size_pt

    # Test if font is already selected
    if (
        self.font_family == family
        and self.font_style == style
        and self.font_size_pt == size
    ):
        return

    # Test if used for the first time
    fontkey = family + style
    if fontkey not in self.fonts:
        # Check if one of standard fonts
        if fontkey in self.core_fonts:
            if fontkey not in fpdf_charwidths:
                # Load metric file
                name = os.path.join(FPDF_FONT_DIR, family)
                if family == &#34;times&#34; or family == &#34;helvetica&#34;:
                    name += style.lower()
                with open(name + &#34;.font&#34;) as file:
                    exec(compile(file.read(), name + &#34;.font&#34;, &#34;exec&#34;))
                if fontkey not in fpdf_charwidths:
                    fpdf_error(&#34;Could not include font metric file for&#34; + fontkey)
            i = len(self.fonts) + 1
            self.fonts[fontkey] = {
                &#34;i&#34;: i,
                &#34;type&#34;: &#34;core&#34;,
                &#34;name&#34;: self.core_fonts[fontkey],
                &#34;up&#34;: -100,
                &#34;ut&#34;: 50,
                &#34;cw&#34;: fpdf_charwidths[fontkey],
            }
        else:
            fpdf_error(&#34;Undefined font: &#34; + family + &#34; &#34; + style)

    # Select it
    self.font_family = family
    self.font_style = style
    self.font_size_pt = size
    self.font_size = size / self.k
    self.current_font = self.fonts[fontkey]
    self.unifontsubset = self.fonts[fontkey][&#34;type&#34;] == &#34;TTF&#34;
    if self.page &gt; 0:
        self._out(
            sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
        )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_font_size"><code class="name flex">
<span>def <span class="ident">set_font_size</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Set font size in points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font_size(self, size):
    &#34;Set font size in points&#34;
    if self.font_size_pt == size:
        return
    self.font_size_pt = size
    self.font_size = size / self.k
    if self.page &gt; 0:
        self._out(
            sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
        )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_keywords"><code class="name flex">
<span>def <span class="ident">set_keywords</span></span>(<span>self, keywords)</span>
</code></dt>
<dd>
<div class="desc"><p>Keywords of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_keywords(self, keywords):
    &#34;Keywords of document&#34;
    self.keywords = keywords</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_left_margin"><code class="name flex">
<span>def <span class="ident">set_left_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set left margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_left_margin(self, margin):
    &#34;Set left margin&#34;
    self.l_margin = margin
    if self.page &gt; 0 and self.x &lt; margin:
        self.x = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_line_width"><code class="name flex">
<span>def <span class="ident">set_line_width</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Set line width</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_line_width(self, width):
    &#34;Set line width&#34;
    self.line_width = width
    if self.page &gt; 0:
        self._out(sprintf(&#34;%.2f w&#34;, width * self.k))</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_link"><code class="name flex">
<span>def <span class="ident">set_link</span></span>(<span>self, link, y=0, page=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set destination of internal link</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_link(self, link, y=0, page=-1):
    &#34;Set destination of internal link&#34;
    if y == -1:
        y = self.y
    if page == -1:
        page = self.page

    self.links[link] = [page, y]</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_margins"><code class="name flex">
<span>def <span class="ident">set_margins</span></span>(<span>self, left, top, right=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set left, top and right margins</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_margins(self, left, top, right=-1):
    &#34;Set left, top and right margins&#34;
    self.l_margin = left
    self.t_margin = top
    if right == -1:
        right = left
    self.r_margin = right</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_right_margin"><code class="name flex">
<span>def <span class="ident">set_right_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set right margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_right_margin(self, margin):
    &#34;Set right margin&#34;
    self.r_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_stretching"><code class="name flex">
<span>def <span class="ident">set_stretching</span></span>(<span>self, factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Set from stretch factor percents (default: 100.0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stretching(self, factor):
    &#34;Set from stretch factor percents (default: 100.0)&#34;
    if self.font_stretching == factor:
        return
    self.font_stretching = factor
    if self.page &gt; 0:
        self._out(sprintf(&#34;BT %.2f Tz ET&#34;, self.font_stretching))</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_subject"><code class="name flex">
<span>def <span class="ident">set_subject</span></span>(<span>self, subject)</span>
</code></dt>
<dd>
<div class="desc"><p>Subject of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_subject(self, subject):
    &#34;Subject of document&#34;
    self.subject = subject</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text_color(self, r, g=-1, b=-1):
    &#34;Set color for text&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.text_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
    else:
        self.text_color = sprintf(
            &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
        )
    self.color_flag = self.fill_color != self.text_color</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_title"><code class="name flex">
<span>def <span class="ident">set_title</span></span>(<span>self, title)</span>
</code></dt>
<dd>
<div class="desc"><p>Title of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_title(self, title):
    &#34;Title of document&#34;
    self.title = title</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_top_margin"><code class="name flex">
<span>def <span class="ident">set_top_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set top margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_top_margin(self, margin):
    &#34;Set top margin&#34;
    self.t_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_x"><code class="name flex">
<span>def <span class="ident">set_x</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Set x position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x(self, x):
    &#34;Set x position&#34;
    if x &gt;= 0:
        self.x = x
    else:
        self.x = self.w + x</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_xy"><code class="name flex">
<span>def <span class="ident">set_xy</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Set x and y positions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_xy(self, x, y):
    &#34;Set x and y positions&#34;
    self.set_y(y)
    self.set_x(x)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_y"><code class="name flex">
<span>def <span class="ident">set_y</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Set y position and reset x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_y(self, y):
    &#34;Set y position and reset x&#34;
    self.x = self.l_margin
    if y &gt;= 0:
        self.y = y
    else:
        self.y = self.h + y</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, x, y, txt='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def text(self, x, y, txt=&#34;&#34;):
    &#34;Output a string&#34;
    txt = self.normalize_text(txt)
    if self.unifontsubset:
        txt2 = UTF8ToUTF16BE(escape_parens(txt), False)
        for uni in UTF8StringToArray(txt):
            self.current_font[&#34;subset&#34;].append(uni)
    else:
        txt2 = escape_parens(txt)
    s = sprintf(
        &#34;BT %.2f %.2f Td (%s) Tj ET&#34;, x * self.k, (self.h - y) * self.k, txt2
    )
    if self.underline and txt != &#34;&#34;:
        s += &#34; &#34; + self._dounderline(x, y, txt)
    if self.color_flag:
        s = &#34;q &#34; + self.text_color + &#34; &#34; + s + &#34; Q&#34;
    self._out(s)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, h, txt='', link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output text in flowing mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def write(self, h, txt=&#34;&#34;, link=&#34;&#34;):
    &#34;Output text in flowing mode&#34;
    txt = self.normalize_text(txt)
    cw = self.current_font[&#34;cw&#34;]
    w = self.w - self.r_margin - self.x
    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
    s = txt.replace(&#34;\r&#34;, &#34;&#34;)
    nb = len(s)
    sep = -1
    i = 0
    j = 0
    l = 0
    nl = 1
    while i &lt; nb:
        # Get next character
        c = s[i]
        if c == &#34;\n&#34;:
            # Explicit line break
            self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
            i += 1
            sep = -1
            j = i
            l = 0
            if nl == 1:
                self.x = self.l_margin
                w = self.w - self.r_margin - self.x
                wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
            nl += 1
            continue
        if c == &#34; &#34;:
            sep = i
        if self.unifontsubset:
            l += self.get_string_width(c, True) / self.font_size * 1000.0
        else:
            l += cw.get(c, 0)
        if l &gt; wmax:
            # Automatic line break
            if sep == -1:
                if self.x &gt; self.l_margin:
                    # Move to next line
                    self.x = self.l_margin
                    self.y += h
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                    i += 1
                    nl += 1
                    continue
                if i == j:
                    i += 1
                self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
            else:
                self.cell(w, h, substr(s, j, sep - j), 0, 2, &#34;&#34;, 0, link)
                i = sep + 1
            sep = -1
            j = i
            l = 0
            if nl == 1:
                self.x = self.l_margin
                w = self.w - self.r_margin - self.x
                wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
            nl += 1
        else:
            i += 1
    # Last chunk
    if i != j:
        self.cell(l / 1000.0 * self.font_size, h, substr(s, j), 0, 0, &#34;&#34;, 0, link)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.HTMLMixin"><code class="flex name class">
<span>class <span class="ident">HTMLMixin</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HTMLMixin(object):
    def write_html(self, text, image_map=None):
        &#34;Parse HTML and convert it to PDF&#34;
        h2p = HTML2FPDF(self, image_map)
        text = html.unescape(text)  # To deal with HTML entities
        h2p.feed(text)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.HTMLMixin.write_html"><code class="name flex">
<span>def <span class="ident">write_html</span></span>(<span>self, text, image_map=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse HTML and convert it to PDF</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_html(self, text, image_map=None):
    &#34;Parse HTML and convert it to PDF&#34;
    h2p = HTML2FPDF(self, image_map)
    text = html.unescape(text)  # To deal with HTML entities
    h2p.feed(text)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.Template"><code class="flex name class">
<span>class <span class="ident">Template</span></span>
<span>(</span><span>infile=None, elements=None, format='A4', orientation='portrait', title='', author='', subject='', creator='', keywords='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Template:
    def __init__(
        self,
        infile=None,
        elements=None,
        format=&#34;A4&#34;,
        orientation=&#34;portrait&#34;,
        title=&#34;&#34;,
        author=&#34;&#34;,
        subject=&#34;&#34;,
        creator=&#34;&#34;,
        keywords=&#34;&#34;,
    ):
        if elements:
            self.load_elements(elements)
        self.handlers = {
            &#34;T&#34;: self.text,
            &#34;L&#34;: self.line,
            &#34;I&#34;: self.image,
            &#34;B&#34;: self.rect,
            &#34;BC&#34;: self.barcode,
            &#34;W&#34;: self.write,
        }
        self.texts = {}
        pdf = self.pdf = FPDF(format=format, orientation=orientation, unit=&#34;mm&#34;)
        pdf.set_title(title)
        pdf.set_author(author)
        pdf.set_creator(creator)
        pdf.set_subject(subject)
        pdf.set_keywords(keywords)

    def load_elements(self, elements):
        &#34;Initialize the internal element structures&#34;
        self.pg_no = 0
        self.elements = elements
        self.keys = [v[&#34;name&#34;].lower() for v in self.elements]

    def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;):
        &#34;Parse template format csv file and create elements dict&#34;
        keys = (
            &#34;name&#34;,
            &#34;type&#34;,
            &#34;x1&#34;,
            &#34;y1&#34;,
            &#34;x2&#34;,
            &#34;y2&#34;,
            &#34;font&#34;,
            &#34;size&#34;,
            &#34;bold&#34;,
            &#34;italic&#34;,
            &#34;underline&#34;,
            &#34;foreground&#34;,
            &#34;background&#34;,
            &#34;align&#34;,
            &#34;text&#34;,
            &#34;priority&#34;,
            &#34;multiline&#34;,
        )
        self.elements = []
        self.pg_no = 0
        with open(infile) as f:
            for row in csv.reader(f, delimiter=delimiter):
                kargs = {}
                for i, v in enumerate(row):
                    if not v.startswith(&#34;&#39;&#34;) and decimal_sep != &#34;.&#34;:
                        v = v.replace(decimal_sep, &#34;.&#34;)
                    else:
                        v = v
                    if v == &#34;&#34;:
                        v = None
                    else:
                        v = eval(v.strip())
                    kargs[keys[i]] = v
                self.elements.append(kargs)
        self.keys = [v[&#34;name&#34;].lower() for v in self.elements]

    def add_page(self):
        self.pg_no += 1
        self.texts[self.pg_no] = {}

    def __setitem__(self, name, value):
        if name.lower() in self.keys:
            if value is None:
                value = &#34;&#34;
            else:
                value = str(value)
            self.texts[self.pg_no][name.lower()] = value

    # setitem shortcut (may be further extended)
    set = __setitem__

    def has_key(self, name):
        return name.lower() in self.keys

    def __contains__(self, name):
        return self.has_key(name)

    def __getitem__(self, name):
        if name in self.keys:
            key = name.lower()
            if key in self.texts:
                # text for this page:
                return self.texts[self.pg_no][key]
            else:
                # find first element for default text:
                elements = [
                    element
                    for element in self.elements
                    if element[&#34;name&#34;].lower() == key
                ]
                if elements:
                    return elements[0][&#34;text&#34;]

    def split_multicell(self, text, element_name):
        &#34;Divide (\n) a string using a given element width&#34;
        pdf = self.pdf
        element = [
            element
            for element in self.elements
            if element[&#34;name&#34;].lower() == element_name.lower()
        ][0]
        style = &#34;&#34;
        if element[&#34;bold&#34;]:
            style += &#34;B&#34;
        if element[&#34;italic&#34;]:
            style += &#34;I&#34;
        if element[&#34;underline&#34;]:
            style += &#34;U&#34;
        pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
        align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
            element[&#34;align&#34;]
        )  # D/I in spanish
        text = str(text)
        return pdf.multi_cell(
            w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
            h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
            txt=text,
            align=align,
            split_only=True,
        )

    def render(self, outfile, dest=&#34;F&#34;):
        pdf = self.pdf
        for pg in range(1, self.pg_no + 1):
            pdf.add_page()
            pdf.set_font(&#34;Arial&#34;, &#34;B&#34;, 16)
            pdf.set_auto_page_break(False, margin=0)

            for element in sorted(self.elements, key=lambda x: x[&#34;priority&#34;]):
                # print &#34;dib&#34;,element[&#39;type&#39;], element[&#39;name&#39;], element[&#39;x1&#39;], element[&#39;y1&#39;], element[&#39;x2&#39;], element[&#39;y2&#39;]
                element = element.copy()
                element[&#34;text&#34;] = self.texts[pg].get(
                    element[&#34;name&#34;].lower(), element[&#34;text&#34;]
                )
                handler_name = element[&#34;type&#34;].upper()
                if &#34;rotate&#34; in element:
                    with pdf.rotation(element[&#34;rotate&#34;], element[&#34;x1&#34;], element[&#34;y1&#34;]):
                        self.handlers[handler_name](pdf, **element)
                else:
                    self.handlers[handler_name](pdf, **element)

        if dest:
            return pdf.output(outfile, dest)

    def text(
        self,
        pdf,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;arial&#34;,
        size=10,
        bold=False,
        italic=False,
        underline=False,
        align=&#34;&#34;,
        foreground=0,
        backgroud=65535,
        multiline=None,
        *args,
        **kwargs
    ):
        if text:
            if pdf.text_color != rgb(foreground):
                pdf.set_text_color(*rgb(foreground))
            if pdf.fill_color != rgb(backgroud):
                pdf.set_fill_color(*rgb(backgroud))

            font = font.strip().lower()
            if font == &#34;arial black&#34;:
                font = &#34;arial&#34;
            style = &#34;&#34;
            for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
                if text.startswith(&#34;&lt;%s&gt;&#34; % tag) and text.endswith(&#34;&lt;/%s&gt;&#34; % tag):
                    text = text[3:-4]
                    style += tag
            if bold:
                style += &#34;B&#34;
            if italic:
                style += &#34;I&#34;
            if underline:
                style += &#34;U&#34;
            align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
                align
            )  # D/I in spanish
            pdf.set_font(font, style, size)
            ##m_k = 72 / 2.54
            ##h = (size/m_k)
            pdf.set_xy(x1, y1)
            if multiline is None:
                # multiline==None: write without wrapping/trimming (default)
                pdf.cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, ln=0, align=align)
            elif multiline:
                # multiline==True: automatic word - warp
                pdf.multi_cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, align=align)
            else:
                # multiline==False: trim to fit exactly the space defined
                text = pdf.multi_cell(
                    w=x2 - x1, h=y2 - y1, txt=text, align=align, split_only=True
                )[0]
                print(&#34;trimming: *%s*&#34; % text)
                pdf.cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, ln=0, align=align)

            # pdf.Text(x=x1,y=y1,txt=text)

    def line(self, pdf, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, *args, **kwargs):
        if pdf.draw_color != rgb(foreground):
            # print &#34;SetDrawColor&#34;, hex(foreground)
            pdf.set_draw_color(*rgb(foreground))
        # print &#34;SetLineWidth&#34;, size
        pdf.set_line_width(size)
        pdf.line(x1, y1, x2, y2)

    def rect(
        self,
        pdf,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        foreground=0,
        backgroud=65535,
        *args,
        **kwargs
    ):
        if pdf.draw_color != rgb(foreground):
            pdf.set_draw_color(*rgb(foreground))
        if pdf.fill_color != rgb(backgroud):
            pdf.set_fill_color(*rgb(backgroud))
        pdf.set_line_width(size)
        pdf.rect(x1, y1, x2 - x1, y2 - y1)

    def image(self, pdf, x1=0, y1=0, x2=0, y2=0, text=&#34;&#34;, *args, **kwargs):
        if text:
            pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, type=&#34;&#34;, link=&#34;&#34;)

    def barcode(
        self,
        pdf,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;arial&#34;,
        size=1,
        foreground=0,
        *args,
        **kwargs
    ):
        if pdf.draw_color != rgb(foreground):
            pdf.set_draw_color(*rgb(foreground))
        font = font.lower().strip()
        if font == &#34;interleaved 2of5 nt&#34;:
            pdf.interleaved2of5(text, x1, y1, w=size, h=y2 - y1)

    # Added by Derek Schwalenberg Schwalenberg1013@gmail.com to allow (url) links in templates (using write method) 2014-02-22
    def write(
        self,
        pdf,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;arial&#34;,
        size=1,
        bold=False,
        italic=False,
        underline=False,
        align=&#34;&#34;,
        link=&#34;http://example.com&#34;,
        foreground=0,
        *args,
        **kwargs
    ):
        if pdf.text_color != rgb(foreground):
            pdf.set_text_color(*rgb(foreground))
        font = font.strip().lower()
        if font == &#34;arial black&#34;:
            font = &#34;arial&#34;
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(&#34;&lt;%s&gt;&#34; % tag) and text.endswith(&#34;&lt;/%s&gt;&#34; % tag):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
            align
        )  # D/I in spanish
        pdf.set_font(font, style, size)
        ##m_k = 72 / 2.54
        ##h = (size/m_k)
        pdf.set_xy(x1, y1)
        pdf.write(5, text, link)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.Template.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page(self):
    self.pg_no += 1
    self.texts[self.pg_no] = {}</code></pre>
</details>
</dd>
<dt id="fpdf.Template.barcode"><code class="name flex">
<span>def <span class="ident">barcode</span></span>(<span>self, pdf, x1=0, y1=0, x2=0, y2=0, text='', font='arial', size=1, foreground=0, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def barcode(
    self,
    pdf,
    x1=0,
    y1=0,
    x2=0,
    y2=0,
    text=&#34;&#34;,
    font=&#34;arial&#34;,
    size=1,
    foreground=0,
    *args,
    **kwargs
):
    if pdf.draw_color != rgb(foreground):
        pdf.set_draw_color(*rgb(foreground))
    font = font.lower().strip()
    if font == &#34;interleaved 2of5 nt&#34;:
        pdf.interleaved2of5(text, x1, y1, w=size, h=y2 - y1)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.has_key"><code class="name flex">
<span>def <span class="ident">has_key</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_key(self, name):
    return name.lower() in self.keys</code></pre>
</details>
</dd>
<dt id="fpdf.Template.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self, pdf, x1=0, y1=0, x2=0, y2=0, text='', *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image(self, pdf, x1=0, y1=0, x2=0, y2=0, text=&#34;&#34;, *args, **kwargs):
    if text:
        pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, type=&#34;&#34;, link=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>self, pdf, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def line(self, pdf, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, *args, **kwargs):
    if pdf.draw_color != rgb(foreground):
        # print &#34;SetDrawColor&#34;, hex(foreground)
        pdf.set_draw_color(*rgb(foreground))
    # print &#34;SetLineWidth&#34;, size
    pdf.set_line_width(size)
    pdf.line(x1, y1, x2, y2)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.load_elements"><code class="name flex">
<span>def <span class="ident">load_elements</span></span>(<span>self, elements)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the internal element structures</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_elements(self, elements):
    &#34;Initialize the internal element structures&#34;
    self.pg_no = 0
    self.elements = elements
    self.keys = [v[&#34;name&#34;].lower() for v in self.elements]</code></pre>
</details>
</dd>
<dt id="fpdf.Template.parse_csv"><code class="name flex">
<span>def <span class="ident">parse_csv</span></span>(<span>self, infile, delimiter=',', decimal_sep='.')</span>
</code></dt>
<dd>
<div class="desc"><p>Parse template format csv file and create elements dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;):
    &#34;Parse template format csv file and create elements dict&#34;
    keys = (
        &#34;name&#34;,
        &#34;type&#34;,
        &#34;x1&#34;,
        &#34;y1&#34;,
        &#34;x2&#34;,
        &#34;y2&#34;,
        &#34;font&#34;,
        &#34;size&#34;,
        &#34;bold&#34;,
        &#34;italic&#34;,
        &#34;underline&#34;,
        &#34;foreground&#34;,
        &#34;background&#34;,
        &#34;align&#34;,
        &#34;text&#34;,
        &#34;priority&#34;,
        &#34;multiline&#34;,
    )
    self.elements = []
    self.pg_no = 0
    with open(infile) as f:
        for row in csv.reader(f, delimiter=delimiter):
            kargs = {}
            for i, v in enumerate(row):
                if not v.startswith(&#34;&#39;&#34;) and decimal_sep != &#34;.&#34;:
                    v = v.replace(decimal_sep, &#34;.&#34;)
                else:
                    v = v
                if v == &#34;&#34;:
                    v = None
                else:
                    v = eval(v.strip())
                kargs[keys[i]] = v
            self.elements.append(kargs)
    self.keys = [v[&#34;name&#34;].lower() for v in self.elements]</code></pre>
</details>
</dd>
<dt id="fpdf.Template.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>self, pdf, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, backgroud=65535, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rect(
    self,
    pdf,
    x1=0,
    y1=0,
    x2=0,
    y2=0,
    size=0,
    foreground=0,
    backgroud=65535,
    *args,
    **kwargs
):
    if pdf.draw_color != rgb(foreground):
        pdf.set_draw_color(*rgb(foreground))
    if pdf.fill_color != rgb(backgroud):
        pdf.set_fill_color(*rgb(backgroud))
    pdf.set_line_width(size)
    pdf.rect(x1, y1, x2 - x1, y2 - y1)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, outfile, dest='F')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, outfile, dest=&#34;F&#34;):
    pdf = self.pdf
    for pg in range(1, self.pg_no + 1):
        pdf.add_page()
        pdf.set_font(&#34;Arial&#34;, &#34;B&#34;, 16)
        pdf.set_auto_page_break(False, margin=0)

        for element in sorted(self.elements, key=lambda x: x[&#34;priority&#34;]):
            # print &#34;dib&#34;,element[&#39;type&#39;], element[&#39;name&#39;], element[&#39;x1&#39;], element[&#39;y1&#39;], element[&#39;x2&#39;], element[&#39;y2&#39;]
            element = element.copy()
            element[&#34;text&#34;] = self.texts[pg].get(
                element[&#34;name&#34;].lower(), element[&#34;text&#34;]
            )
            handler_name = element[&#34;type&#34;].upper()
            if &#34;rotate&#34; in element:
                with pdf.rotation(element[&#34;rotate&#34;], element[&#34;x1&#34;], element[&#34;y1&#34;]):
                    self.handlers[handler_name](pdf, **element)
            else:
                self.handlers[handler_name](pdf, **element)

    if dest:
        return pdf.output(outfile, dest)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __setitem__(self, name, value):
    if name.lower() in self.keys:
        if value is None:
            value = &#34;&#34;
        else:
            value = str(value)
        self.texts[self.pg_no][name.lower()] = value</code></pre>
</details>
</dd>
<dt id="fpdf.Template.split_multicell"><code class="name flex">
<span>def <span class="ident">split_multicell</span></span>(<span>self, text, element_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Divide (
) a string using a given element width</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_multicell(self, text, element_name):
    &#34;Divide (\n) a string using a given element width&#34;
    pdf = self.pdf
    element = [
        element
        for element in self.elements
        if element[&#34;name&#34;].lower() == element_name.lower()
    ][0]
    style = &#34;&#34;
    if element[&#34;bold&#34;]:
        style += &#34;B&#34;
    if element[&#34;italic&#34;]:
        style += &#34;I&#34;
    if element[&#34;underline&#34;]:
        style += &#34;U&#34;
    pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
    align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
        element[&#34;align&#34;]
    )  # D/I in spanish
    text = str(text)
    return pdf.multi_cell(
        w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
        h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
        txt=text,
        align=align,
        split_only=True,
    )</code></pre>
</details>
</dd>
<dt id="fpdf.Template.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, pdf, x1=0, y1=0, x2=0, y2=0, text='', font='arial', size=10, bold=False, italic=False, underline=False, align='', foreground=0, backgroud=65535, multiline=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text(
    self,
    pdf,
    x1=0,
    y1=0,
    x2=0,
    y2=0,
    text=&#34;&#34;,
    font=&#34;arial&#34;,
    size=10,
    bold=False,
    italic=False,
    underline=False,
    align=&#34;&#34;,
    foreground=0,
    backgroud=65535,
    multiline=None,
    *args,
    **kwargs
):
    if text:
        if pdf.text_color != rgb(foreground):
            pdf.set_text_color(*rgb(foreground))
        if pdf.fill_color != rgb(backgroud):
            pdf.set_fill_color(*rgb(backgroud))

        font = font.strip().lower()
        if font == &#34;arial black&#34;:
            font = &#34;arial&#34;
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(&#34;&lt;%s&gt;&#34; % tag) and text.endswith(&#34;&lt;/%s&gt;&#34; % tag):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
            align
        )  # D/I in spanish
        pdf.set_font(font, style, size)
        ##m_k = 72 / 2.54
        ##h = (size/m_k)
        pdf.set_xy(x1, y1)
        if multiline is None:
            # multiline==None: write without wrapping/trimming (default)
            pdf.cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, ln=0, align=align)
        elif multiline:
            # multiline==True: automatic word - warp
            pdf.multi_cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, align=align)
        else:
            # multiline==False: trim to fit exactly the space defined
            text = pdf.multi_cell(
                w=x2 - x1, h=y2 - y1, txt=text, align=align, split_only=True
            )[0]
            print(&#34;trimming: *%s*&#34; % text)
            pdf.cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, ln=0, align=align)

        # pdf.Text(x=x1,y=y1,txt=text)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, pdf, x1=0, y1=0, x2=0, y2=0, text='', font='arial', size=1, bold=False, italic=False, underline=False, align='', link='http://example.com', foreground=0, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(
    self,
    pdf,
    x1=0,
    y1=0,
    x2=0,
    y2=0,
    text=&#34;&#34;,
    font=&#34;arial&#34;,
    size=1,
    bold=False,
    italic=False,
    underline=False,
    align=&#34;&#34;,
    link=&#34;http://example.com&#34;,
    foreground=0,
    *args,
    **kwargs
):
    if pdf.text_color != rgb(foreground):
        pdf.set_text_color(*rgb(foreground))
    font = font.strip().lower()
    if font == &#34;arial black&#34;:
        font = &#34;arial&#34;
    style = &#34;&#34;
    for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
        if text.startswith(&#34;&lt;%s&gt;&#34; % tag) and text.endswith(&#34;&lt;/%s&gt;&#34; % tag):
            text = text[3:-4]
            style += tag
    if bold:
        style += &#34;B&#34;
    if italic:
        style += &#34;I&#34;
    if underline:
        style += &#34;U&#34;
    align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
        align
    )  # D/I in spanish
    pdf.set_font(font, style, size)
    ##m_k = 72 / 2.54
    ##h = (size/m_k)
    pdf.set_xy(x1, y1)
    pdf.write(5, text, link)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fpdf.errors" href="errors.html">fpdf.errors</a></code></li>
<li><code><a title="fpdf.fonts" href="fonts.html">fpdf.fonts</a></code></li>
<li><code><a title="fpdf.fpdf" href="fpdf.html">fpdf.fpdf</a></code></li>
<li><code><a title="fpdf.html" href="html.html">fpdf.html</a></code></li>
<li><code><a title="fpdf.image_parsing" href="image_parsing.html">fpdf.image_parsing</a></code></li>
<li><code><a title="fpdf.php" href="php.html">fpdf.php</a></code></li>
<li><code><a title="fpdf.template" href="template.html">fpdf.template</a></code></li>
<li><code><a title="fpdf.ttfonts" href="ttfonts.html">fpdf.ttfonts</a></code></li>
<li><code><a title="fpdf.util" href="util/index.html">fpdf.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="fpdf.FPDF_CACHE_DIR" href="#fpdf.FPDF_CACHE_DIR">FPDF_CACHE_DIR</a></code></li>
<li><code><a title="fpdf.FPDF_FONT_DIR" href="#fpdf.FPDF_FONT_DIR">FPDF_FONT_DIR</a></code></li>
<li><code><a title="fpdf.FPDF_VERSION" href="#fpdf.FPDF_VERSION">FPDF_VERSION</a></code></li>
<li><code><a title="fpdf.SYSTEM_TTFONTS" href="#fpdf.SYSTEM_TTFONTS">SYSTEM_TTFONTS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.FPDF" href="#fpdf.FPDF">FPDF</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.FPDF.accept_page_break" href="#fpdf.FPDF.accept_page_break">accept_page_break</a></code></li>
<li><code><a title="fpdf.FPDF.add_font" href="#fpdf.FPDF.add_font">add_font</a></code></li>
<li><code><a title="fpdf.FPDF.add_link" href="#fpdf.FPDF.add_link">add_link</a></code></li>
<li><code><a title="fpdf.FPDF.add_page" href="#fpdf.FPDF.add_page">add_page</a></code></li>
<li><code><a title="fpdf.FPDF.alias_nb_pages" href="#fpdf.FPDF.alias_nb_pages">alias_nb_pages</a></code></li>
<li><code><a title="fpdf.FPDF.cell" href="#fpdf.FPDF.cell">cell</a></code></li>
<li><code><a title="fpdf.FPDF.check_page" href="#fpdf.FPDF.check_page">check_page</a></code></li>
<li><code><a title="fpdf.FPDF.close" href="#fpdf.FPDF.close">close</a></code></li>
<li><code><a title="fpdf.FPDF.code39" href="#fpdf.FPDF.code39">code39</a></code></li>
<li><code><a title="fpdf.FPDF.dashed_line" href="#fpdf.FPDF.dashed_line">dashed_line</a></code></li>
<li><code><a title="fpdf.FPDF.ellipse" href="#fpdf.FPDF.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.FPDF.footer" href="#fpdf.FPDF.footer">footer</a></code></li>
<li><code><a title="fpdf.FPDF.get_string_width" href="#fpdf.FPDF.get_string_width">get_string_width</a></code></li>
<li><code><a title="fpdf.FPDF.get_x" href="#fpdf.FPDF.get_x">get_x</a></code></li>
<li><code><a title="fpdf.FPDF.get_y" href="#fpdf.FPDF.get_y">get_y</a></code></li>
<li><code><a title="fpdf.FPDF.header" href="#fpdf.FPDF.header">header</a></code></li>
<li><code><a title="fpdf.FPDF.image" href="#fpdf.FPDF.image">image</a></code></li>
<li><code><a title="fpdf.FPDF.interleaved2of5" href="#fpdf.FPDF.interleaved2of5">interleaved2of5</a></code></li>
<li><code><a title="fpdf.FPDF.line" href="#fpdf.FPDF.line">line</a></code></li>
<li><code><a title="fpdf.FPDF.link" href="#fpdf.FPDF.link">link</a></code></li>
<li><code><a title="fpdf.FPDF.ln" href="#fpdf.FPDF.ln">ln</a></code></li>
<li><code><a title="fpdf.FPDF.multi_cell" href="#fpdf.FPDF.multi_cell">multi_cell</a></code></li>
<li><code><a title="fpdf.FPDF.normalize_text" href="#fpdf.FPDF.normalize_text">normalize_text</a></code></li>
<li><code><a title="fpdf.FPDF.open" href="#fpdf.FPDF.open">open</a></code></li>
<li><code><a title="fpdf.FPDF.output" href="#fpdf.FPDF.output">output</a></code></li>
<li><code><a title="fpdf.FPDF.page_no" href="#fpdf.FPDF.page_no">page_no</a></code></li>
<li><code><a title="fpdf.FPDF.rect" href="#fpdf.FPDF.rect">rect</a></code></li>
<li><code><a title="fpdf.FPDF.rect_clip" href="#fpdf.FPDF.rect_clip">rect_clip</a></code></li>
<li><code><a title="fpdf.FPDF.rotate" href="#fpdf.FPDF.rotate">rotate</a></code></li>
<li><code><a title="fpdf.FPDF.rotation" href="#fpdf.FPDF.rotation">rotation</a></code></li>
<li><code><a title="fpdf.FPDF.set_author" href="#fpdf.FPDF.set_author">set_author</a></code></li>
<li><code><a title="fpdf.FPDF.set_auto_page_break" href="#fpdf.FPDF.set_auto_page_break">set_auto_page_break</a></code></li>
<li><code><a title="fpdf.FPDF.set_compression" href="#fpdf.FPDF.set_compression">set_compression</a></code></li>
<li><code><a title="fpdf.FPDF.set_creation_date" href="#fpdf.FPDF.set_creation_date">set_creation_date</a></code></li>
<li><code><a title="fpdf.FPDF.set_creator" href="#fpdf.FPDF.set_creator">set_creator</a></code></li>
<li><code><a title="fpdf.FPDF.set_display_mode" href="#fpdf.FPDF.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="fpdf.FPDF.set_doc_option" href="#fpdf.FPDF.set_doc_option">set_doc_option</a></code></li>
<li><code><a title="fpdf.FPDF.set_draw_color" href="#fpdf.FPDF.set_draw_color">set_draw_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_fill_color" href="#fpdf.FPDF.set_fill_color">set_fill_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_font" href="#fpdf.FPDF.set_font">set_font</a></code></li>
<li><code><a title="fpdf.FPDF.set_font_size" href="#fpdf.FPDF.set_font_size">set_font_size</a></code></li>
<li><code><a title="fpdf.FPDF.set_keywords" href="#fpdf.FPDF.set_keywords">set_keywords</a></code></li>
<li><code><a title="fpdf.FPDF.set_left_margin" href="#fpdf.FPDF.set_left_margin">set_left_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_line_width" href="#fpdf.FPDF.set_line_width">set_line_width</a></code></li>
<li><code><a title="fpdf.FPDF.set_link" href="#fpdf.FPDF.set_link">set_link</a></code></li>
<li><code><a title="fpdf.FPDF.set_margins" href="#fpdf.FPDF.set_margins">set_margins</a></code></li>
<li><code><a title="fpdf.FPDF.set_right_margin" href="#fpdf.FPDF.set_right_margin">set_right_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_stretching" href="#fpdf.FPDF.set_stretching">set_stretching</a></code></li>
<li><code><a title="fpdf.FPDF.set_subject" href="#fpdf.FPDF.set_subject">set_subject</a></code></li>
<li><code><a title="fpdf.FPDF.set_text_color" href="#fpdf.FPDF.set_text_color">set_text_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_title" href="#fpdf.FPDF.set_title">set_title</a></code></li>
<li><code><a title="fpdf.FPDF.set_top_margin" href="#fpdf.FPDF.set_top_margin">set_top_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_x" href="#fpdf.FPDF.set_x">set_x</a></code></li>
<li><code><a title="fpdf.FPDF.set_xy" href="#fpdf.FPDF.set_xy">set_xy</a></code></li>
<li><code><a title="fpdf.FPDF.set_y" href="#fpdf.FPDF.set_y">set_y</a></code></li>
<li><code><a title="fpdf.FPDF.text" href="#fpdf.FPDF.text">text</a></code></li>
<li><code><a title="fpdf.FPDF.write" href="#fpdf.FPDF.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.HTMLMixin" href="#fpdf.HTMLMixin">HTMLMixin</a></code></h4>
<ul class="">
<li><code><a title="fpdf.HTMLMixin.write_html" href="#fpdf.HTMLMixin.write_html">write_html</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.Template" href="#fpdf.Template">Template</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.Template.add_page" href="#fpdf.Template.add_page">add_page</a></code></li>
<li><code><a title="fpdf.Template.barcode" href="#fpdf.Template.barcode">barcode</a></code></li>
<li><code><a title="fpdf.Template.has_key" href="#fpdf.Template.has_key">has_key</a></code></li>
<li><code><a title="fpdf.Template.image" href="#fpdf.Template.image">image</a></code></li>
<li><code><a title="fpdf.Template.line" href="#fpdf.Template.line">line</a></code></li>
<li><code><a title="fpdf.Template.load_elements" href="#fpdf.Template.load_elements">load_elements</a></code></li>
<li><code><a title="fpdf.Template.parse_csv" href="#fpdf.Template.parse_csv">parse_csv</a></code></li>
<li><code><a title="fpdf.Template.rect" href="#fpdf.Template.rect">rect</a></code></li>
<li><code><a title="fpdf.Template.render" href="#fpdf.Template.render">render</a></code></li>
<li><code><a title="fpdf.Template.set" href="#fpdf.Template.set">set</a></code></li>
<li><code><a title="fpdf.Template.split_multicell" href="#fpdf.Template.split_multicell">split_multicell</a></code></li>
<li><code><a title="fpdf.Template.text" href="#fpdf.Template.text">text</a></code></li>
<li><code><a title="fpdf.Template.write" href="#fpdf.Template.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>