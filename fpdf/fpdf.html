<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fpdf.fpdf API documentation</title>
<meta name="description" content="fpdf module (in fpdf package housing FPDF class) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.fpdf</code></h1>
</header>
<section id="section-intro">
<p>fpdf module (in fpdf package housing FPDF class)</p>
<p>This module contains FPDF class inspiring this library.
The version number is updated here (above and below in variable).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ****************************************************************************
# * Software: FPDF for python                                                *
# * License:  LGPL v3.0                                                      *
# *                                                                          *
# * Original Author (PHP):  Olivier PLATHEY 2004-12-31                       *
# * Ported to Python 2.4 by Max (maxpat78@yahoo.it) on 2006-05               *
# * Maintainer:  Mariano Reingart (reingart@gmail.com) et al since 2008 est. *
# * Maintainer:  David Alexander (daveankin@gmail.com) et al since 2017 est. *
# * NOTE: &#39;I&#39; and &#39;D&#39; destinations are disabled, and simply print to STDOUT  *
# ****************************************************************************
&#34;&#34;&#34;fpdf module (in fpdf package housing FPDF class)

This module contains FPDF class inspiring this library.
The version number is updated here (above and below in variable).
&#34;&#34;&#34;

from contextlib import contextmanager
from datetime import datetime
from collections import OrderedDict
from functools import wraps
from uuid import uuid4
import errno
import logging
import math
import os
import pickle
import re
import sys
import warnings
import zlib
from hashlib import md5

from .errors import FPDFException, FPDFPageFormatException
from .fonts import fpdf_charwidths
from .image_parsing import get_img_info, load_resource
from .ttfonts import TTFontFile
from .util import (
    enclose_in_parens,
    escape_parens,
    sprintf,
    substr,
)
from .util.syntax import (
    create_name as pdf_name,
    create_dictionary_string as pdf_d,
    create_list_string as pdf_l,
    iobj_ref as pdf_ref,
    create_stream as pdf_stream,
)

LOGGER = logging.getLogger(__name__)

# Global variables
FPDF_VERSION = &#34;2.2.0&#34;
FPDF_FONT_DIR = os.path.join(os.path.dirname(__file__), &#34;font&#34;)
FPDF_CACHE_MODE = 0  # 0 - in same folder, 1 - none, 2 - hash
FPDF_CACHE_DIR = None
SYSTEM_TTFONTS = None

PAGE_FORMATS = {
    &#34;a3&#34;: (841.89, 1190.55),
    &#34;a4&#34;: (595.28, 841.89),
    &#34;a5&#34;: (420.94, 595.28),
    &#34;letter&#34;: (612, 792),
    &#34;legal&#34;: (612, 1008),
}


# Disabling this check due to the &#34;format&#34; parameter below:
# pylint: disable=redefined-builtin
def get_page_format(format, k=None):
    &#34;&#34;&#34;Return page width and height size in points.

    Throws FPDFPageFormatException

    `format` can be either a 2-tuple or one of &#39;a3&#39;, &#39;a4&#39;, &#39;a5&#39;, &#39;letter&#39;, or
    &#39;legal&#39;.

    If format is a tuple, then the return value is the tuple&#39;s values
    given in the units specified on this document in the constructor,
    multiplied by the corresponding scale factor `k`, taken from instance
    variable `self.k`.

    If format is a string, the (width, height) tuple returned is in points.
    For a width and height of 8.5 * 11, 72 dpi is assumed, so the value
    returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be
    added by adding fields to the `fpdf.fpdf.PAGE_FORMATS` dictionary with a
    case insensitive key (the name of the new format) and 2-tuple value of
    (width, height) in dots per inch with a 72 dpi resolution.
    &#34;&#34;&#34;
    if isinstance(format, str):
        format = format.lower()
        if format in PAGE_FORMATS:
            return PAGE_FORMATS[format]
        raise FPDFPageFormatException(format, unknown=True)

    if k is None:
        raise FPDFPageFormatException(format, one=True)

    try:
        return (format[0] * k, format[1] * k)
    except Exception as e:
        args = str(format) + &#34;, &#34; + str(k)
        raise FPDFPageFormatException(&#34;Arguments must be numbers: &#34; + args) from e


def load_cache(filename):
    &#34;&#34;&#34;Return unpickled object, or None if cache unavailable&#34;&#34;&#34;
    if not filename:
        return None
    try:
        with open(filename, &#34;rb&#34;) as fh:
            return pickle.load(fh)
    # File missing, unsupported pickle, etc
    except (IOError, ValueError):
        return None


def check_page(fn):
    &#34;Decorator to protect drawing methods&#34;

    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        if not self.page and not kwargs.get(&#34;split_only&#34;):
            raise FPDFException(&#34;No page open, you need to call add_page() first&#34;)
        return fn(self, *args, **kwargs)

    return wrapper


class FPDF:
    &#34;PDF Generation class&#34;

    def __init__(self, orientation=&#34;P&#34;, unit=&#34;mm&#34;, format=&#34;A4&#34;):
        # Initialization of properties
        self.offsets = {}  # array of object offsets
        self.page = 0  # current page number
        self.n = 2  # current object number
        self.buffer = bytearray()  # buffer holding in-memory PDF
        self.pages = {}  # array containing pages and metadata
        self.state = 0  # current document state
        self.fonts = {}  # array of used fonts
        self.font_files = {}  # array of font files
        self.diffs = {}  # array of encoding differences
        self.images = {}  # array of used images
        self.page_links = {}  # array of links in pages
        self.links = {}  # array of internal links
        self.in_footer = 0  # flag set when processing footer
        self.lasth = 0  # height of last cell printed
        self.font_family = &#34;&#34;  # current font family
        self.font_style = &#34;&#34;  # current font style
        self.font_size_pt = 12  # current font size in points
        self.font_stretching = 100  # current font stretching
        self.unifontsubset = False
        self.underline = 0  # underlining flag
        self.draw_color = &#34;0 G&#34;
        self.fill_color = &#34;0 g&#34;
        self.text_color = &#34;0 g&#34;
        # indicates whether fill and text colors are different
        self.color_flag = 0
        self.ws = 0  # word spacing
        self.angle = 0

        # Standard fonts
        self.core_fonts = {
            &#34;courier&#34;: &#34;Courier&#34;,
            &#34;courierB&#34;: &#34;Courier-Bold&#34;,
            &#34;courierI&#34;: &#34;Courier-Oblique&#34;,
            &#34;courierBI&#34;: &#34;Courier-BoldOblique&#34;,
            &#34;helvetica&#34;: &#34;Helvetica&#34;,
            &#34;helveticaB&#34;: &#34;Helvetica-Bold&#34;,
            &#34;helveticaI&#34;: &#34;Helvetica-Oblique&#34;,
            &#34;helveticaBI&#34;: &#34;Helvetica-BoldOblique&#34;,
            &#34;times&#34;: &#34;Times-Roman&#34;,
            &#34;timesB&#34;: &#34;Times-Bold&#34;,
            &#34;timesI&#34;: &#34;Times-Italic&#34;,
            &#34;timesBI&#34;: &#34;Times-BoldItalic&#34;,
            &#34;symbol&#34;: &#34;Symbol&#34;,
            &#34;zapfdingbats&#34;: &#34;ZapfDingbats&#34;,
        }
        self.core_fonts_encoding = &#34;latin-1&#34;

        # Scale factor
        if unit == &#34;pt&#34;:
            self.k = 1
        elif unit == &#34;mm&#34;:
            self.k = 72 / 25.4
        elif unit == &#34;cm&#34;:
            self.k = 72 / 2.54
        elif unit == &#34;in&#34;:
            self.k = 72.0
        else:
            raise FPDFException(&#34;Incorrect unit: &#34; + unit)

        # Page format
        self.dw_pt, self.dh_pt = get_page_format(format, self.k)

        # Page orientation
        orientation = orientation.lower()
        if orientation in (&#34;p&#34;, &#34;portrait&#34;):
            self.def_orientation = &#34;P&#34;
            self.w_pt = self.dw_pt
            self.h_pt = self.dh_pt
        elif orientation in (&#34;l&#34;, &#34;landscape&#34;):
            self.def_orientation = &#34;L&#34;
            self.w_pt = self.dh_pt
            self.h_pt = self.dw_pt
        else:
            raise FPDFException(&#34;Incorrect orientation: &#34; + orientation)
        self.cur_orientation = self.def_orientation
        self.w = self.w_pt / self.k
        self.h = self.h_pt / self.k

        # Page spacing
        # Page margins (1 cm)
        margin = 28.35 / self.k
        self.set_margins(margin, margin)
        self.c_margin = margin / 10.0  # Interior cell margin (1 mm)
        self.line_width = 0.567 / self.k  # line width (0.2 mm)
        self.set_auto_page_break(1, 2 * margin)  # Automatic page break
        self.set_display_mode(&#34;fullwidth&#34;)  # Full width display mode
        self.compress = True  # Enable compression by default
        self.pdf_version = &#34;1.3&#34;  # Set default PDF version No.

    def set_margins(self, left, top, right=-1):
        &#34;Set left, top and right margins&#34;
        self.l_margin = left
        self.t_margin = top
        if right == -1:
            right = left
        self.r_margin = right

    def set_left_margin(self, margin):
        &#34;Set left margin&#34;
        self.l_margin = margin
        if self.page &gt; 0 and self.x &lt; margin:
            self.x = margin

    def set_top_margin(self, margin):
        &#34;Set top margin&#34;
        self.t_margin = margin

    def set_right_margin(self, margin):
        &#34;Set right margin&#34;
        self.r_margin = margin

    def set_auto_page_break(self, auto, margin=0):
        &#34;Set auto page break mode and triggering margin&#34;
        self.auto_page_break = auto
        self.b_margin = margin
        self.page_break_trigger = self.h - margin

    def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
        &#34;&#34;&#34;Set display mode in viewer

        The &#34;zoom&#34; argument may be &#39;fullpage&#39;, &#39;fullwidth&#39;, &#39;real&#39;,
        &#39;default&#39;, or a number, interpreted as a percentage.
        &#34;&#34;&#34;
        if zoom in [&#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;]:
            self.zoom_mode = zoom
        elif not isinstance(zoom, str):
            self.zoom_mode = zoom
        else:
            raise FPDFException(&#34;Incorrect zoom display mode: &#34; + zoom)

        if layout in [&#34;single&#34;, &#34;continuous&#34;, &#34;two&#34;, &#34;default&#34;]:
            self.layout_mode = layout
        else:
            raise FPDFException(&#34;Incorrect layout display mode: &#34; + layout)

    def set_compression(self, compress):
        &#34;Set page compression&#34;
        self.compress = compress

    def set_title(self, title):
        &#34;Title of document&#34;
        self.title = title

    def set_subject(self, subject):
        &#34;Subject of document&#34;
        self.subject = subject

    def set_author(self, author):
        &#34;Author of document&#34;
        self.author = author

    def set_keywords(self, keywords):
        &#34;Keywords of document&#34;
        self.keywords = keywords

    def set_creator(self, creator):
        &#34;Creator of document&#34;
        self.creator = creator

    def set_creation_date(self, date=None):
        &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
        self.creation_date = datetime.now() if date is None else date

    def set_doc_option(self, opt, value):
        &#34;Set document option&#34;
        if opt == &#34;core_fonts_encoding&#34;:
            self.core_fonts_encoding = value
        else:
            raise FPDFException(&#39;Unknown document option &#34;%s&#34;&#39; % str(opt))

    def alias_nb_pages(self, alias=&#34;{nb}&#34;):
        &#34;Define an alias for total number of pages&#34;
        self.str_alias_nb_pages = alias
        return alias

    def open(self):
        &#34;Begin document&#34;
        self.state = 1

    def close(self):
        &#34;Terminate document&#34;
        if self.state == 3:
            return
        if self.page == 0:
            self.add_page()

        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0

        self._endpage()  # close page
        self._enddoc()  # close document

    def add_page(self, orientation=&#34;&#34;, format=&#34;&#34;, same=False):
        &#34;Start a new page, if same page format will be same as previous&#34;
        if self.state == 0:
            self.open()
        family = self.font_family
        style = self.font_style + &#34;U&#34; if self.underline else self.font_style
        size = self.font_size_pt
        lw = self.line_width
        dc = self.draw_color
        fc = self.fill_color
        tc = self.text_color
        cf = self.color_flag
        stretching = self.font_stretching
        if self.page &gt; 0:
            # Page footer
            self.in_footer = 1
            self.footer()
            self.in_footer = 0
            # close page
            self._endpage()

        # Start new page
        self._beginpage(orientation, format, same)
        self._out(&#34;2 J&#34;)  # Set line cap style to square
        self.line_width = lw  # Set line width
        self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

        # Set font
        if family:
            self.set_font(family, style, size)

        # Set colors
        self.draw_color = dc
        if dc != &#34;0 G&#34;:
            self._out(dc)
        self.fill_color = fc
        if fc != &#34;0 g&#34;:
            self._out(fc)
        self.text_color = tc
        self.color_flag = cf

        # BEGIN Page header
        self.header()

        if self.line_width != lw:  # Restore line width
            self.line_width = lw
            self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

        if family:
            self.set_font(family, style, size)  # Restore font

        if self.draw_color != dc:  # Restore colors
            self.draw_color = dc
            self._out(dc)
        if self.fill_color != fc:
            self.fill_color = fc
            self._out(fc)
        self.text_color = tc
        self.color_flag = cf

        if stretching != 100:  # Restore stretching
            self.set_stretching(stretching)
        # END Page header

    def header(self):
        &#34;Header to be implemented in your own inherited class&#34;

    def footer(self):
        &#34;Footer to be implemented in your own inherited class&#34;

    def page_no(self):
        &#34;Get current page number&#34;
        return self.page

    def set_draw_color(self, r, g=-1, b=-1):
        &#34;Set color for all stroking operations&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.draw_color = sprintf(&#34;%.3f G&#34;, r / 255.0)
        else:
            self.draw_color = sprintf(
                &#34;%.3f %.3f %.3f RG&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        if self.page &gt; 0:
            self._out(self.draw_color)

    def set_fill_color(self, r, g=-1, b=-1):
        &#34;Set color for all filling operations&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.fill_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
        else:
            self.fill_color = sprintf(
                &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        self.color_flag = self.fill_color != self.text_color
        if self.page &gt; 0:
            self._out(self.fill_color)

    def set_text_color(self, r, g=-1, b=-1):
        &#34;Set color for text&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.text_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
        else:
            self.text_color = sprintf(
                &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        self.color_flag = self.fill_color != self.text_color

    def get_string_width(self, s, normalized=False):
        &#34;Get width of a string in the current font&#34;
        # normalized is parameter for internal use
        s = s if normalized else self.normalize_text(s)
        cw = self.current_font[&#34;cw&#34;]
        w = 0
        l = len(s)
        if self.unifontsubset:
            for char in s:
                char = ord(char)
                if len(cw) &gt; char:
                    w += cw[char]
                elif self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]:
                    w += self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]
                else:
                    w += 500
        else:
            for i in range(0, l):
                w += cw.get(s[i], 0)
        if self.font_stretching != 100:
            w = w * self.font_stretching / 100.0
        return w * self.font_size / 1000.0

    def set_line_width(self, width):
        &#34;Set line width&#34;
        self.line_width = width
        if self.page &gt; 0:
            self._out(sprintf(&#34;%.2f w&#34;, width * self.k))

    @check_page
    def line(self, x1, y1, x2, y2):
        &#34;Draw a line&#34;
        self._out(
            sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S&#34;,
                x1 * self.k,
                (self.h - y1) * self.k,
                x2 * self.k,
                (self.h - y2) * self.k,
            )
        )

    def _set_dash(self, dash_length=False, space_length=False):
        if dash_length and space_length:
            s = sprintf(&#34;[%.3f %.3f] 0 d&#34;, dash_length * self.k, space_length * self.k)
        else:
            s = &#34;[] 0 d&#34;
        self._out(s)

    @check_page
    def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
        &#34;&#34;&#34;Draw a dashed line. Same interface as line() except:
        - dash_length: Length of the dash
        - space_length: Length of the space between dashes&#34;&#34;&#34;
        self._set_dash(dash_length, space_length)
        self.line(x1, y1, x2, y2)
        self._set_dash()

    @check_page
    def rect(self, x, y, w, h, style=None):
        &#34;Draw a rectangle&#34;
        style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
        op = style_to_operators.get(style, &#34;S&#34;)
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f re %s&#34;,
                x * self.k,
                (self.h - y) * self.k,
                w * self.k,
                -h * self.k,
                op,
            )
        )

    @check_page
    def ellipse(self, x, y, w, h, style=None):
        &#34;Draw a ellipse&#34;
        style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
        op = style_to_operators.get(style, &#34;S&#34;)

        cx = x + w / 2.0
        cy = y + h / 2.0
        rx = w / 2.0
        ry = h / 2.0

        lx = 4.0 / 3.0 * (math.sqrt(2) - 1) * rx
        ly = 4.0 / 3.0 * (math.sqrt(2) - 1) * ry

        self._out(
            sprintf(
                &#34;%.2f %.2f m %.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx + rx) * self.k,
                (self.h - cy) * self.k,
                (cx + rx) * self.k,
                (self.h - (cy - ly)) * self.k,
                (cx + lx) * self.k,
                (self.h - (cy - ry)) * self.k,
                cx * self.k,
                (self.h - (cy - ry)) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx - lx) * self.k,
                (self.h - (cy - ry)) * self.k,
                (cx - rx) * self.k,
                (self.h - (cy - ly)) * self.k,
                (cx - rx) * self.k,
                (self.h - cy) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx - rx) * self.k,
                (self.h - (cy + ly)) * self.k,
                (cx - lx) * self.k,
                (self.h - (cy + ry)) * self.k,
                cx * self.k,
                (self.h - (cy + ry)) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c %s&#34;,
                (cx + lx) * self.k,
                (self.h - (cy + ry)) * self.k,
                (cx + rx) * self.k,
                (self.h - (cy + ly)) * self.k,
                (cx + rx) * self.k,
                (self.h - cy) * self.k,
                op,
            )
        )

    def add_font(self, family, style=&#34;&#34;, fname=None, uni=False):
        &#34;Add a TrueType or Type1 font&#34;
        if not fname:
            fname = family.replace(&#34; &#34;, &#34;&#34;) + style.lower() + &#34;.pkl&#34;

        if family.lower() == &#34;arial&#34;:
            warnings.warn(&#34;Substitutting Arial by core font Helvetica&#34;)
            family = &#34;helvetica&#34;
        style = style.upper()
        if style == &#34;IB&#34;:
            style = &#34;BI&#34;
        fontkey = family + style

        # Font already added!
        if fontkey in self.fonts:
            return
        if uni:
            if os.path.exists(fname):
                ttffilename = fname
            elif FPDF_FONT_DIR and os.path.exists(os.path.join(FPDF_FONT_DIR, fname)):
                ttffilename = os.path.join(FPDF_FONT_DIR, fname)
            elif SYSTEM_TTFONTS and os.path.exists(os.path.join(SYSTEM_TTFONTS, fname)):
                ttffilename = os.path.join(SYSTEM_TTFONTS, fname)
            else:
                raise RuntimeError(&#34;TTF Font file not found: %s&#34; % fname)
            if FPDF_CACHE_MODE == 0:
                unifilename = os.path.splitext(ttffilename)[0] + &#34;.pkl&#34;
            elif FPDF_CACHE_MODE == 2:
                unifilename = os.path.join(
                    FPDF_CACHE_DIR, _hashpath(ttffilename) + &#34;.pkl&#34;
                )
            else:
                unifilename = None

            font_dict = load_cache(unifilename)
            if font_dict is None:
                ttf = TTFontFile()
                ttf.getMetrics(ttffilename)
                desc = {
                    &#34;Ascent&#34;: int(round(ttf.ascent, 0)),
                    &#34;Descent&#34;: int(round(ttf.descent, 0)),
                    &#34;CapHeight&#34;: int(round(ttf.capHeight, 0)),
                    &#34;Flags&#34;: ttf.flags,
                    &#34;FontBBox&#34;: &#34;[%s %s %s %s]&#34;
                    % (
                        int(round(ttf.bbox[0], 0)),
                        int(round(ttf.bbox[1], 0)),
                        int(round(ttf.bbox[2], 0)),
                        int(round(ttf.bbox[3], 0)),
                    ),
                    &#34;ItalicAngle&#34;: int(ttf.italicAngle),
                    &#34;StemV&#34;: int(round(ttf.stemV, 0)),
                    &#34;MissingWidth&#34;: int(round(ttf.defaultWidth, 0)),
                }

                # Generate metrics .pkl file
                font_dict = {
                    &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
                    &#34;type&#34;: &#34;TTF&#34;,
                    &#34;desc&#34;: desc,
                    &#34;up&#34;: round(ttf.underlinePosition),
                    &#34;ut&#34;: round(ttf.underlineThickness),
                    &#34;ttffile&#34;: ttffilename,
                    &#34;fontkey&#34;: fontkey,
                    &#34;originalsize&#34;: os.stat(ttffilename).st_size,
                    &#34;cw&#34;: ttf.charWidths,
                }

                if unifilename:
                    try:
                        with open(unifilename, &#34;wb&#34;) as fh:
                            pickle.dump(font_dict, fh)
                    except IOError as e:
                        if e.errno != errno.EACCES:
                            raise  # Not a permission error.
                del ttf

            # include numbers in the subset! (if alias present)
            have_page_alias = lambda: hasattr(self, &#34;str_alias_nb_pages&#34;)
            sbarr = list(range(0, 57 if have_page_alias() else 32))

            self.fonts[fontkey] = {
                &#34;i&#34;: len(self.fonts) + 1,
                &#34;type&#34;: font_dict[&#34;type&#34;],
                &#34;name&#34;: font_dict[&#34;name&#34;],
                &#34;desc&#34;: font_dict[&#34;desc&#34;],
                &#34;up&#34;: font_dict[&#34;up&#34;],
                &#34;ut&#34;: font_dict[&#34;ut&#34;],
                &#34;cw&#34;: font_dict[&#34;cw&#34;],
                &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
                &#34;fontkey&#34;: fontkey,
                &#34;subset&#34;: sbarr,
                &#34;unifilename&#34;: unifilename,
            }
            self.font_files[fontkey] = {
                &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;ttffile&#34;: ttffilename,
            }
            self.font_files[fname] = {&#34;type&#34;: &#34;TTF&#34;}
        else:
            with open(fname, &#34;rb&#34;) as fontfile:
                font_dict = pickle.load(fontfile)
            self.fonts[fontkey] = {&#34;i&#34;: len(self.fonts) + 1}
            self.fonts[fontkey].update(font_dict)
            diff = font_dict.get(&#34;diff&#34;)
            if diff:
                # Search existing encodings
                d = 0
                nb = len(self.diffs)
                for i in range(1, nb + 1):
                    if self.diffs[i] == diff:
                        d = i
                        break
                if d == 0:
                    d = nb + 1
                    self.diffs[d] = diff
                self.fonts[fontkey][&#34;diff&#34;] = d
            filename = font_dict.get(&#34;filename&#34;)
            if filename:
                if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                    originalsize = font_dict[&#34;originalsize&#34;]
                    self.font_files[filename] = {&#34;length1&#34;: originalsize}
                else:
                    self.font_files[filename] = {
                        &#34;length1&#34;: font_dict[&#34;size1&#34;],
                        &#34;length2&#34;: font_dict[&#34;size2&#34;],
                    }

    def set_font(self, family, style=&#34;&#34;, size=0):
        &#34;Select a font; size given in points&#34;
        if family == &#34;&#34;:
            family = self.font_family
        if family.lower() == &#34;arial&#34;:
            warnings.warn(&#34;Substitutting Arial by core font Helvetica&#34;)
            family = &#34;helvetica&#34;
        elif family in (&#34;symbol&#34;, &#34;zapfdingbats&#34;):
            style = &#34;&#34;
        style = style.upper()
        if &#34;U&#34; in style:
            self.underline = 1
            style = style.replace(&#34;U&#34;, &#34;&#34;)
        else:
            self.underline = 0
        if style == &#34;IB&#34;:
            style = &#34;BI&#34;
        if size == 0:
            size = self.font_size_pt

        # Test if font is already selected
        if (
            self.font_family == family
            and self.font_style == style
            and self.font_size_pt == size
        ):
            return

        # Test if used for the first time
        fontkey = family + style
        if fontkey not in self.fonts:
            if fontkey not in self.core_fonts or fontkey not in fpdf_charwidths:
                raise FPDFException(&#34;Undefined font: &#34; + fontkey)
            i = len(self.fonts) + 1
            self.fonts[fontkey] = {
                &#34;i&#34;: i,
                &#34;type&#34;: &#34;core&#34;,
                &#34;name&#34;: self.core_fonts[fontkey],
                &#34;up&#34;: -100,
                &#34;ut&#34;: 50,
                &#34;cw&#34;: fpdf_charwidths[fontkey],
            }

        # Select it
        self.font_family = family
        self.font_style = style
        self.font_size_pt = size
        self.font_size = size / self.k
        self.current_font = self.fonts[fontkey]
        self.unifontsubset = self.current_font[&#34;type&#34;] == &#34;TTF&#34;
        if self.page &gt; 0:
            self._out(
                sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
            )

    def set_font_size(self, size):
        &#34;Set font size in points&#34;
        if self.font_size_pt == size:
            return
        self.font_size_pt = size
        self.font_size = size / self.k
        if self.page &gt; 0:
            self._out(
                sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
            )

    def set_stretching(self, factor):
        &#34;Set from stretch factor percents (default: 100.0)&#34;
        if self.font_stretching == factor:
            return
        self.font_stretching = factor
        if self.page &gt; 0:
            self._out(sprintf(&#34;BT %.2f Tz ET&#34;, self.font_stretching))

    def add_link(self):
        &#34;Create a new internal link&#34;
        n = len(self.links) + 1
        self.links[n] = (0, 0)
        return n

    def set_link(self, link, y=0, page=-1):
        &#34;Set destination of internal link&#34;
        if y == -1:
            y = self.y
        if page == -1:
            page = self.page

        self.links[link] = [page, y]

    def link(self, x, y, w, h, link, alt_text=&#34;&#34;):
        &#34;Put a link on the page&#34;
        if self.page not in self.page_links:
            self.page_links[self.page] = []
        self.page_links[self.page] += [
            (x * self.k, self.h_pt - y * self.k, w * self.k, h * self.k, link, alt_text)
        ]

    @check_page
    def text(self, x, y, txt=&#34;&#34;):
        &#34;Output a string&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        txt = self.normalize_text(txt)
        if self.unifontsubset:
            txt2 = escape_parens(txt).encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;)
            for char in txt:
                self.current_font[&#34;subset&#34;].append(ord(char))
        else:
            txt2 = escape_parens(txt)
        s = sprintf(
            &#34;BT %.2f %.2f Td (%s) Tj ET&#34;, x * self.k, (self.h - y) * self.k, txt2
        )
        if self.underline and txt != &#34;&#34;:
            s += &#34; &#34; + self._dounderline(x, y, txt)
        if self.color_flag:
            s = &#34;q &#34; + self.text_color + &#34; &#34; + s + &#34; Q&#34;
        self._out(s)

    @check_page
    def rotate(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        .. deprecated:: 2.1.0
          Use `rotation` instead.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;rotate() can produces malformed PDFs and is deprecated. Use the rotation() context manager instead.&#34;,
            PendingDeprecationWarning,
        )
        if x is None:
            x = self.x
        if y is None:
            y = self.y

        if self.angle != 0:
            self._out(&#34;Q&#34;)
        self.angle = angle
        if angle != 0:
            angle *= math.pi / 180
            c = math.cos(angle)
            s = math.sin(angle)
            cx = x * self.k
            cy = (self.h - y) * self.k
            s = sprintf(
                &#34;q %.5F %.5F %.5F %.5F %.2F %.2F &#34; + &#34;cm 1 0 0 1 %.2F %.2F cm&#34;,
                c,
                s,
                -s,
                c,
                cx,
                cy,
                -cx,
                -cy,
            )
            self._out(s)

    @check_page
    @contextmanager
    def rotation(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        This method allows to perform a rotation around a given center.

        The rotation affects all elements which are printed inside the indented context
        (with the exception of clickable areas).

        Notes
        -----

        Only the rendering is altered. The `get_x()` and `get_y()` methods are not affected,
        nor the automatic page break mechanism.
        &#34;&#34;&#34;
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        angle *= math.pi / 180
        c, s = math.cos(angle), math.sin(angle)
        cx, cy = x * self.k, (self.h - y) * self.k
        self._out(
            sprintf(
                &#34;q %.5F %.5F %.5F %.5F %.2F %.2F cm 1 0 0 1 %.2F %.2F cm\n&#34;,
                c,
                s,
                -s,
                c,
                cx,
                cy,
                -cx,
                -cy,
            )
        )
        yield
        self._out(&#34;Q\n&#34;)

    @property
    def accept_page_break(self):
        &#34;Accept automatic page break or not&#34;
        return self.auto_page_break

    @check_page
    def cell(self, w, h=0, txt=&#34;&#34;, border=0, ln=0, align=&#34;&#34;, fill=0, link=&#34;&#34;):
        &#34;Output a cell, return boolean if triggered auto page break&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                &#39;Integer values for &#34;border&#34; parameter other than 1 are currently ignored&#39;
            )
            border = 1
        page_break_triggered = False
        txt = self.normalize_text(txt)
        k = self.k
        if (
            self.y + h &gt; self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        ):

            # Automatic page break
            page_break_triggered = True
            x = self.x
            ws = self.ws
            if ws &gt; 0:
                self.ws = 0
                self._out(&#34;0 Tw&#34;)
            self.add_page(same=True)
            self.x = x  # restore x but not y after drawing header

            if ws &gt; 0:
                self.ws = ws
                self._out(sprintf(&#34;%.3f Tw&#34;, ws * k))
        if w == 0:
            w = self.w - self.r_margin - self.x
        s = &#34;&#34;

        if fill == 1 or border == 1:
            if fill == 1:
                if border == 1:
                    op = &#34;B&#34;
                else:
                    op = &#34;f&#34;
            else:
                op = &#34;S&#34;
            s = sprintf(
                &#34;%.2f %.2f %.2f %.2f re %s &#34;,
                self.x * k,
                (self.h - self.y) * k,
                w * k,
                -h * k,
                op,
            )

        if isinstance(border, str):
            x = self.x
            y = self.y
            if &#34;L&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - y) * k,
                    x * k,
                    (self.h - (y + h)) * k,
                )
            if &#34;T&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - y) * k,
                    (x + w) * k,
                    (self.h - y) * k,
                )
            if &#34;R&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    (x + w) * k,
                    (self.h - y) * k,
                    (x + w) * k,
                    (self.h - (y + h)) * k,
                )
            if &#34;B&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - (y + h)) * k,
                    (x + w) * k,
                    (self.h - (y + h)) * k,
                )

        if txt != &#34;&#34;:
            if align == &#34;R&#34;:
                dx = w - self.c_margin - self.get_string_width(txt, True)
            elif align == &#34;C&#34;:
                dx = (w - self.get_string_width(txt, True)) / 2.0
            else:
                dx = self.c_margin
            if self.color_flag:
                s += &#34;q &#34; + self.text_color + &#34; &#34;

            # If multibyte, Tw has no effect - do word spacing using an
            # adjustment before each space
            if self.ws and self.unifontsubset:
                for char in txt:
                    self.current_font[&#34;subset&#34;].append(ord(char))
                space = escape_parens(&#34; &#34;.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))

                s += sprintf(
                    &#34;BT 0 Tw %.2F %.2F Td [&#34;,
                    (self.x + dx) * k,
                    (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
                )

                t = txt.split(&#34; &#34;)
                numt = len(t)
                for i in range(numt):
                    tx = t[i]
                    tx = enclose_in_parens(
                        escape_parens(tx.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                    )
                    s += sprintf(&#34;%s &#34;, tx)
                    if (i + 1) &lt; numt:
                        adj = -(self.ws * self.k) * 1000 / self.font_size_pt
                        s += sprintf(&#34;%d(%s) &#34;, adj, space)
                s += &#34;] TJ&#34;
                s += &#34; ET&#34;
            else:
                if self.unifontsubset:
                    txt2 = escape_parens(txt.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                    for char in txt:
                        self.current_font[&#34;subset&#34;].append(ord(char))
                else:
                    txt2 = escape_parens(txt)

                s += sprintf(
                    &#34;BT %.2f %.2f Td (%s) Tj ET&#34;,
                    (self.x + dx) * k,
                    (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
                    txt2,
                )

            if self.underline:
                s += &#34; &#34; + self._dounderline(
                    self.x + dx, self.y + (0.5 * h) + (0.3 * self.font_size), txt
                )
            if self.color_flag:
                s += &#34; Q&#34;
            if link:
                self.link(
                    self.x + dx,
                    self.y + (0.5 * h) - (0.5 * self.font_size),
                    self.get_string_width(txt, True),
                    self.font_size,
                    link,
                )
        if s:
            self._out(s)
        self.lasth = h

        if ln &gt; 0:
            self.y += h  # Go to next line
            if ln == 1:
                self.x = self.l_margin
        else:
            self.x += w

        return page_break_triggered

    @check_page
    def multi_cell(
        self, w, h, txt=&#34;&#34;, border=0, align=&#34;J&#34;, fill=0, split_only=False, link=&#34;&#34;, ln=0
    ):
        &#34;&#34;&#34;
        Output text with automatic or explicit line breaks,
        returns boolean if page break triggered in output mode.

        Args:
            ln (int): controls cell positioning:

              - 0: stack cells horizontally, with respect to `.x` &amp; `.y`
              - 1: one cell per line, aligned on the left with respect to `.l_margin`
              - 2: one cell per line
        &#34;&#34;&#34;
        page_break_triggered = False
        if split_only:
            _out, _add_page = self._out, self.add_page
            self._out = lambda *args, **kwargs: None
            self.add_page = lambda *args, **kwargs: None

        # Store this information for manipulating position.
        location = (self.get_x(), self.get_y())

        # If width is 0, set width to available width between margins
        if w == 0:
            w = self.w - self.r_margin - self.x
        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size

        # Calculate text length
        txt = self.normalize_text(txt)
        s = txt.replace(&#34;\r&#34;, &#34;&#34;)
        normalized_string_length = len(s)
        if normalized_string_length &gt; 0 and s[-1] == &#34;\n&#34;:
            normalized_string_length -= 1

        b = 0
        if border:
            if border == 1:
                border = &#34;LTRB&#34;
                b = &#34;LRT&#34;
                b2 = &#34;LR&#34;
            else:
                b2 = &#34;&#34;
                if &#34;L&#34; in border:
                    b2 += &#34;L&#34;
                if &#34;R&#34; in border:
                    b2 += &#34;R&#34;
                if &#34;T&#34; in border:
                    b = b2 + &#34;T&#34;
                else:
                    b = b2

        character_widths = self.current_font[&#34;cw&#34;]
        text_cells = []
        sep = -1
        i = 0
        j = 0
        l = 0
        ns = 0
        nl = 1
        while i &lt; normalized_string_length:
            # Get next character
            c = s[i]

            # Explicit line break
            if c == &#34;\n&#34;:
                if self.ws &gt; 0:
                    self.ws = 0
                    self._out(&#34;0 Tw&#34;)

                new_page = self.cell(
                    w,
                    h=h,
                    txt=substr(s, j, i - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, i - j))

                i += 1
                sep = -1
                j = i
                l = 0
                ns = 0
                nl += 1
                if border and nl == 2:
                    b = b2
                continue

            if c == &#34; &#34;:
                sep = i
                ls = l
                ns += 1
            if self.unifontsubset:
                l += self.get_string_width(c, True) / self.font_size * 1000.0
            else:
                l += character_widths.get(c, 0)

            # Automatic line break
            if l &gt; wmax:
                if sep == -1:
                    if i == j:
                        i += 1
                    if self.ws &gt; 0:
                        self.ws = 0
                        self._out(&#34;0 Tw&#34;)

                    new_page = self.cell(
                        w,
                        h=h,
                        txt=substr(s, j, i - j),
                        border=b,
                        ln=2,
                        align=align,
                        fill=fill,
                        link=link,
                    )
                    page_break_triggered = page_break_triggered or new_page
                    text_cells.append(substr(s, j, i - j))

                else:
                    if align == &#34;J&#34;:
                        if ns &gt; 1:
                            self.ws = (wmax - ls) / 1000.0 * self.font_size / (ns - 1)
                        else:
                            self.ws = 0
                        self._out(sprintf(&#34;%.3f Tw&#34;, self.ws * self.k))

                    new_page = self.cell(
                        w,
                        h=h,
                        txt=substr(s, j, sep - j),
                        border=b,
                        ln=2,
                        align=align,
                        fill=fill,
                        link=link,
                    )
                    page_break_triggered = page_break_triggered or new_page
                    text_cells.append(substr(s, j, sep - j))

                    i = sep + 1
                sep = -1
                j = i
                l = 0
                ns = 0
                nl += 1
                if border and nl == 2:
                    b = b2
            else:
                i += 1

        # Last chunk
        if self.ws &gt; 0:
            self.ws = 0
            self._out(&#34;0 Tw&#34;)
        if border and &#34;B&#34; in border:
            b += &#34;B&#34;

        new_page = self.cell(
            w,
            h=h,
            txt=substr(s, j, i - j),
            border=b,
            ln=2,
            align=align,
            fill=fill,
            link=link,
        )
        page_break_triggered = page_break_triggered or new_page
        text_cells.append(substr(s, j, i - j))

        location_options = {
            0: lambda: self.set_xy(self.x + w, self.y),
            1: lambda: self.set_x(self.l_margin),  # could control y
            2: lambda: None,
        }
        location_options.get(ln, lambda: None)()

        if split_only:
            # restore writing functions
            self._out, self.add_page = _out, _add_page
            self.set_xy(*location)  # restore location
            return text_cells

        return page_break_triggered

    @check_page
    def write(self, h, txt=&#34;&#34;, link=&#34;&#34;):
        &#34;Output text in flowing mode&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        txt = self.normalize_text(txt)
        cw = self.current_font[&#34;cw&#34;]
        w = self.w - self.r_margin - self.x
        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
        s = txt.replace(&#34;\r&#34;, &#34;&#34;)
        nb = len(s)
        sep = -1
        i = 0
        j = 0
        l = 0
        nl = 1
        while i &lt; nb:
            # Get next character
            c = s[i]
            if c == &#34;\n&#34;:
                # Explicit line break
                self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
                i += 1
                sep = -1
                j = i
                l = 0
                if nl == 1:
                    self.x = self.l_margin
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                nl += 1
                continue
            if c == &#34; &#34;:
                sep = i
            if self.unifontsubset:
                l += self.get_string_width(c, True) / self.font_size * 1000.0
            else:
                l += cw.get(c, 0)
            if l &gt; wmax:
                # Automatic line break
                if sep == -1:
                    if self.x &gt; self.l_margin:
                        # Move to next line
                        self.x = self.l_margin
                        self.y += h
                        w = self.w - self.r_margin - self.x
                        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                        i += 1
                        nl += 1
                        continue
                    if i == j:
                        i += 1
                    self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
                else:
                    self.cell(w, h, substr(s, j, sep - j), 0, 2, &#34;&#34;, 0, link)
                    i = sep + 1
                sep = -1
                j = i
                l = 0
                if nl == 1:
                    self.x = self.l_margin
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                nl += 1
            else:
                i += 1
        # Last chunk
        if i != j:
            self.cell(l / 1000.0 * self.font_size, h, substr(s, j), 0, 0, &#34;&#34;, 0, link)

    @check_page
    def image(
        self,
        name,
        x=None,
        y=None,
        w=0,
        h=0,
        type=&#34;&#34;,
        link=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Put an image on the page

        Args:
            name: either a string representing a file path to an image, or a instance of `PIL.Image.Image`
            x (int): optional horizontal position where to put the image on the page
            y (int): optional vertical position where to put the image on the page
            w (int): optional width of the image
            h (int): optional height of the image
            type (str): [**DEPRECATED**] unused, will be removed in a later version
            link (str): optional link, internal or external, to add on the image
        &#34;&#34;&#34;
        if type:
            warnings.warn(
                &#39;&#34;type&#34; is unused and will soon be deprecated&#39;,
                PendingDeprecationWarning,
            )
        if isinstance(name, str):
            img = load_resource(name)
        else:
            name, img = uuid4(), name
        if name not in self.images:
            info = get_img_info(img)
            info[&#34;i&#34;] = len(self.images) + 1
            self.images[name] = info
        else:
            info = self.images[name]

        # Automatic width and height calculation if needed
        if w == 0 and h == 0:
            # Put image at 72 dpi
            w = info[&#34;w&#34;] / self.k
            h = info[&#34;h&#34;] / self.k
        elif w == 0:
            w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
        elif h == 0:
            h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

        # Flowing mode
        if y is None:
            if (
                self.y + h &gt; self.page_break_trigger
                and not self.in_footer
                and self.accept_page_break
            ):
                # Automatic page break
                x = self.x
                self.add_page(same=True)
                self.x = x
            y = self.y
            self.y += h

        if x is None:
            x = self.x
        self._out(
            sprintf(
                &#34;q %.2f 0 0 %.2f %.2f %.2f cm /I%d Do Q&#34;,
                w * self.k,
                h * self.k,
                x * self.k,
                (self.h - (y + h)) * self.k,
                info[&#34;i&#34;],
            )
        )
        if link:
            self.link(x, y, w, h, link)

        return info

    @check_page
    def ln(self, h=None):
        &#34;Line Feed; default value is last cell height&#34;
        self.x = self.l_margin
        if h is None:
            self.y += self.lasth
        else:
            self.y += h

    def get_x(self):
        &#34;Get x position&#34;
        return self.x

    def set_x(self, x):
        &#34;Set x position&#34;
        if x &gt;= 0:
            self.x = x
        else:
            self.x = self.w + x

    def get_y(self):
        &#34;Get y position&#34;
        return self.y

    def set_y(self, y):
        &#34;Set y position and reset x&#34;
        self.x = self.l_margin
        if y &gt;= 0:
            self.y = y
        else:
            self.y = self.h + y

    def set_xy(self, x, y):
        &#34;Set x and y positions&#34;
        self.set_y(y)
        self.set_x(x)

    def output(self, name=&#34;&#34;, dest=&#34;&#34;):
        &#34;&#34;&#34;Output PDF to some destination

        By default the PDF is written to sys.stdout. If a name is given, the
        PDF is written to a new file. If dest=&#39;S&#39; is given, the PDF data is
        returned as a byte string.&#34;&#34;&#34;
        # pylint: disable=inconsistent-return-statements
        # Finish document if necessary
        if self.state &lt; 3:
            self.close()
        dest = dest.upper()
        if dest == &#34;&#34;:
            dest = &#34;I&#34; if name == &#34;&#34; else &#34;F&#34;
        if dest in (&#34;I&#34;, &#34;D&#34;):
            # Python &lt; 3 writes byte data transparently without &#34;buffer&#34;
            stdout = getattr(sys.stdout, &#34;buffer&#34;, sys.stdout)
            stdout.write(self.buffer)
            return None
        if dest == &#34;F&#34;:
            # Save to local file
            with open(name, &#34;wb&#34;) as f:
                f.write(self.buffer)
            return None
        # Return as a byte string
        if dest == &#34;S&#34;:
            return self.buffer
        raise FPDFException(&#34;Incorrect output destination: &#34; + dest)

    def normalize_text(self, txt):
        &#34;Check that text input is in the correct format/encoding&#34;
        # - for TTF unicode fonts: unicode object (utf8 encoding)
        # - for built-in fonts: string instances (encoding: latin-1, cp1252)
        if not self.unifontsubset and self.core_fonts_encoding:
            return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
        return txt

    def _putpages(self):
        nb = self.page
        if hasattr(self, &#34;str_alias_nb_pages&#34;):
            # Replace number of pages in fonts using subsets (unicode)
            alias = self.str_alias_nb_pages.encode(&#34;UTF-16BE&#34;)
            r = str(nb).encode(&#34;UTF-16BE&#34;)
            for n in range(1, nb + 1):
                self.pages[n][&#34;content&#34;] = self.pages[n][&#34;content&#34;].replace(alias, r)
            # Now repeat for no pages in non-subset fonts
            for n in range(1, nb + 1):
                self.pages[n][&#34;content&#34;].replace(
                    self.str_alias_nb_pages.encode(&#34;latin-1&#34;), str(nb).encode(&#34;latin-1&#34;)
                )
        if self.def_orientation == &#34;P&#34;:
            dw_pt = self.dw_pt
            dh_pt = self.dh_pt
        else:
            dw_pt = self.dh_pt
            dh_pt = self.dw_pt
        if self.compress:
            filter = &#34;/Filter /FlateDecode &#34;
        else:
            filter = &#34;&#34;
        for n in range(1, nb + 1):
            # page object from pages[n]
            # page object from pages[n]#w_pt
            # page object from pages[n]#h_pt
            # page object from page_links[n] if page_links and page_links[n]
            # Page
            self._newobj()
            self._out(&#34;&lt;&lt;/Type /Page&#34;)
            self._out(&#34;/Parent 1 0 R&#34;)
            w_pt = self.pages[n][&#34;w_pt&#34;]
            h_pt = self.pages[n][&#34;h_pt&#34;]
            if w_pt != dw_pt or h_pt != dh_pt:
                self._out(sprintf(&#34;/MediaBox [0 0 %.2f %.2f]&#34;, w_pt, h_pt))
            self._out(&#34;/Resources 2 0 R&#34;)

            if self.page_links and n in self.page_links:
                # Links
                annots = &#34;/Annots [&#34;
                for pl in self.page_links[n]:
                    # first four things in &#39;link&#39; list are coordinates?
                    rect = sprintf(
                        &#34;%.2f %.2f %.2f %.2f&#34;,
                        pl[0],
                        pl[1],
                        pl[0] + pl[2],
                        pl[1] - pl[3],
                    )

                    # start the annotation entry
                    annots += (
                        &#34;&lt;&lt;/Type /Annot /Subtype /Link /Rect [&#34;
                        + rect
                        + &#34;] /Border [0 0 0] &#34;
                    )

                    # HTML ending of annotation entry
                    if isinstance(pl[4], str):
                        annots += (
                            &#34;/A &lt;&lt;/S /URI /URI &#34; + enclose_in_parens(pl[4]) + &#34;&gt;&gt;&gt;&gt;&#34;
                        )

                    # Dest type ending of annotation entry
                    else:
                        assert (
                            pl[4] in self.links
                        ), &#34;Page {} has a link with an invalid index: {} (doc #links={})&#34;.format(
                            n, pl[4], len(self.links)
                        )
                        l = self.links[pl[4]]
                        # if l[0] in self.orientation_changes: h = w_pt
                        # else:                                h = h_pt
                        annots += sprintf(
                            &#34;/Dest [%d 0 R /XYZ 0 %.2f null]&gt;&gt;&#34;,
                            1 + 2 * l[0],
                            h_pt - l[1] * self.k,
                        )

                # End links list
                self._out(annots + &#34;]&#34;)
            if self.pdf_version &gt; &#34;1.3&#34;:
                self._out(&#34;/Group &lt;&lt;/Type /Group /S /Transparency&#34; &#34;/CS /DeviceRGB&gt;&gt;&#34;)
            self._out(&#34;/Contents &#34; + str(self.n + 1) + &#34; 0 R&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

            # Page content
            content = self.pages[n][&#34;content&#34;]
            if self.compress:
                p = zlib.compress(content)
            else:
                p = content
            self._newobj()
            self._out(&#34;&lt;&lt;&#34; + filter + &#34;/Length &#34; + str(len(p)) + &#34;&gt;&gt;&#34;)
            self._out(pdf_stream(p))
            self._out(&#34;endobj&#34;)
        # Pages root
        self.offsets[1] = len(self.buffer)
        self._out(&#34;1 0 obj&#34;)
        self._out(&#34;&lt;&lt;/Type /Pages&#34;)
        kids = &#34;/Kids [&#34;
        for i in range(0, nb):
            kids += str(3 + 2 * i) + &#34; 0 R &#34;
        self._out(kids + &#34;]&#34;)
        self._out(&#34;/Count &#34; + str(nb))
        self._out(sprintf(&#34;/MediaBox [0 0 %.2f %.2f]&#34;, dw_pt, dh_pt))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _putfonts(self):
        nf = self.n
        for diff in self.diffs:
            # Encodings
            self._newobj()
            self._out(
                (
                    &#34;&lt;&lt;/Type /Encoding /BaseEncoding /WinAnsiEncoding &#34;
                    + &#34;/Differences [&#34;
                    + self.diffs[diff]
                    + &#34;]&gt;&gt;&#34;
                )
            )
            self._out(&#34;endobj&#34;)

        for name, info in self.font_files.items():
            if &#34;type&#34; in info and info[&#34;type&#34;] != &#34;TTF&#34;:
                # Font file embedding
                self._newobj()
                self.font_files[name][&#34;n&#34;] = self.n
                with open(os.path.join(FPDF_FONT_DIR, name), &#34;rb&#34;, 1) as f:
                    font = f.read()
                compressed = substr(name, -2) == &#34;.z&#34;
                if not compressed and &#34;length2&#34; in info:
                    header = ord(font[0]) == 128
                    if header:
                        # Strip first binary header
                        font = substr(font, 6)
                    if header and ord(font[info[&#34;length1&#34;]]) == 128:
                        # Strip second binary header
                        font = substr(font, 0, info[&#34;length1&#34;]) + substr(
                            font, info[&#34;length1&#34;] + 6
                        )

                self._out(&#34;&lt;&lt;/Length &#34; + str(len(font)))
                if compressed:
                    self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;/Length1 &#34; + str(info[&#34;length1&#34;]))
                if &#34;length2&#34; in info:
                    self._out(
                        &#34;/Length2 &#34; + str(info[&#34;length2&#34;]) + &#34; /Length3 0&#34;
                    )  # noqa: E501
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(font))
                self._out(&#34;endobj&#34;)

        # Font objects
        flist = [(x[1][&#34;i&#34;], x[0], x[1]) for x in self.fonts.items()]
        flist.sort()
        for _, font_name, font in flist:
            self.fonts[font_name][&#34;n&#34;] = self.n + 1
            my_type = font[&#34;type&#34;]
            name = font[&#34;name&#34;]
            # Standard font
            if my_type == &#34;core&#34;:
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/BaseFont /&#34; + name)
                self._out(&#34;/Subtype /Type1&#34;)
                if name not in (&#34;Symbol&#34;, &#34;ZapfDingbats&#34;):
                    self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

            # Additional Type1 or TrueType font
            elif my_type in (&#34;Type1&#34;, &#34;TrueType&#34;):
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/BaseFont /&#34; + name)
                self._out(&#34;/Subtype /&#34; + my_type)
                self._out(&#34;/FirstChar 32 /LastChar 255&#34;)
                self._out(&#34;/Widths &#34; + str(self.n + 1) + &#34; 0 R&#34;)
                self._out(&#34;/FontDescriptor &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                if font[&#34;enc&#34;]:
                    if &#34;diff&#34; in font:
                        self._out(
                            &#34;/Encoding &#34; + str(nf + font[&#34;diff&#34;]) + &#34; 0 R&#34;
                        )  # noqa: E501
                    else:
                        self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Widths
                self._newobj()
                cw = font[&#34;cw&#34;]
                s = &#34;[&#34;
                for i in range(32, 256):
                    # Get doesn&#39;t raise exception;
                    # returns 0 instead of None if not set
                    s += str(cw.get(chr(i), 0)) + &#34; &#34;
                self._out(s + &#34;]&#34;)
                self._out(&#34;endobj&#34;)

                # Descriptor
                self._newobj()
                s = &#34;&lt;&lt;/Type /FontDescriptor /FontName /&#34; + name
                for k in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    s += &#34; /%s %s&#34; % (k, font[&#34;desc&#34;][k])

                filename = font[&#34;file&#34;]
                if filename:
                    s += &#34; /FontFile&#34;
                    if my_type != &#34;Type1&#34;:
                        s += &#34;2&#34;
                    s += &#34; &#34; + str(self.font_files[filename][&#34;n&#34;]) + &#34; 0 R&#34;
                self._out(s + &#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)
            elif my_type == &#34;TTF&#34;:
                self.fonts[font_name][&#34;n&#34;] = self.n + 1
                ttf = TTFontFile()
                fontname = &#34;MPDFAA&#34; + &#34;+&#34; + font[&#34;name&#34;]
                subset = font[&#34;subset&#34;]
                del subset[0]
                ttfontstream = ttf.makeSubset(font[&#34;ttffile&#34;], subset)
                ttfontsize = len(ttfontstream)
                fontstream = zlib.compress(ttfontstream)
                codeToGlyph = ttf.codeToGlyph
                # del codeToGlyph[0]

                # Type0 Font
                # A composite font - a font composed of other fonts,
                # organized hierarchically
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /Type0&#34;)
                self._out(&#34;/BaseFont /&#34; + fontname + &#34;&#34;)
                self._out(&#34;/Encoding /Identity-H&#34;)
                self._out(&#34;/DescendantFonts [&#34; + str(self.n + 1) + &#34; 0 R&#34; + &#34;]&#34;)
                self._out(&#34;/ToUnicode &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # CIDFontType2
                # A CIDFont whose glyph descriptions are based on
                # TrueType font technology
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /CIDFontType2&#34;)
                self._out(&#34;/BaseFont /&#34; + fontname + &#34;&#34;)
                self._out(&#34;/CIDSystemInfo &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;/FontDescriptor &#34; + str(self.n + 3) + &#34; 0 R&#34;)
                if font[&#34;desc&#34;].get(&#34;MissingWidth&#34;):
                    self._out(&#34;/DW %d&#34; % font[&#34;desc&#34;][&#34;MissingWidth&#34;])
                self._putTTfontwidths(font, ttf.maxUni)
                self._out(&#34;/CIDToGIDMap &#34; + str(self.n + 4) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # ToUnicode
                self._newobj()
                toUni = (
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    &#34;1 beginbfrange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt; &lt;0000&gt;\n&#34;
                    &#34;endbfrange\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(toUni)) + &#34;&gt;&gt;&#34;)
                self._out(pdf_stream(toUni))
                self._out(&#34;endobj&#34;)

                # CIDSystemInfo dictionary
                self._newobj()
                self._out(&#34;&lt;&lt;/Registry (Adobe)&#34;)
                self._out(&#34;/Ordering (UCS)&#34;)
                self._out(&#34;/Supplement 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Font descriptor
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /FontDescriptor&#34;)
                self._out(&#34;/FontName /&#34; + fontname)
                for kd in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    v = font[&#34;desc&#34;][kd]
                    if kd == &#34;Flags&#34;:
                        v = v | 4
                        v = v &amp; ~32  # SYMBOLIC font flag
                    self._out(&#34; /%s %s&#34; % (kd, v))
                self._out(&#34;/FontFile2 &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Embed CIDToGIDMap
                # A specification of the mapping from CIDs to glyph indices
                cidtogidmap = &#34;&#34;
                cidtogidmap = [&#34;\x00&#34;] * 256 * 256 * 2
                for cc, glyph in codeToGlyph.items():
                    cidtogidmap[cc * 2] = chr(glyph &gt;&gt; 8)
                    cidtogidmap[cc * 2 + 1] = chr(glyph &amp; 0xFF)
                cidtogidmap = &#34;&#34;.join(cidtogidmap)
                # manage binary data as latin1 until PEP461-like function is implemented
                cidtogidmap = zlib.compress(cidtogidmap.encode(&#34;latin1&#34;))
                self._newobj()
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(cidtogidmap)) + &#34;&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(cidtogidmap))
                self._out(&#34;endobj&#34;)

                # Font file
                self._newobj()
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(fontstream)))
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;/Length1 &#34; + str(ttfontsize))
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(fontstream))
                self._out(&#34;endobj&#34;)
                del ttf
            else:
                # Allow for additional types
                mtd = &#34;_put&#34; + my_type.lower()
                # check if self has a attr mtd which is callable (method)
                if not callable(getattr(self, mtd, None)):
                    raise FPDFException(&#34;Unsupported font type: &#34; + my_type)
                # pylint: disable=no-member
                self.mtd(font)

    def _putTTfontwidths(self, font, maxUni):
        if font[&#34;unifilename&#34;]:
            ops = os.path.splitext
            cw127fname = ops(font[&#34;unifilename&#34;])[0] + &#34;.cw127.pkl&#34;
        else:
            cw127fname = None
        font_dict = load_cache(cw127fname)
        if font_dict is None:
            rangeid = 0
            range_ = {}
            range_interval = {}
            prevcid = -2
            prevwidth = -1
            interval = False
            startcid = 1
        else:
            rangeid = font_dict[&#34;rangeid&#34;]
            range_ = font_dict[&#34;range&#34;]
            prevcid = font_dict[&#34;prevcid&#34;]
            prevwidth = font_dict[&#34;prevwidth&#34;]
            interval = font_dict[&#34;interval&#34;]
            range_interval = font_dict[&#34;range_interval&#34;]
            startcid = 128
        cwlen = maxUni + 1

        # for each character
        subset = set(font[&#34;subset&#34;])
        for cid in range(startcid, cwlen):
            if cid == 128 and cw127fname and not os.path.exists(cw127fname):
                try:
                    with open(cw127fname, &#34;wb&#34;) as fh:
                        font_dict = {}
                        font_dict[&#34;rangeid&#34;] = rangeid
                        font_dict[&#34;prevcid&#34;] = prevcid
                        font_dict[&#34;prevwidth&#34;] = prevwidth
                        font_dict[&#34;interval&#34;] = interval
                        font_dict[&#34;range_interval&#34;] = range_interval
                        font_dict[&#34;range&#34;] = range_
                        pickle.dump(font_dict, fh)
                except IOError as e:
                    if e.errno != errno.EACCES:
                        raise  # Not a permission error.

            if cid &gt; 255 and (cid not in subset or cid &gt;= len(font[&#34;cw&#34;])):
                continue
            width = font[&#34;cw&#34;][cid]
            if width == 0:
                continue
            if width == 65535:
                width = 0

            if &#34;dw&#34; not in font or (font[&#34;dw&#34;] and width != font[&#34;dw&#34;]):
                if cid == (prevcid + 1):
                    if width == prevwidth:
                        if width == range_[rangeid][0]:
                            range_.setdefault(rangeid, []).append(width)
                        else:
                            range_[rangeid].pop()
                            # new range
                            rangeid = prevcid
                            range_[rangeid] = [prevwidth, width]
                        interval = True
                        range_interval[rangeid] = True
                    else:
                        if interval:
                            # new range
                            rangeid = cid
                            range_[rangeid] = [width]
                        else:
                            range_[rangeid].append(width)
                        interval = False
                else:
                    rangeid = cid
                    range_[rangeid] = [width]
                    interval = False
                prevcid = cid
                prevwidth = width
        prevk = -1
        nextk = -1
        prevint = False

        ri = range_interval
        for k, ws in sorted(range_.items()):
            cws = len(ws)
            if k == nextk and not prevint and (k not in ri or cws &lt; 3):
                if k in ri:
                    del ri[k]
                range_[prevk] = range_[prevk] + range_[k]
                del range_[k]
            else:
                prevk = k
            nextk = k + cws
            if k in ri:
                prevint = cws &gt; 3
                del ri[k]
                nextk -= 1
            else:
                prevint = False
        w = []
        for k, ws in sorted(range_.items()):
            if len(set(ws)) == 1:
                w.append(&#34; %s %s %s&#34; % (k, k + len(ws) - 1, ws[0]))
            else:
                w.append(&#34; %s [ %s ]\n&#34; % (k, &#34; &#34;.join([str(int(h)) for h in ws])))
        self._out(&#34;/W [%s]&#34; % &#34;&#34;.join(w))

    def _putimages(self):
        i = [(x[1][&#34;i&#34;], x[1]) for x in self.images.items()]
        i.sort()
        for _, info in i:
            self._putimage(info)
            del info[&#34;data&#34;]
            if &#34;smask&#34; in info:
                del info[&#34;smask&#34;]

    def _putimage(self, info):
        if &#34;data&#34; in info:
            self._newobj()
            info[&#34;n&#34;] = self.n
            self._out(&#34;&lt;&lt;/Type /XObject&#34;)
            self._out(&#34;/Subtype /Image&#34;)
            self._out(&#34;/Width &#34; + str(info[&#34;w&#34;]))
            self._out(&#34;/Height &#34; + str(info[&#34;h&#34;]))

            if info[&#34;cs&#34;] == &#34;Indexed&#34;:
                self._out(
                    &#34;/ColorSpace [/Indexed /DeviceRGB &#34;
                    + str(len(info[&#34;pal&#34;]) // 3 - 1)
                    + &#34; &#34;
                    + str(self.n + 1)
                    + &#34; 0 R]&#34;
                )
            else:
                self._out(&#34;/ColorSpace /&#34; + info[&#34;cs&#34;])
                if info[&#34;cs&#34;] == &#34;DeviceCMYK&#34;:
                    self._out(&#34;/Decode [1 0 1 0 1 0 1 0]&#34;)

            self._out(&#34;/BitsPerComponent &#34; + str(info[&#34;bpc&#34;]))

            if &#34;f&#34; in info:
                self._out(&#34;/Filter /&#34; + info[&#34;f&#34;])
            if &#34;dp&#34; in info:
                self._out(&#34;/DecodeParms &lt;&lt;&#34; + info[&#34;dp&#34;] + &#34;&gt;&gt;&#34;)

            if &#34;trns&#34; in info and isinstance(info[&#34;trns&#34;], list):
                trns = &#34;&#34;
                for i in range(0, len(info[&#34;trns&#34;])):
                    trns += str(info[&#34;trns&#34;][i]) + &#34; &#34; + str(info[&#34;trns&#34;][i]) + &#34; &#34;
                self._out(&#34;/Mask [&#34; + trns + &#34;]&#34;)

            if &#34;smask&#34; in info:
                self._out(&#34;/SMask &#34; + str(self.n + 1) + &#34; 0 R&#34;)

            self._out(&#34;/Length &#34; + str(len(info[&#34;data&#34;])) + &#34;&gt;&gt;&#34;)
            self._out(pdf_stream(info[&#34;data&#34;]))
            self._out(&#34;endobj&#34;)

            # Soft mask
            if &#34;smask&#34; in info:
                dp = (
                    &#34;/Predictor 15 /Colors 1 /BitsPerComponent 8 &#34;
                    + &#34;/Columns &#34;
                    + str(info[&#34;w&#34;])
                )
                smask = {
                    &#34;w&#34;: info[&#34;w&#34;],
                    &#34;h&#34;: info[&#34;h&#34;],
                    &#34;cs&#34;: &#34;DeviceGray&#34;,
                    &#34;bpc&#34;: 8,
                    &#34;f&#34;: info[&#34;f&#34;],
                    &#34;dp&#34;: dp,
                    &#34;data&#34;: info[&#34;smask&#34;],
                }
                self._putimage(smask)

            # Palette
            if info[&#34;cs&#34;] == &#34;Indexed&#34;:
                self._newobj()
                filter, pal = (
                    (&#34;/Filter /FlateDecode &#34;, zlib.compress(info[&#34;pal&#34;]))
                    if self.compress
                    else (&#34;&#34;, info[&#34;pal&#34;])
                )
                self._out(&#34;&lt;&lt;&#34; + filter + &#34;/Length &#34; + str(len(pal)) + &#34;&gt;&gt;&#34;)
                self._out(pdf_stream(pal))
                self._out(&#34;endobj&#34;)

    def _putxobjectdict(self):
        i = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.images.values()]
        i.sort()
        for idx, n in i:
            self._out(&#34;/I&#34; + str(idx) + &#34; &#34; + str(n) + &#34; 0 R&#34;)

    def _putresourcedict(self):
        self._out(&#34;/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]&#34;)
        self._out(&#34;/Font &lt;&lt;&#34;)
        f = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.fonts.values()]
        f.sort()
        for idx, n in f:
            self._out(&#34;/F&#34; + str(idx) + &#34; &#34; + pdf_ref(n))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;/XObject &lt;&lt;&#34;)
        self._putxobjectdict()
        self._out(&#34;&gt;&gt;&#34;)

    def _putresources(self):
        with self._trace_size(&#34;resources.fonts&#34;):
            self._putfonts()
        with self._trace_size(&#34;resources.images&#34;):
            self._putimages()

        # Resource dictionary
        with self._trace_size(&#34;resources.dict&#34;):
            self.offsets[2] = len(self.buffer)
            self._out(&#34;2 0 obj&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._putresourcedict()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

    def _putinfo(self):
        info_d = OrderedDict()
        info_d[pdf_name(&#34;title&#34;)] = enclose_in_parens(getattr(self, &#34;title&#34;, None))
        info_d[pdf_name(&#34;subject&#34;)] = enclose_in_parens(getattr(self, &#34;subject&#34;, None))
        info_d[pdf_name(&#34;author&#34;)] = enclose_in_parens(getattr(self, &#34;author&#34;, None))
        info_d[pdf_name(&#34;keywords&#34;)] = enclose_in_parens(
            getattr(self, &#34;keywords&#34;, None)
        )
        info_d[pdf_name(&#34;creator&#34;)] = enclose_in_parens(getattr(self, &#34;creator&#34;, None))

        if hasattr(self, &#34;creation_date&#34;):
            try:
                creation_date = self.creation_date
                date_string = creation_date.strftime(&#34;%Y%m%d%H%M%S&#34;)
            except Exception as error:
                raise FPDFException(
                    &#34;Could not format date: &#34; + str(creation_date)
                ) from error
        else:
            date_string = datetime.now().strftime(&#34;%Y%m%d%H%M%S&#34;)
        info_d[pdf_name(&#34;CreationDate&#34;)] = enclose_in_parens(&#34;D:&#34; + date_string)

        self._out(pdf_d(info_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;, has_empty_fields=True))

    def _putcatalog(self):
        catalog_d = OrderedDict()
        catalog_d[pdf_name(&#34;type&#34;)] = pdf_name(&#34;catalog&#34;)
        catalog_d[pdf_name(&#34;pages&#34;)] = pdf_ref(1)

        zoom_configs = {
            &#34;default&#34;: [&#34;/Fit&#34;],  # TODO FIXME
            &#34;fullpage&#34;: [&#34;/Fit&#34;],
            &#34;fullwidth&#34;: [&#34;/FitH&#34;, &#34;null&#34;],
            &#34;real&#34;: [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, &#34;1&#34;],
        }
        zoom_config = [pdf_ref(3)]
        zoom_config.extend(zoom_configs.get(self.zoom_mode, []))

        # zoom_config is a number, not one of the allowed strings
        if not zoom_config:
            zoom_config = [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, str(self.zoom_mode / 100)]

        catalog_d[pdf_name(&#34;OpenAction&#34;)] = pdf_l(zoom_config)

        layout_names = {
            &#34;single&#34;: pdf_name(&#34;SinglePage&#34;),
            &#34;continuous&#34;: pdf_name(&#34;OneColumn&#34;),
            &#34;two&#34;: pdf_name(&#34;TwoColumnLeft&#34;),
        }

        if self.layout_mode in layout_names:
            catalog_d[pdf_name(&#34;PageLayout&#34;)] = layout_names[self.layout_mode]

        self._out(pdf_d(catalog_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;))

    def _putheader(self):
        self._out(&#34;%PDF-&#34; + self.pdf_version)

    def _puttrailer(self):
        self._out(&#34;/Size &#34; + str(self.n + 1))
        self._out(&#34;/Root &#34; + pdf_ref(self.n))
        self._out(&#34;/Info &#34; + pdf_ref(self.n - 1))

    def _enddoc(self):
        LOGGER.debug(&#34;Final doc sections size summary:&#34;)
        with self._trace_size(&#34;header&#34;):
            self._putheader()
        with self._trace_size(&#34;pages&#34;):
            self._putpages()
        self._putresources()  # trace_size is performed inside
        # Info
        with self._trace_size(&#34;info&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putinfo()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Catalog
        with self._trace_size(&#34;catalog&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putcatalog()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Cross-ref
        with self._trace_size(&#34;xref&#34;):
            o = len(self.buffer)
            self._out(&#34;xref&#34;)
            self._out(&#34;0 &#34; + (str(self.n + 1)))
            self._out(&#34;0000000000 65535 f &#34;)
            for i in range(1, self.n + 1):
                self._out(sprintf(&#34;%010d 00000 n &#34;, self.offsets[i]))
        # Trailer
        with self._trace_size(&#34;trailer&#34;):
            self._out(&#34;trailer&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._puttrailer()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;startxref&#34;)
            self._out(o)
        self._out(&#34;%%EOF&#34;)
        self.state = 3

    def _beginpage(self, orientation, format, same):
        self.page += 1
        self.pages[self.page] = {&#34;content&#34;: bytearray()}
        self.state = 2
        self.x = self.l_margin
        self.y = self.t_margin
        self.font_family = &#34;&#34;
        self.font_stretching = 100
        if not same:
            # Page format
            if format:
                # Change page format
                fw_pt, fh_pt = get_page_format(format, self.k)
            else:
                # Set to default format
                fw_pt = self.dw_pt
                fh_pt = self.dh_pt
            # Page orientation
            if not orientation:
                orientation = self.def_orientation
            else:
                orientation = orientation[0].upper()
            if orientation == &#34;P&#34;:
                self.w_pt = fw_pt
                self.h_pt = fh_pt
            else:
                self.w_pt = fh_pt
                self.h_pt = fw_pt
            self.w = self.w_pt / self.k
            self.h = self.h_pt / self.k
            self.page_break_trigger = self.h - self.b_margin
            self.cur_orientation = orientation
        self.pages[self.page][&#34;w_pt&#34;] = self.w_pt
        self.pages[self.page][&#34;h_pt&#34;] = self.h_pt

    def _endpage(self):
        # End of page contents
        self.state = 1

    def _newobj(self):
        # Begin a new object
        self.n += 1
        self.offsets[self.n] = len(self.buffer)
        self._out(str(self.n) + &#34; 0 obj&#34;)

    def _dounderline(self, x, y, txt):
        # Underline text
        up = self.current_font[&#34;up&#34;]
        ut = self.current_font[&#34;ut&#34;]
        w = self.get_string_width(txt, True) + self.ws * txt.count(&#34; &#34;)
        return sprintf(
            &#34;%.2f %.2f %.2f %.2f re f&#34;,
            x * self.k,
            (self.h - (y - up / 1000.0 * self.font_size)) * self.k,
            w * self.k,
            -ut / 1000.0 * self.font_size_pt,
        )

    def _out(self, s):
        # Add a line to the document
        if not isinstance(s, bytes):
            if not isinstance(s, str):
                s = str(s)
            s = s.encode(&#34;latin1&#34;)
        if self.state == 2:
            self.pages[self.page][&#34;content&#34;] += s + b&#34;\n&#34;
        else:
            self.buffer += s + b&#34;\n&#34;

    @check_page
    def interleaved2of5(self, txt, x, y, w=1.0, h=10.0):
        &#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;
        narrow = w / 3.0
        wide = w

        # wide/narrow codes for the digits
        bar_char = {
            &#34;0&#34;: &#34;nnwwn&#34;,
            &#34;1&#34;: &#34;wnnnw&#34;,
            &#34;2&#34;: &#34;nwnnw&#34;,
            &#34;3&#34;: &#34;wwnnn&#34;,
            &#34;4&#34;: &#34;nnwnw&#34;,
            &#34;5&#34;: &#34;wnwnn&#34;,
            &#34;6&#34;: &#34;nwwnn&#34;,
            &#34;7&#34;: &#34;nnnww&#34;,
            &#34;8&#34;: &#34;wnnwn&#34;,
            &#34;9&#34;: &#34;nwnwn&#34;,
            &#34;A&#34;: &#34;nn&#34;,
            &#34;Z&#34;: &#34;wn&#34;,
        }

        self.set_fill_color(0)
        code = txt
        # add leading zero if code-length is odd
        if len(code) % 2 != 0:
            code = &#34;0&#34; + code

        # add start and stop codes
        code = &#34;AA&#34; + code.lower() + &#34;ZA&#34;

        for i in range(0, len(code), 2):
            # choose next pair of digits
            char_bar = code[i]
            char_space = code[i + 1]
            # check whether it is a valid digit
            if char_bar not in bar_char.keys():
                raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_bar)
            if not char_space in bar_char.keys():
                raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_space)

            # create a wide/narrow-seq (first digit=bars, second digit=spaces)
            seq = &#34;&#34;
            for s in range(0, len(bar_char[char_bar])):
                seq += bar_char[char_bar][s] + bar_char[char_space][s]

            for bar, char in enumerate(seq):
                # set line_width depending on value
                line_width = narrow if char == &#34;n&#34; else wide

                # draw every second value, the other is represented by space
                if bar % 2 == 0:
                    self.rect(x, y, line_width, h, &#34;F&#34;)

                x += line_width

    @check_page
    def code39(self, txt, x, y, w=1.5, h=5.0):
        &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
        dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3.0}
        chars = {
            &#34;0&#34;: &#34;nnnwwnwnn&#34;,
            &#34;1&#34;: &#34;wnnwnnnnw&#34;,
            &#34;2&#34;: &#34;nnwwnnnnw&#34;,
            &#34;3&#34;: &#34;wnwwnnnnn&#34;,
            &#34;4&#34;: &#34;nnnwwnnnw&#34;,
            &#34;5&#34;: &#34;wnnwwnnnn&#34;,
            &#34;6&#34;: &#34;nnwwwnnnn&#34;,
            &#34;7&#34;: &#34;nnnwnnwnw&#34;,
            &#34;8&#34;: &#34;wnnwnnwnn&#34;,
            &#34;9&#34;: &#34;nnwwnnwnn&#34;,
            &#34;A&#34;: &#34;wnnnnwnnw&#34;,
            &#34;B&#34;: &#34;nnwnnwnnw&#34;,
            &#34;C&#34;: &#34;wnwnnwnnn&#34;,
            &#34;D&#34;: &#34;nnnnwwnnw&#34;,
            &#34;E&#34;: &#34;wnnnwwnnn&#34;,
            &#34;F&#34;: &#34;nnwnwwnnn&#34;,
            &#34;G&#34;: &#34;nnnnnwwnw&#34;,
            &#34;H&#34;: &#34;wnnnnwwnn&#34;,
            &#34;I&#34;: &#34;nnwnnwwnn&#34;,
            &#34;J&#34;: &#34;nnnnwwwnn&#34;,
            &#34;K&#34;: &#34;wnnnnnnww&#34;,
            &#34;L&#34;: &#34;nnwnnnnww&#34;,
            &#34;M&#34;: &#34;wnwnnnnwn&#34;,
            &#34;N&#34;: &#34;nnnnwnnww&#34;,
            &#34;O&#34;: &#34;wnnnwnnwn&#34;,
            &#34;P&#34;: &#34;nnwnwnnwn&#34;,
            &#34;Q&#34;: &#34;nnnnnnwww&#34;,
            &#34;R&#34;: &#34;wnnnnnwwn&#34;,
            &#34;S&#34;: &#34;nnwnnnwwn&#34;,
            &#34;T&#34;: &#34;nnnnwnwwn&#34;,
            &#34;U&#34;: &#34;wwnnnnnnw&#34;,
            &#34;V&#34;: &#34;nwwnnnnnw&#34;,
            &#34;W&#34;: &#34;wwwnnnnnn&#34;,
            &#34;X&#34;: &#34;nwnnwnnnw&#34;,
            &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
            &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
            &#34;-&#34;: &#34;nwnnnnwnw&#34;,
            &#34;.&#34;: &#34;wwnnnnwnn&#34;,
            &#34; &#34;: &#34;nwwnnnwnn&#34;,
            &#34;*&#34;: &#34;nwnnwnwnn&#34;,
            &#34;$&#34;: &#34;nwnwnwnnn&#34;,
            &#34;/&#34;: &#34;nwnwnnnwn&#34;,
            &#34;+&#34;: &#34;nwnnnwnwn&#34;,
            &#34;%&#34;: &#34;nnnwnwnwn&#34;,
        }
        self.set_fill_color(0)
        for c in txt.upper():
            if c not in chars:
                raise RuntimeError(&#39;Invalid char &#34;%s&#34; for Code39&#39; % c)
            for i, d in enumerate(chars[c]):
                if i % 2 == 0:
                    self.rect(x, y, dim[d], h, &#34;F&#34;)
                x += dim[d]
            x += dim[&#34;n&#34;]

    @check_page
    @contextmanager
    def rect_clip(self, x, y, w, h):
        self._out(
            sprintf(
                &#34;q %.2f %.2f %.2f %.2f re W n\n&#34;,
                x * self.k,
                (self.h - (y + h)) * self.k,
                w * self.k,
                h * self.k,
            )
        )
        yield
        self._out(&#34;Q\n&#34;)

    @contextmanager
    def _trace_size(self, label):
        prev_size = len(self.buffer)
        yield
        LOGGER.debug(&#34;- %s.size: %s&#34;, label, _sizeof_fmt(len(self.buffer) - prev_size))


def _hashpath(fn):
    h = md5()
    h.update(fn.encode(&#34;UTF-8&#34;))
    return h.hexdigest()


def _sizeof_fmt(num, suffix=&#34;B&#34;):
    # Recipe from: https://stackoverflow.com/a/1094933/636849
    for unit in [&#34;&#34;, &#34;Ki&#34;, &#34;Mi&#34;, &#34;Gi&#34;, &#34;Ti&#34;, &#34;Pi&#34;, &#34;Ei&#34;, &#34;Zi&#34;]:
        if abs(num) &lt; 1024.0:
            return &#34;%3.1f%s%s&#34; % (num, unit, suffix)
        num /= 1024.0
    return &#34;%.1f%s%s&#34; % (num, &#34;Yi&#34;, suffix)


__all__ = [&#34;FPDF&#34;, &#34;load_cache&#34;, &#34;get_page_format&#34;, &#34;PAGE_FORMATS&#34;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.fpdf.get_page_format"><code class="name flex">
<span>def <span class="ident">get_page_format</span></span>(<span>format, k=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return page width and height size in points.</p>
<p>Throws FPDFPageFormatException</p>
<p><code>format</code> can be either a 2-tuple or one of 'a3', 'a4', 'a5', 'letter', or
'legal'.</p>
<p>If format is a tuple, then the return value is the tuple's values
given in the units specified on this document in the constructor,
multiplied by the corresponding scale factor <code>k</code>, taken from instance
variable <code>self.k</code>.</p>
<p>If format is a string, the (width, height) tuple returned is in points.
For a width and height of 8.5 * 11, 72 dpi is assumed, so the value
returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be
added by adding fields to the <code>fpdf.fpdf.PAGE_FORMATS</code> dictionary with a
case insensitive key (the name of the new format) and 2-tuple value of
(width, height) in dots per inch with a 72 dpi resolution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_page_format(format, k=None):
    &#34;&#34;&#34;Return page width and height size in points.

    Throws FPDFPageFormatException

    `format` can be either a 2-tuple or one of &#39;a3&#39;, &#39;a4&#39;, &#39;a5&#39;, &#39;letter&#39;, or
    &#39;legal&#39;.

    If format is a tuple, then the return value is the tuple&#39;s values
    given in the units specified on this document in the constructor,
    multiplied by the corresponding scale factor `k`, taken from instance
    variable `self.k`.

    If format is a string, the (width, height) tuple returned is in points.
    For a width and height of 8.5 * 11, 72 dpi is assumed, so the value
    returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be
    added by adding fields to the `fpdf.fpdf.PAGE_FORMATS` dictionary with a
    case insensitive key (the name of the new format) and 2-tuple value of
    (width, height) in dots per inch with a 72 dpi resolution.
    &#34;&#34;&#34;
    if isinstance(format, str):
        format = format.lower()
        if format in PAGE_FORMATS:
            return PAGE_FORMATS[format]
        raise FPDFPageFormatException(format, unknown=True)

    if k is None:
        raise FPDFPageFormatException(format, one=True)

    try:
        return (format[0] * k, format[1] * k)
    except Exception as e:
        args = str(format) + &#34;, &#34; + str(k)
        raise FPDFPageFormatException(&#34;Arguments must be numbers: &#34; + args) from e</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.load_cache"><code class="name flex">
<span>def <span class="ident">load_cache</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Return unpickled object, or None if cache unavailable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_cache(filename):
    &#34;&#34;&#34;Return unpickled object, or None if cache unavailable&#34;&#34;&#34;
    if not filename:
        return None
    try:
        with open(filename, &#34;rb&#34;) as fh:
            return pickle.load(fh)
    # File missing, unsupported pickle, etc
    except (IOError, ValueError):
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.fpdf.FPDF"><code class="flex name class">
<span>class <span class="ident">FPDF</span></span>
<span>(</span><span>orientation='P', unit='mm', format='A4')</span>
</code></dt>
<dd>
<div class="desc"><p>PDF Generation class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FPDF:
    &#34;PDF Generation class&#34;

    def __init__(self, orientation=&#34;P&#34;, unit=&#34;mm&#34;, format=&#34;A4&#34;):
        # Initialization of properties
        self.offsets = {}  # array of object offsets
        self.page = 0  # current page number
        self.n = 2  # current object number
        self.buffer = bytearray()  # buffer holding in-memory PDF
        self.pages = {}  # array containing pages and metadata
        self.state = 0  # current document state
        self.fonts = {}  # array of used fonts
        self.font_files = {}  # array of font files
        self.diffs = {}  # array of encoding differences
        self.images = {}  # array of used images
        self.page_links = {}  # array of links in pages
        self.links = {}  # array of internal links
        self.in_footer = 0  # flag set when processing footer
        self.lasth = 0  # height of last cell printed
        self.font_family = &#34;&#34;  # current font family
        self.font_style = &#34;&#34;  # current font style
        self.font_size_pt = 12  # current font size in points
        self.font_stretching = 100  # current font stretching
        self.unifontsubset = False
        self.underline = 0  # underlining flag
        self.draw_color = &#34;0 G&#34;
        self.fill_color = &#34;0 g&#34;
        self.text_color = &#34;0 g&#34;
        # indicates whether fill and text colors are different
        self.color_flag = 0
        self.ws = 0  # word spacing
        self.angle = 0

        # Standard fonts
        self.core_fonts = {
            &#34;courier&#34;: &#34;Courier&#34;,
            &#34;courierB&#34;: &#34;Courier-Bold&#34;,
            &#34;courierI&#34;: &#34;Courier-Oblique&#34;,
            &#34;courierBI&#34;: &#34;Courier-BoldOblique&#34;,
            &#34;helvetica&#34;: &#34;Helvetica&#34;,
            &#34;helveticaB&#34;: &#34;Helvetica-Bold&#34;,
            &#34;helveticaI&#34;: &#34;Helvetica-Oblique&#34;,
            &#34;helveticaBI&#34;: &#34;Helvetica-BoldOblique&#34;,
            &#34;times&#34;: &#34;Times-Roman&#34;,
            &#34;timesB&#34;: &#34;Times-Bold&#34;,
            &#34;timesI&#34;: &#34;Times-Italic&#34;,
            &#34;timesBI&#34;: &#34;Times-BoldItalic&#34;,
            &#34;symbol&#34;: &#34;Symbol&#34;,
            &#34;zapfdingbats&#34;: &#34;ZapfDingbats&#34;,
        }
        self.core_fonts_encoding = &#34;latin-1&#34;

        # Scale factor
        if unit == &#34;pt&#34;:
            self.k = 1
        elif unit == &#34;mm&#34;:
            self.k = 72 / 25.4
        elif unit == &#34;cm&#34;:
            self.k = 72 / 2.54
        elif unit == &#34;in&#34;:
            self.k = 72.0
        else:
            raise FPDFException(&#34;Incorrect unit: &#34; + unit)

        # Page format
        self.dw_pt, self.dh_pt = get_page_format(format, self.k)

        # Page orientation
        orientation = orientation.lower()
        if orientation in (&#34;p&#34;, &#34;portrait&#34;):
            self.def_orientation = &#34;P&#34;
            self.w_pt = self.dw_pt
            self.h_pt = self.dh_pt
        elif orientation in (&#34;l&#34;, &#34;landscape&#34;):
            self.def_orientation = &#34;L&#34;
            self.w_pt = self.dh_pt
            self.h_pt = self.dw_pt
        else:
            raise FPDFException(&#34;Incorrect orientation: &#34; + orientation)
        self.cur_orientation = self.def_orientation
        self.w = self.w_pt / self.k
        self.h = self.h_pt / self.k

        # Page spacing
        # Page margins (1 cm)
        margin = 28.35 / self.k
        self.set_margins(margin, margin)
        self.c_margin = margin / 10.0  # Interior cell margin (1 mm)
        self.line_width = 0.567 / self.k  # line width (0.2 mm)
        self.set_auto_page_break(1, 2 * margin)  # Automatic page break
        self.set_display_mode(&#34;fullwidth&#34;)  # Full width display mode
        self.compress = True  # Enable compression by default
        self.pdf_version = &#34;1.3&#34;  # Set default PDF version No.

    def set_margins(self, left, top, right=-1):
        &#34;Set left, top and right margins&#34;
        self.l_margin = left
        self.t_margin = top
        if right == -1:
            right = left
        self.r_margin = right

    def set_left_margin(self, margin):
        &#34;Set left margin&#34;
        self.l_margin = margin
        if self.page &gt; 0 and self.x &lt; margin:
            self.x = margin

    def set_top_margin(self, margin):
        &#34;Set top margin&#34;
        self.t_margin = margin

    def set_right_margin(self, margin):
        &#34;Set right margin&#34;
        self.r_margin = margin

    def set_auto_page_break(self, auto, margin=0):
        &#34;Set auto page break mode and triggering margin&#34;
        self.auto_page_break = auto
        self.b_margin = margin
        self.page_break_trigger = self.h - margin

    def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
        &#34;&#34;&#34;Set display mode in viewer

        The &#34;zoom&#34; argument may be &#39;fullpage&#39;, &#39;fullwidth&#39;, &#39;real&#39;,
        &#39;default&#39;, or a number, interpreted as a percentage.
        &#34;&#34;&#34;
        if zoom in [&#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;]:
            self.zoom_mode = zoom
        elif not isinstance(zoom, str):
            self.zoom_mode = zoom
        else:
            raise FPDFException(&#34;Incorrect zoom display mode: &#34; + zoom)

        if layout in [&#34;single&#34;, &#34;continuous&#34;, &#34;two&#34;, &#34;default&#34;]:
            self.layout_mode = layout
        else:
            raise FPDFException(&#34;Incorrect layout display mode: &#34; + layout)

    def set_compression(self, compress):
        &#34;Set page compression&#34;
        self.compress = compress

    def set_title(self, title):
        &#34;Title of document&#34;
        self.title = title

    def set_subject(self, subject):
        &#34;Subject of document&#34;
        self.subject = subject

    def set_author(self, author):
        &#34;Author of document&#34;
        self.author = author

    def set_keywords(self, keywords):
        &#34;Keywords of document&#34;
        self.keywords = keywords

    def set_creator(self, creator):
        &#34;Creator of document&#34;
        self.creator = creator

    def set_creation_date(self, date=None):
        &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
        self.creation_date = datetime.now() if date is None else date

    def set_doc_option(self, opt, value):
        &#34;Set document option&#34;
        if opt == &#34;core_fonts_encoding&#34;:
            self.core_fonts_encoding = value
        else:
            raise FPDFException(&#39;Unknown document option &#34;%s&#34;&#39; % str(opt))

    def alias_nb_pages(self, alias=&#34;{nb}&#34;):
        &#34;Define an alias for total number of pages&#34;
        self.str_alias_nb_pages = alias
        return alias

    def open(self):
        &#34;Begin document&#34;
        self.state = 1

    def close(self):
        &#34;Terminate document&#34;
        if self.state == 3:
            return
        if self.page == 0:
            self.add_page()

        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0

        self._endpage()  # close page
        self._enddoc()  # close document

    def add_page(self, orientation=&#34;&#34;, format=&#34;&#34;, same=False):
        &#34;Start a new page, if same page format will be same as previous&#34;
        if self.state == 0:
            self.open()
        family = self.font_family
        style = self.font_style + &#34;U&#34; if self.underline else self.font_style
        size = self.font_size_pt
        lw = self.line_width
        dc = self.draw_color
        fc = self.fill_color
        tc = self.text_color
        cf = self.color_flag
        stretching = self.font_stretching
        if self.page &gt; 0:
            # Page footer
            self.in_footer = 1
            self.footer()
            self.in_footer = 0
            # close page
            self._endpage()

        # Start new page
        self._beginpage(orientation, format, same)
        self._out(&#34;2 J&#34;)  # Set line cap style to square
        self.line_width = lw  # Set line width
        self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

        # Set font
        if family:
            self.set_font(family, style, size)

        # Set colors
        self.draw_color = dc
        if dc != &#34;0 G&#34;:
            self._out(dc)
        self.fill_color = fc
        if fc != &#34;0 g&#34;:
            self._out(fc)
        self.text_color = tc
        self.color_flag = cf

        # BEGIN Page header
        self.header()

        if self.line_width != lw:  # Restore line width
            self.line_width = lw
            self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

        if family:
            self.set_font(family, style, size)  # Restore font

        if self.draw_color != dc:  # Restore colors
            self.draw_color = dc
            self._out(dc)
        if self.fill_color != fc:
            self.fill_color = fc
            self._out(fc)
        self.text_color = tc
        self.color_flag = cf

        if stretching != 100:  # Restore stretching
            self.set_stretching(stretching)
        # END Page header

    def header(self):
        &#34;Header to be implemented in your own inherited class&#34;

    def footer(self):
        &#34;Footer to be implemented in your own inherited class&#34;

    def page_no(self):
        &#34;Get current page number&#34;
        return self.page

    def set_draw_color(self, r, g=-1, b=-1):
        &#34;Set color for all stroking operations&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.draw_color = sprintf(&#34;%.3f G&#34;, r / 255.0)
        else:
            self.draw_color = sprintf(
                &#34;%.3f %.3f %.3f RG&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        if self.page &gt; 0:
            self._out(self.draw_color)

    def set_fill_color(self, r, g=-1, b=-1):
        &#34;Set color for all filling operations&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.fill_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
        else:
            self.fill_color = sprintf(
                &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        self.color_flag = self.fill_color != self.text_color
        if self.page &gt; 0:
            self._out(self.fill_color)

    def set_text_color(self, r, g=-1, b=-1):
        &#34;Set color for text&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.text_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
        else:
            self.text_color = sprintf(
                &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
            )
        self.color_flag = self.fill_color != self.text_color

    def get_string_width(self, s, normalized=False):
        &#34;Get width of a string in the current font&#34;
        # normalized is parameter for internal use
        s = s if normalized else self.normalize_text(s)
        cw = self.current_font[&#34;cw&#34;]
        w = 0
        l = len(s)
        if self.unifontsubset:
            for char in s:
                char = ord(char)
                if len(cw) &gt; char:
                    w += cw[char]
                elif self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]:
                    w += self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]
                else:
                    w += 500
        else:
            for i in range(0, l):
                w += cw.get(s[i], 0)
        if self.font_stretching != 100:
            w = w * self.font_stretching / 100.0
        return w * self.font_size / 1000.0

    def set_line_width(self, width):
        &#34;Set line width&#34;
        self.line_width = width
        if self.page &gt; 0:
            self._out(sprintf(&#34;%.2f w&#34;, width * self.k))

    @check_page
    def line(self, x1, y1, x2, y2):
        &#34;Draw a line&#34;
        self._out(
            sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S&#34;,
                x1 * self.k,
                (self.h - y1) * self.k,
                x2 * self.k,
                (self.h - y2) * self.k,
            )
        )

    def _set_dash(self, dash_length=False, space_length=False):
        if dash_length and space_length:
            s = sprintf(&#34;[%.3f %.3f] 0 d&#34;, dash_length * self.k, space_length * self.k)
        else:
            s = &#34;[] 0 d&#34;
        self._out(s)

    @check_page
    def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
        &#34;&#34;&#34;Draw a dashed line. Same interface as line() except:
        - dash_length: Length of the dash
        - space_length: Length of the space between dashes&#34;&#34;&#34;
        self._set_dash(dash_length, space_length)
        self.line(x1, y1, x2, y2)
        self._set_dash()

    @check_page
    def rect(self, x, y, w, h, style=None):
        &#34;Draw a rectangle&#34;
        style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
        op = style_to_operators.get(style, &#34;S&#34;)
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f re %s&#34;,
                x * self.k,
                (self.h - y) * self.k,
                w * self.k,
                -h * self.k,
                op,
            )
        )

    @check_page
    def ellipse(self, x, y, w, h, style=None):
        &#34;Draw a ellipse&#34;
        style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
        op = style_to_operators.get(style, &#34;S&#34;)

        cx = x + w / 2.0
        cy = y + h / 2.0
        rx = w / 2.0
        ry = h / 2.0

        lx = 4.0 / 3.0 * (math.sqrt(2) - 1) * rx
        ly = 4.0 / 3.0 * (math.sqrt(2) - 1) * ry

        self._out(
            sprintf(
                &#34;%.2f %.2f m %.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx + rx) * self.k,
                (self.h - cy) * self.k,
                (cx + rx) * self.k,
                (self.h - (cy - ly)) * self.k,
                (cx + lx) * self.k,
                (self.h - (cy - ry)) * self.k,
                cx * self.k,
                (self.h - (cy - ry)) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx - lx) * self.k,
                (self.h - (cy - ry)) * self.k,
                (cx - rx) * self.k,
                (self.h - (cy - ly)) * self.k,
                (cx - rx) * self.k,
                (self.h - cy) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
                (cx - rx) * self.k,
                (self.h - (cy + ly)) * self.k,
                (cx - lx) * self.k,
                (self.h - (cy + ry)) * self.k,
                cx * self.k,
                (self.h - (cy + ry)) * self.k,
            )
        )
        self._out(
            sprintf(
                &#34;%.2f %.2f %.2f %.2f %.2f %.2f c %s&#34;,
                (cx + lx) * self.k,
                (self.h - (cy + ry)) * self.k,
                (cx + rx) * self.k,
                (self.h - (cy + ly)) * self.k,
                (cx + rx) * self.k,
                (self.h - cy) * self.k,
                op,
            )
        )

    def add_font(self, family, style=&#34;&#34;, fname=None, uni=False):
        &#34;Add a TrueType or Type1 font&#34;
        if not fname:
            fname = family.replace(&#34; &#34;, &#34;&#34;) + style.lower() + &#34;.pkl&#34;

        if family.lower() == &#34;arial&#34;:
            warnings.warn(&#34;Substitutting Arial by core font Helvetica&#34;)
            family = &#34;helvetica&#34;
        style = style.upper()
        if style == &#34;IB&#34;:
            style = &#34;BI&#34;
        fontkey = family + style

        # Font already added!
        if fontkey in self.fonts:
            return
        if uni:
            if os.path.exists(fname):
                ttffilename = fname
            elif FPDF_FONT_DIR and os.path.exists(os.path.join(FPDF_FONT_DIR, fname)):
                ttffilename = os.path.join(FPDF_FONT_DIR, fname)
            elif SYSTEM_TTFONTS and os.path.exists(os.path.join(SYSTEM_TTFONTS, fname)):
                ttffilename = os.path.join(SYSTEM_TTFONTS, fname)
            else:
                raise RuntimeError(&#34;TTF Font file not found: %s&#34; % fname)
            if FPDF_CACHE_MODE == 0:
                unifilename = os.path.splitext(ttffilename)[0] + &#34;.pkl&#34;
            elif FPDF_CACHE_MODE == 2:
                unifilename = os.path.join(
                    FPDF_CACHE_DIR, _hashpath(ttffilename) + &#34;.pkl&#34;
                )
            else:
                unifilename = None

            font_dict = load_cache(unifilename)
            if font_dict is None:
                ttf = TTFontFile()
                ttf.getMetrics(ttffilename)
                desc = {
                    &#34;Ascent&#34;: int(round(ttf.ascent, 0)),
                    &#34;Descent&#34;: int(round(ttf.descent, 0)),
                    &#34;CapHeight&#34;: int(round(ttf.capHeight, 0)),
                    &#34;Flags&#34;: ttf.flags,
                    &#34;FontBBox&#34;: &#34;[%s %s %s %s]&#34;
                    % (
                        int(round(ttf.bbox[0], 0)),
                        int(round(ttf.bbox[1], 0)),
                        int(round(ttf.bbox[2], 0)),
                        int(round(ttf.bbox[3], 0)),
                    ),
                    &#34;ItalicAngle&#34;: int(ttf.italicAngle),
                    &#34;StemV&#34;: int(round(ttf.stemV, 0)),
                    &#34;MissingWidth&#34;: int(round(ttf.defaultWidth, 0)),
                }

                # Generate metrics .pkl file
                font_dict = {
                    &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
                    &#34;type&#34;: &#34;TTF&#34;,
                    &#34;desc&#34;: desc,
                    &#34;up&#34;: round(ttf.underlinePosition),
                    &#34;ut&#34;: round(ttf.underlineThickness),
                    &#34;ttffile&#34;: ttffilename,
                    &#34;fontkey&#34;: fontkey,
                    &#34;originalsize&#34;: os.stat(ttffilename).st_size,
                    &#34;cw&#34;: ttf.charWidths,
                }

                if unifilename:
                    try:
                        with open(unifilename, &#34;wb&#34;) as fh:
                            pickle.dump(font_dict, fh)
                    except IOError as e:
                        if e.errno != errno.EACCES:
                            raise  # Not a permission error.
                del ttf

            # include numbers in the subset! (if alias present)
            have_page_alias = lambda: hasattr(self, &#34;str_alias_nb_pages&#34;)
            sbarr = list(range(0, 57 if have_page_alias() else 32))

            self.fonts[fontkey] = {
                &#34;i&#34;: len(self.fonts) + 1,
                &#34;type&#34;: font_dict[&#34;type&#34;],
                &#34;name&#34;: font_dict[&#34;name&#34;],
                &#34;desc&#34;: font_dict[&#34;desc&#34;],
                &#34;up&#34;: font_dict[&#34;up&#34;],
                &#34;ut&#34;: font_dict[&#34;ut&#34;],
                &#34;cw&#34;: font_dict[&#34;cw&#34;],
                &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
                &#34;fontkey&#34;: fontkey,
                &#34;subset&#34;: sbarr,
                &#34;unifilename&#34;: unifilename,
            }
            self.font_files[fontkey] = {
                &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;ttffile&#34;: ttffilename,
            }
            self.font_files[fname] = {&#34;type&#34;: &#34;TTF&#34;}
        else:
            with open(fname, &#34;rb&#34;) as fontfile:
                font_dict = pickle.load(fontfile)
            self.fonts[fontkey] = {&#34;i&#34;: len(self.fonts) + 1}
            self.fonts[fontkey].update(font_dict)
            diff = font_dict.get(&#34;diff&#34;)
            if diff:
                # Search existing encodings
                d = 0
                nb = len(self.diffs)
                for i in range(1, nb + 1):
                    if self.diffs[i] == diff:
                        d = i
                        break
                if d == 0:
                    d = nb + 1
                    self.diffs[d] = diff
                self.fonts[fontkey][&#34;diff&#34;] = d
            filename = font_dict.get(&#34;filename&#34;)
            if filename:
                if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                    originalsize = font_dict[&#34;originalsize&#34;]
                    self.font_files[filename] = {&#34;length1&#34;: originalsize}
                else:
                    self.font_files[filename] = {
                        &#34;length1&#34;: font_dict[&#34;size1&#34;],
                        &#34;length2&#34;: font_dict[&#34;size2&#34;],
                    }

    def set_font(self, family, style=&#34;&#34;, size=0):
        &#34;Select a font; size given in points&#34;
        if family == &#34;&#34;:
            family = self.font_family
        if family.lower() == &#34;arial&#34;:
            warnings.warn(&#34;Substitutting Arial by core font Helvetica&#34;)
            family = &#34;helvetica&#34;
        elif family in (&#34;symbol&#34;, &#34;zapfdingbats&#34;):
            style = &#34;&#34;
        style = style.upper()
        if &#34;U&#34; in style:
            self.underline = 1
            style = style.replace(&#34;U&#34;, &#34;&#34;)
        else:
            self.underline = 0
        if style == &#34;IB&#34;:
            style = &#34;BI&#34;
        if size == 0:
            size = self.font_size_pt

        # Test if font is already selected
        if (
            self.font_family == family
            and self.font_style == style
            and self.font_size_pt == size
        ):
            return

        # Test if used for the first time
        fontkey = family + style
        if fontkey not in self.fonts:
            if fontkey not in self.core_fonts or fontkey not in fpdf_charwidths:
                raise FPDFException(&#34;Undefined font: &#34; + fontkey)
            i = len(self.fonts) + 1
            self.fonts[fontkey] = {
                &#34;i&#34;: i,
                &#34;type&#34;: &#34;core&#34;,
                &#34;name&#34;: self.core_fonts[fontkey],
                &#34;up&#34;: -100,
                &#34;ut&#34;: 50,
                &#34;cw&#34;: fpdf_charwidths[fontkey],
            }

        # Select it
        self.font_family = family
        self.font_style = style
        self.font_size_pt = size
        self.font_size = size / self.k
        self.current_font = self.fonts[fontkey]
        self.unifontsubset = self.current_font[&#34;type&#34;] == &#34;TTF&#34;
        if self.page &gt; 0:
            self._out(
                sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
            )

    def set_font_size(self, size):
        &#34;Set font size in points&#34;
        if self.font_size_pt == size:
            return
        self.font_size_pt = size
        self.font_size = size / self.k
        if self.page &gt; 0:
            self._out(
                sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
            )

    def set_stretching(self, factor):
        &#34;Set from stretch factor percents (default: 100.0)&#34;
        if self.font_stretching == factor:
            return
        self.font_stretching = factor
        if self.page &gt; 0:
            self._out(sprintf(&#34;BT %.2f Tz ET&#34;, self.font_stretching))

    def add_link(self):
        &#34;Create a new internal link&#34;
        n = len(self.links) + 1
        self.links[n] = (0, 0)
        return n

    def set_link(self, link, y=0, page=-1):
        &#34;Set destination of internal link&#34;
        if y == -1:
            y = self.y
        if page == -1:
            page = self.page

        self.links[link] = [page, y]

    def link(self, x, y, w, h, link, alt_text=&#34;&#34;):
        &#34;Put a link on the page&#34;
        if self.page not in self.page_links:
            self.page_links[self.page] = []
        self.page_links[self.page] += [
            (x * self.k, self.h_pt - y * self.k, w * self.k, h * self.k, link, alt_text)
        ]

    @check_page
    def text(self, x, y, txt=&#34;&#34;):
        &#34;Output a string&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        txt = self.normalize_text(txt)
        if self.unifontsubset:
            txt2 = escape_parens(txt).encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;)
            for char in txt:
                self.current_font[&#34;subset&#34;].append(ord(char))
        else:
            txt2 = escape_parens(txt)
        s = sprintf(
            &#34;BT %.2f %.2f Td (%s) Tj ET&#34;, x * self.k, (self.h - y) * self.k, txt2
        )
        if self.underline and txt != &#34;&#34;:
            s += &#34; &#34; + self._dounderline(x, y, txt)
        if self.color_flag:
            s = &#34;q &#34; + self.text_color + &#34; &#34; + s + &#34; Q&#34;
        self._out(s)

    @check_page
    def rotate(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        .. deprecated:: 2.1.0
          Use `rotation` instead.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;rotate() can produces malformed PDFs and is deprecated. Use the rotation() context manager instead.&#34;,
            PendingDeprecationWarning,
        )
        if x is None:
            x = self.x
        if y is None:
            y = self.y

        if self.angle != 0:
            self._out(&#34;Q&#34;)
        self.angle = angle
        if angle != 0:
            angle *= math.pi / 180
            c = math.cos(angle)
            s = math.sin(angle)
            cx = x * self.k
            cy = (self.h - y) * self.k
            s = sprintf(
                &#34;q %.5F %.5F %.5F %.5F %.2F %.2F &#34; + &#34;cm 1 0 0 1 %.2F %.2F cm&#34;,
                c,
                s,
                -s,
                c,
                cx,
                cy,
                -cx,
                -cy,
            )
            self._out(s)

    @check_page
    @contextmanager
    def rotation(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        This method allows to perform a rotation around a given center.

        The rotation affects all elements which are printed inside the indented context
        (with the exception of clickable areas).

        Notes
        -----

        Only the rendering is altered. The `get_x()` and `get_y()` methods are not affected,
        nor the automatic page break mechanism.
        &#34;&#34;&#34;
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        angle *= math.pi / 180
        c, s = math.cos(angle), math.sin(angle)
        cx, cy = x * self.k, (self.h - y) * self.k
        self._out(
            sprintf(
                &#34;q %.5F %.5F %.5F %.5F %.2F %.2F cm 1 0 0 1 %.2F %.2F cm\n&#34;,
                c,
                s,
                -s,
                c,
                cx,
                cy,
                -cx,
                -cy,
            )
        )
        yield
        self._out(&#34;Q\n&#34;)

    @property
    def accept_page_break(self):
        &#34;Accept automatic page break or not&#34;
        return self.auto_page_break

    @check_page
    def cell(self, w, h=0, txt=&#34;&#34;, border=0, ln=0, align=&#34;&#34;, fill=0, link=&#34;&#34;):
        &#34;Output a cell, return boolean if triggered auto page break&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                &#39;Integer values for &#34;border&#34; parameter other than 1 are currently ignored&#39;
            )
            border = 1
        page_break_triggered = False
        txt = self.normalize_text(txt)
        k = self.k
        if (
            self.y + h &gt; self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        ):

            # Automatic page break
            page_break_triggered = True
            x = self.x
            ws = self.ws
            if ws &gt; 0:
                self.ws = 0
                self._out(&#34;0 Tw&#34;)
            self.add_page(same=True)
            self.x = x  # restore x but not y after drawing header

            if ws &gt; 0:
                self.ws = ws
                self._out(sprintf(&#34;%.3f Tw&#34;, ws * k))
        if w == 0:
            w = self.w - self.r_margin - self.x
        s = &#34;&#34;

        if fill == 1 or border == 1:
            if fill == 1:
                if border == 1:
                    op = &#34;B&#34;
                else:
                    op = &#34;f&#34;
            else:
                op = &#34;S&#34;
            s = sprintf(
                &#34;%.2f %.2f %.2f %.2f re %s &#34;,
                self.x * k,
                (self.h - self.y) * k,
                w * k,
                -h * k,
                op,
            )

        if isinstance(border, str):
            x = self.x
            y = self.y
            if &#34;L&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - y) * k,
                    x * k,
                    (self.h - (y + h)) * k,
                )
            if &#34;T&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - y) * k,
                    (x + w) * k,
                    (self.h - y) * k,
                )
            if &#34;R&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    (x + w) * k,
                    (self.h - y) * k,
                    (x + w) * k,
                    (self.h - (y + h)) * k,
                )
            if &#34;B&#34; in border:
                s += sprintf(
                    &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                    x * k,
                    (self.h - (y + h)) * k,
                    (x + w) * k,
                    (self.h - (y + h)) * k,
                )

        if txt != &#34;&#34;:
            if align == &#34;R&#34;:
                dx = w - self.c_margin - self.get_string_width(txt, True)
            elif align == &#34;C&#34;:
                dx = (w - self.get_string_width(txt, True)) / 2.0
            else:
                dx = self.c_margin
            if self.color_flag:
                s += &#34;q &#34; + self.text_color + &#34; &#34;

            # If multibyte, Tw has no effect - do word spacing using an
            # adjustment before each space
            if self.ws and self.unifontsubset:
                for char in txt:
                    self.current_font[&#34;subset&#34;].append(ord(char))
                space = escape_parens(&#34; &#34;.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))

                s += sprintf(
                    &#34;BT 0 Tw %.2F %.2F Td [&#34;,
                    (self.x + dx) * k,
                    (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
                )

                t = txt.split(&#34; &#34;)
                numt = len(t)
                for i in range(numt):
                    tx = t[i]
                    tx = enclose_in_parens(
                        escape_parens(tx.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                    )
                    s += sprintf(&#34;%s &#34;, tx)
                    if (i + 1) &lt; numt:
                        adj = -(self.ws * self.k) * 1000 / self.font_size_pt
                        s += sprintf(&#34;%d(%s) &#34;, adj, space)
                s += &#34;] TJ&#34;
                s += &#34; ET&#34;
            else:
                if self.unifontsubset:
                    txt2 = escape_parens(txt.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                    for char in txt:
                        self.current_font[&#34;subset&#34;].append(ord(char))
                else:
                    txt2 = escape_parens(txt)

                s += sprintf(
                    &#34;BT %.2f %.2f Td (%s) Tj ET&#34;,
                    (self.x + dx) * k,
                    (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
                    txt2,
                )

            if self.underline:
                s += &#34; &#34; + self._dounderline(
                    self.x + dx, self.y + (0.5 * h) + (0.3 * self.font_size), txt
                )
            if self.color_flag:
                s += &#34; Q&#34;
            if link:
                self.link(
                    self.x + dx,
                    self.y + (0.5 * h) - (0.5 * self.font_size),
                    self.get_string_width(txt, True),
                    self.font_size,
                    link,
                )
        if s:
            self._out(s)
        self.lasth = h

        if ln &gt; 0:
            self.y += h  # Go to next line
            if ln == 1:
                self.x = self.l_margin
        else:
            self.x += w

        return page_break_triggered

    @check_page
    def multi_cell(
        self, w, h, txt=&#34;&#34;, border=0, align=&#34;J&#34;, fill=0, split_only=False, link=&#34;&#34;, ln=0
    ):
        &#34;&#34;&#34;
        Output text with automatic or explicit line breaks,
        returns boolean if page break triggered in output mode.

        Args:
            ln (int): controls cell positioning:

              - 0: stack cells horizontally, with respect to `.x` &amp; `.y`
              - 1: one cell per line, aligned on the left with respect to `.l_margin`
              - 2: one cell per line
        &#34;&#34;&#34;
        page_break_triggered = False
        if split_only:
            _out, _add_page = self._out, self.add_page
            self._out = lambda *args, **kwargs: None
            self.add_page = lambda *args, **kwargs: None

        # Store this information for manipulating position.
        location = (self.get_x(), self.get_y())

        # If width is 0, set width to available width between margins
        if w == 0:
            w = self.w - self.r_margin - self.x
        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size

        # Calculate text length
        txt = self.normalize_text(txt)
        s = txt.replace(&#34;\r&#34;, &#34;&#34;)
        normalized_string_length = len(s)
        if normalized_string_length &gt; 0 and s[-1] == &#34;\n&#34;:
            normalized_string_length -= 1

        b = 0
        if border:
            if border == 1:
                border = &#34;LTRB&#34;
                b = &#34;LRT&#34;
                b2 = &#34;LR&#34;
            else:
                b2 = &#34;&#34;
                if &#34;L&#34; in border:
                    b2 += &#34;L&#34;
                if &#34;R&#34; in border:
                    b2 += &#34;R&#34;
                if &#34;T&#34; in border:
                    b = b2 + &#34;T&#34;
                else:
                    b = b2

        character_widths = self.current_font[&#34;cw&#34;]
        text_cells = []
        sep = -1
        i = 0
        j = 0
        l = 0
        ns = 0
        nl = 1
        while i &lt; normalized_string_length:
            # Get next character
            c = s[i]

            # Explicit line break
            if c == &#34;\n&#34;:
                if self.ws &gt; 0:
                    self.ws = 0
                    self._out(&#34;0 Tw&#34;)

                new_page = self.cell(
                    w,
                    h=h,
                    txt=substr(s, j, i - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, i - j))

                i += 1
                sep = -1
                j = i
                l = 0
                ns = 0
                nl += 1
                if border and nl == 2:
                    b = b2
                continue

            if c == &#34; &#34;:
                sep = i
                ls = l
                ns += 1
            if self.unifontsubset:
                l += self.get_string_width(c, True) / self.font_size * 1000.0
            else:
                l += character_widths.get(c, 0)

            # Automatic line break
            if l &gt; wmax:
                if sep == -1:
                    if i == j:
                        i += 1
                    if self.ws &gt; 0:
                        self.ws = 0
                        self._out(&#34;0 Tw&#34;)

                    new_page = self.cell(
                        w,
                        h=h,
                        txt=substr(s, j, i - j),
                        border=b,
                        ln=2,
                        align=align,
                        fill=fill,
                        link=link,
                    )
                    page_break_triggered = page_break_triggered or new_page
                    text_cells.append(substr(s, j, i - j))

                else:
                    if align == &#34;J&#34;:
                        if ns &gt; 1:
                            self.ws = (wmax - ls) / 1000.0 * self.font_size / (ns - 1)
                        else:
                            self.ws = 0
                        self._out(sprintf(&#34;%.3f Tw&#34;, self.ws * self.k))

                    new_page = self.cell(
                        w,
                        h=h,
                        txt=substr(s, j, sep - j),
                        border=b,
                        ln=2,
                        align=align,
                        fill=fill,
                        link=link,
                    )
                    page_break_triggered = page_break_triggered or new_page
                    text_cells.append(substr(s, j, sep - j))

                    i = sep + 1
                sep = -1
                j = i
                l = 0
                ns = 0
                nl += 1
                if border and nl == 2:
                    b = b2
            else:
                i += 1

        # Last chunk
        if self.ws &gt; 0:
            self.ws = 0
            self._out(&#34;0 Tw&#34;)
        if border and &#34;B&#34; in border:
            b += &#34;B&#34;

        new_page = self.cell(
            w,
            h=h,
            txt=substr(s, j, i - j),
            border=b,
            ln=2,
            align=align,
            fill=fill,
            link=link,
        )
        page_break_triggered = page_break_triggered or new_page
        text_cells.append(substr(s, j, i - j))

        location_options = {
            0: lambda: self.set_xy(self.x + w, self.y),
            1: lambda: self.set_x(self.l_margin),  # could control y
            2: lambda: None,
        }
        location_options.get(ln, lambda: None)()

        if split_only:
            # restore writing functions
            self._out, self.add_page = _out, _add_page
            self.set_xy(*location)  # restore location
            return text_cells

        return page_break_triggered

    @check_page
    def write(self, h, txt=&#34;&#34;, link=&#34;&#34;):
        &#34;Output text in flowing mode&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        txt = self.normalize_text(txt)
        cw = self.current_font[&#34;cw&#34;]
        w = self.w - self.r_margin - self.x
        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
        s = txt.replace(&#34;\r&#34;, &#34;&#34;)
        nb = len(s)
        sep = -1
        i = 0
        j = 0
        l = 0
        nl = 1
        while i &lt; nb:
            # Get next character
            c = s[i]
            if c == &#34;\n&#34;:
                # Explicit line break
                self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
                i += 1
                sep = -1
                j = i
                l = 0
                if nl == 1:
                    self.x = self.l_margin
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                nl += 1
                continue
            if c == &#34; &#34;:
                sep = i
            if self.unifontsubset:
                l += self.get_string_width(c, True) / self.font_size * 1000.0
            else:
                l += cw.get(c, 0)
            if l &gt; wmax:
                # Automatic line break
                if sep == -1:
                    if self.x &gt; self.l_margin:
                        # Move to next line
                        self.x = self.l_margin
                        self.y += h
                        w = self.w - self.r_margin - self.x
                        wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                        i += 1
                        nl += 1
                        continue
                    if i == j:
                        i += 1
                    self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
                else:
                    self.cell(w, h, substr(s, j, sep - j), 0, 2, &#34;&#34;, 0, link)
                    i = sep + 1
                sep = -1
                j = i
                l = 0
                if nl == 1:
                    self.x = self.l_margin
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                nl += 1
            else:
                i += 1
        # Last chunk
        if i != j:
            self.cell(l / 1000.0 * self.font_size, h, substr(s, j), 0, 0, &#34;&#34;, 0, link)

    @check_page
    def image(
        self,
        name,
        x=None,
        y=None,
        w=0,
        h=0,
        type=&#34;&#34;,
        link=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Put an image on the page

        Args:
            name: either a string representing a file path to an image, or a instance of `PIL.Image.Image`
            x (int): optional horizontal position where to put the image on the page
            y (int): optional vertical position where to put the image on the page
            w (int): optional width of the image
            h (int): optional height of the image
            type (str): [**DEPRECATED**] unused, will be removed in a later version
            link (str): optional link, internal or external, to add on the image
        &#34;&#34;&#34;
        if type:
            warnings.warn(
                &#39;&#34;type&#34; is unused and will soon be deprecated&#39;,
                PendingDeprecationWarning,
            )
        if isinstance(name, str):
            img = load_resource(name)
        else:
            name, img = uuid4(), name
        if name not in self.images:
            info = get_img_info(img)
            info[&#34;i&#34;] = len(self.images) + 1
            self.images[name] = info
        else:
            info = self.images[name]

        # Automatic width and height calculation if needed
        if w == 0 and h == 0:
            # Put image at 72 dpi
            w = info[&#34;w&#34;] / self.k
            h = info[&#34;h&#34;] / self.k
        elif w == 0:
            w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
        elif h == 0:
            h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

        # Flowing mode
        if y is None:
            if (
                self.y + h &gt; self.page_break_trigger
                and not self.in_footer
                and self.accept_page_break
            ):
                # Automatic page break
                x = self.x
                self.add_page(same=True)
                self.x = x
            y = self.y
            self.y += h

        if x is None:
            x = self.x
        self._out(
            sprintf(
                &#34;q %.2f 0 0 %.2f %.2f %.2f cm /I%d Do Q&#34;,
                w * self.k,
                h * self.k,
                x * self.k,
                (self.h - (y + h)) * self.k,
                info[&#34;i&#34;],
            )
        )
        if link:
            self.link(x, y, w, h, link)

        return info

    @check_page
    def ln(self, h=None):
        &#34;Line Feed; default value is last cell height&#34;
        self.x = self.l_margin
        if h is None:
            self.y += self.lasth
        else:
            self.y += h

    def get_x(self):
        &#34;Get x position&#34;
        return self.x

    def set_x(self, x):
        &#34;Set x position&#34;
        if x &gt;= 0:
            self.x = x
        else:
            self.x = self.w + x

    def get_y(self):
        &#34;Get y position&#34;
        return self.y

    def set_y(self, y):
        &#34;Set y position and reset x&#34;
        self.x = self.l_margin
        if y &gt;= 0:
            self.y = y
        else:
            self.y = self.h + y

    def set_xy(self, x, y):
        &#34;Set x and y positions&#34;
        self.set_y(y)
        self.set_x(x)

    def output(self, name=&#34;&#34;, dest=&#34;&#34;):
        &#34;&#34;&#34;Output PDF to some destination

        By default the PDF is written to sys.stdout. If a name is given, the
        PDF is written to a new file. If dest=&#39;S&#39; is given, the PDF data is
        returned as a byte string.&#34;&#34;&#34;
        # pylint: disable=inconsistent-return-statements
        # Finish document if necessary
        if self.state &lt; 3:
            self.close()
        dest = dest.upper()
        if dest == &#34;&#34;:
            dest = &#34;I&#34; if name == &#34;&#34; else &#34;F&#34;
        if dest in (&#34;I&#34;, &#34;D&#34;):
            # Python &lt; 3 writes byte data transparently without &#34;buffer&#34;
            stdout = getattr(sys.stdout, &#34;buffer&#34;, sys.stdout)
            stdout.write(self.buffer)
            return None
        if dest == &#34;F&#34;:
            # Save to local file
            with open(name, &#34;wb&#34;) as f:
                f.write(self.buffer)
            return None
        # Return as a byte string
        if dest == &#34;S&#34;:
            return self.buffer
        raise FPDFException(&#34;Incorrect output destination: &#34; + dest)

    def normalize_text(self, txt):
        &#34;Check that text input is in the correct format/encoding&#34;
        # - for TTF unicode fonts: unicode object (utf8 encoding)
        # - for built-in fonts: string instances (encoding: latin-1, cp1252)
        if not self.unifontsubset and self.core_fonts_encoding:
            return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
        return txt

    def _putpages(self):
        nb = self.page
        if hasattr(self, &#34;str_alias_nb_pages&#34;):
            # Replace number of pages in fonts using subsets (unicode)
            alias = self.str_alias_nb_pages.encode(&#34;UTF-16BE&#34;)
            r = str(nb).encode(&#34;UTF-16BE&#34;)
            for n in range(1, nb + 1):
                self.pages[n][&#34;content&#34;] = self.pages[n][&#34;content&#34;].replace(alias, r)
            # Now repeat for no pages in non-subset fonts
            for n in range(1, nb + 1):
                self.pages[n][&#34;content&#34;].replace(
                    self.str_alias_nb_pages.encode(&#34;latin-1&#34;), str(nb).encode(&#34;latin-1&#34;)
                )
        if self.def_orientation == &#34;P&#34;:
            dw_pt = self.dw_pt
            dh_pt = self.dh_pt
        else:
            dw_pt = self.dh_pt
            dh_pt = self.dw_pt
        if self.compress:
            filter = &#34;/Filter /FlateDecode &#34;
        else:
            filter = &#34;&#34;
        for n in range(1, nb + 1):
            # page object from pages[n]
            # page object from pages[n]#w_pt
            # page object from pages[n]#h_pt
            # page object from page_links[n] if page_links and page_links[n]
            # Page
            self._newobj()
            self._out(&#34;&lt;&lt;/Type /Page&#34;)
            self._out(&#34;/Parent 1 0 R&#34;)
            w_pt = self.pages[n][&#34;w_pt&#34;]
            h_pt = self.pages[n][&#34;h_pt&#34;]
            if w_pt != dw_pt or h_pt != dh_pt:
                self._out(sprintf(&#34;/MediaBox [0 0 %.2f %.2f]&#34;, w_pt, h_pt))
            self._out(&#34;/Resources 2 0 R&#34;)

            if self.page_links and n in self.page_links:
                # Links
                annots = &#34;/Annots [&#34;
                for pl in self.page_links[n]:
                    # first four things in &#39;link&#39; list are coordinates?
                    rect = sprintf(
                        &#34;%.2f %.2f %.2f %.2f&#34;,
                        pl[0],
                        pl[1],
                        pl[0] + pl[2],
                        pl[1] - pl[3],
                    )

                    # start the annotation entry
                    annots += (
                        &#34;&lt;&lt;/Type /Annot /Subtype /Link /Rect [&#34;
                        + rect
                        + &#34;] /Border [0 0 0] &#34;
                    )

                    # HTML ending of annotation entry
                    if isinstance(pl[4], str):
                        annots += (
                            &#34;/A &lt;&lt;/S /URI /URI &#34; + enclose_in_parens(pl[4]) + &#34;&gt;&gt;&gt;&gt;&#34;
                        )

                    # Dest type ending of annotation entry
                    else:
                        assert (
                            pl[4] in self.links
                        ), &#34;Page {} has a link with an invalid index: {} (doc #links={})&#34;.format(
                            n, pl[4], len(self.links)
                        )
                        l = self.links[pl[4]]
                        # if l[0] in self.orientation_changes: h = w_pt
                        # else:                                h = h_pt
                        annots += sprintf(
                            &#34;/Dest [%d 0 R /XYZ 0 %.2f null]&gt;&gt;&#34;,
                            1 + 2 * l[0],
                            h_pt - l[1] * self.k,
                        )

                # End links list
                self._out(annots + &#34;]&#34;)
            if self.pdf_version &gt; &#34;1.3&#34;:
                self._out(&#34;/Group &lt;&lt;/Type /Group /S /Transparency&#34; &#34;/CS /DeviceRGB&gt;&gt;&#34;)
            self._out(&#34;/Contents &#34; + str(self.n + 1) + &#34; 0 R&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

            # Page content
            content = self.pages[n][&#34;content&#34;]
            if self.compress:
                p = zlib.compress(content)
            else:
                p = content
            self._newobj()
            self._out(&#34;&lt;&lt;&#34; + filter + &#34;/Length &#34; + str(len(p)) + &#34;&gt;&gt;&#34;)
            self._out(pdf_stream(p))
            self._out(&#34;endobj&#34;)
        # Pages root
        self.offsets[1] = len(self.buffer)
        self._out(&#34;1 0 obj&#34;)
        self._out(&#34;&lt;&lt;/Type /Pages&#34;)
        kids = &#34;/Kids [&#34;
        for i in range(0, nb):
            kids += str(3 + 2 * i) + &#34; 0 R &#34;
        self._out(kids + &#34;]&#34;)
        self._out(&#34;/Count &#34; + str(nb))
        self._out(sprintf(&#34;/MediaBox [0 0 %.2f %.2f]&#34;, dw_pt, dh_pt))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _putfonts(self):
        nf = self.n
        for diff in self.diffs:
            # Encodings
            self._newobj()
            self._out(
                (
                    &#34;&lt;&lt;/Type /Encoding /BaseEncoding /WinAnsiEncoding &#34;
                    + &#34;/Differences [&#34;
                    + self.diffs[diff]
                    + &#34;]&gt;&gt;&#34;
                )
            )
            self._out(&#34;endobj&#34;)

        for name, info in self.font_files.items():
            if &#34;type&#34; in info and info[&#34;type&#34;] != &#34;TTF&#34;:
                # Font file embedding
                self._newobj()
                self.font_files[name][&#34;n&#34;] = self.n
                with open(os.path.join(FPDF_FONT_DIR, name), &#34;rb&#34;, 1) as f:
                    font = f.read()
                compressed = substr(name, -2) == &#34;.z&#34;
                if not compressed and &#34;length2&#34; in info:
                    header = ord(font[0]) == 128
                    if header:
                        # Strip first binary header
                        font = substr(font, 6)
                    if header and ord(font[info[&#34;length1&#34;]]) == 128:
                        # Strip second binary header
                        font = substr(font, 0, info[&#34;length1&#34;]) + substr(
                            font, info[&#34;length1&#34;] + 6
                        )

                self._out(&#34;&lt;&lt;/Length &#34; + str(len(font)))
                if compressed:
                    self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;/Length1 &#34; + str(info[&#34;length1&#34;]))
                if &#34;length2&#34; in info:
                    self._out(
                        &#34;/Length2 &#34; + str(info[&#34;length2&#34;]) + &#34; /Length3 0&#34;
                    )  # noqa: E501
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(font))
                self._out(&#34;endobj&#34;)

        # Font objects
        flist = [(x[1][&#34;i&#34;], x[0], x[1]) for x in self.fonts.items()]
        flist.sort()
        for _, font_name, font in flist:
            self.fonts[font_name][&#34;n&#34;] = self.n + 1
            my_type = font[&#34;type&#34;]
            name = font[&#34;name&#34;]
            # Standard font
            if my_type == &#34;core&#34;:
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/BaseFont /&#34; + name)
                self._out(&#34;/Subtype /Type1&#34;)
                if name not in (&#34;Symbol&#34;, &#34;ZapfDingbats&#34;):
                    self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

            # Additional Type1 or TrueType font
            elif my_type in (&#34;Type1&#34;, &#34;TrueType&#34;):
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/BaseFont /&#34; + name)
                self._out(&#34;/Subtype /&#34; + my_type)
                self._out(&#34;/FirstChar 32 /LastChar 255&#34;)
                self._out(&#34;/Widths &#34; + str(self.n + 1) + &#34; 0 R&#34;)
                self._out(&#34;/FontDescriptor &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                if font[&#34;enc&#34;]:
                    if &#34;diff&#34; in font:
                        self._out(
                            &#34;/Encoding &#34; + str(nf + font[&#34;diff&#34;]) + &#34; 0 R&#34;
                        )  # noqa: E501
                    else:
                        self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Widths
                self._newobj()
                cw = font[&#34;cw&#34;]
                s = &#34;[&#34;
                for i in range(32, 256):
                    # Get doesn&#39;t raise exception;
                    # returns 0 instead of None if not set
                    s += str(cw.get(chr(i), 0)) + &#34; &#34;
                self._out(s + &#34;]&#34;)
                self._out(&#34;endobj&#34;)

                # Descriptor
                self._newobj()
                s = &#34;&lt;&lt;/Type /FontDescriptor /FontName /&#34; + name
                for k in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    s += &#34; /%s %s&#34; % (k, font[&#34;desc&#34;][k])

                filename = font[&#34;file&#34;]
                if filename:
                    s += &#34; /FontFile&#34;
                    if my_type != &#34;Type1&#34;:
                        s += &#34;2&#34;
                    s += &#34; &#34; + str(self.font_files[filename][&#34;n&#34;]) + &#34; 0 R&#34;
                self._out(s + &#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)
            elif my_type == &#34;TTF&#34;:
                self.fonts[font_name][&#34;n&#34;] = self.n + 1
                ttf = TTFontFile()
                fontname = &#34;MPDFAA&#34; + &#34;+&#34; + font[&#34;name&#34;]
                subset = font[&#34;subset&#34;]
                del subset[0]
                ttfontstream = ttf.makeSubset(font[&#34;ttffile&#34;], subset)
                ttfontsize = len(ttfontstream)
                fontstream = zlib.compress(ttfontstream)
                codeToGlyph = ttf.codeToGlyph
                # del codeToGlyph[0]

                # Type0 Font
                # A composite font - a font composed of other fonts,
                # organized hierarchically
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /Type0&#34;)
                self._out(&#34;/BaseFont /&#34; + fontname + &#34;&#34;)
                self._out(&#34;/Encoding /Identity-H&#34;)
                self._out(&#34;/DescendantFonts [&#34; + str(self.n + 1) + &#34; 0 R&#34; + &#34;]&#34;)
                self._out(&#34;/ToUnicode &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # CIDFontType2
                # A CIDFont whose glyph descriptions are based on
                # TrueType font technology
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /CIDFontType2&#34;)
                self._out(&#34;/BaseFont /&#34; + fontname + &#34;&#34;)
                self._out(&#34;/CIDSystemInfo &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;/FontDescriptor &#34; + str(self.n + 3) + &#34; 0 R&#34;)
                if font[&#34;desc&#34;].get(&#34;MissingWidth&#34;):
                    self._out(&#34;/DW %d&#34; % font[&#34;desc&#34;][&#34;MissingWidth&#34;])
                self._putTTfontwidths(font, ttf.maxUni)
                self._out(&#34;/CIDToGIDMap &#34; + str(self.n + 4) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # ToUnicode
                self._newobj()
                toUni = (
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    &#34;1 beginbfrange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt; &lt;0000&gt;\n&#34;
                    &#34;endbfrange\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(toUni)) + &#34;&gt;&gt;&#34;)
                self._out(pdf_stream(toUni))
                self._out(&#34;endobj&#34;)

                # CIDSystemInfo dictionary
                self._newobj()
                self._out(&#34;&lt;&lt;/Registry (Adobe)&#34;)
                self._out(&#34;/Ordering (UCS)&#34;)
                self._out(&#34;/Supplement 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Font descriptor
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /FontDescriptor&#34;)
                self._out(&#34;/FontName /&#34; + fontname)
                for kd in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    v = font[&#34;desc&#34;][kd]
                    if kd == &#34;Flags&#34;:
                        v = v | 4
                        v = v &amp; ~32  # SYMBOLIC font flag
                    self._out(&#34; /%s %s&#34; % (kd, v))
                self._out(&#34;/FontFile2 &#34; + str(self.n + 2) + &#34; 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Embed CIDToGIDMap
                # A specification of the mapping from CIDs to glyph indices
                cidtogidmap = &#34;&#34;
                cidtogidmap = [&#34;\x00&#34;] * 256 * 256 * 2
                for cc, glyph in codeToGlyph.items():
                    cidtogidmap[cc * 2] = chr(glyph &gt;&gt; 8)
                    cidtogidmap[cc * 2 + 1] = chr(glyph &amp; 0xFF)
                cidtogidmap = &#34;&#34;.join(cidtogidmap)
                # manage binary data as latin1 until PEP461-like function is implemented
                cidtogidmap = zlib.compress(cidtogidmap.encode(&#34;latin1&#34;))
                self._newobj()
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(cidtogidmap)) + &#34;&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(cidtogidmap))
                self._out(&#34;endobj&#34;)

                # Font file
                self._newobj()
                self._out(&#34;&lt;&lt;/Length &#34; + str(len(fontstream)))
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;/Length1 &#34; + str(ttfontsize))
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(fontstream))
                self._out(&#34;endobj&#34;)
                del ttf
            else:
                # Allow for additional types
                mtd = &#34;_put&#34; + my_type.lower()
                # check if self has a attr mtd which is callable (method)
                if not callable(getattr(self, mtd, None)):
                    raise FPDFException(&#34;Unsupported font type: &#34; + my_type)
                # pylint: disable=no-member
                self.mtd(font)

    def _putTTfontwidths(self, font, maxUni):
        if font[&#34;unifilename&#34;]:
            ops = os.path.splitext
            cw127fname = ops(font[&#34;unifilename&#34;])[0] + &#34;.cw127.pkl&#34;
        else:
            cw127fname = None
        font_dict = load_cache(cw127fname)
        if font_dict is None:
            rangeid = 0
            range_ = {}
            range_interval = {}
            prevcid = -2
            prevwidth = -1
            interval = False
            startcid = 1
        else:
            rangeid = font_dict[&#34;rangeid&#34;]
            range_ = font_dict[&#34;range&#34;]
            prevcid = font_dict[&#34;prevcid&#34;]
            prevwidth = font_dict[&#34;prevwidth&#34;]
            interval = font_dict[&#34;interval&#34;]
            range_interval = font_dict[&#34;range_interval&#34;]
            startcid = 128
        cwlen = maxUni + 1

        # for each character
        subset = set(font[&#34;subset&#34;])
        for cid in range(startcid, cwlen):
            if cid == 128 and cw127fname and not os.path.exists(cw127fname):
                try:
                    with open(cw127fname, &#34;wb&#34;) as fh:
                        font_dict = {}
                        font_dict[&#34;rangeid&#34;] = rangeid
                        font_dict[&#34;prevcid&#34;] = prevcid
                        font_dict[&#34;prevwidth&#34;] = prevwidth
                        font_dict[&#34;interval&#34;] = interval
                        font_dict[&#34;range_interval&#34;] = range_interval
                        font_dict[&#34;range&#34;] = range_
                        pickle.dump(font_dict, fh)
                except IOError as e:
                    if e.errno != errno.EACCES:
                        raise  # Not a permission error.

            if cid &gt; 255 and (cid not in subset or cid &gt;= len(font[&#34;cw&#34;])):
                continue
            width = font[&#34;cw&#34;][cid]
            if width == 0:
                continue
            if width == 65535:
                width = 0

            if &#34;dw&#34; not in font or (font[&#34;dw&#34;] and width != font[&#34;dw&#34;]):
                if cid == (prevcid + 1):
                    if width == prevwidth:
                        if width == range_[rangeid][0]:
                            range_.setdefault(rangeid, []).append(width)
                        else:
                            range_[rangeid].pop()
                            # new range
                            rangeid = prevcid
                            range_[rangeid] = [prevwidth, width]
                        interval = True
                        range_interval[rangeid] = True
                    else:
                        if interval:
                            # new range
                            rangeid = cid
                            range_[rangeid] = [width]
                        else:
                            range_[rangeid].append(width)
                        interval = False
                else:
                    rangeid = cid
                    range_[rangeid] = [width]
                    interval = False
                prevcid = cid
                prevwidth = width
        prevk = -1
        nextk = -1
        prevint = False

        ri = range_interval
        for k, ws in sorted(range_.items()):
            cws = len(ws)
            if k == nextk and not prevint and (k not in ri or cws &lt; 3):
                if k in ri:
                    del ri[k]
                range_[prevk] = range_[prevk] + range_[k]
                del range_[k]
            else:
                prevk = k
            nextk = k + cws
            if k in ri:
                prevint = cws &gt; 3
                del ri[k]
                nextk -= 1
            else:
                prevint = False
        w = []
        for k, ws in sorted(range_.items()):
            if len(set(ws)) == 1:
                w.append(&#34; %s %s %s&#34; % (k, k + len(ws) - 1, ws[0]))
            else:
                w.append(&#34; %s [ %s ]\n&#34; % (k, &#34; &#34;.join([str(int(h)) for h in ws])))
        self._out(&#34;/W [%s]&#34; % &#34;&#34;.join(w))

    def _putimages(self):
        i = [(x[1][&#34;i&#34;], x[1]) for x in self.images.items()]
        i.sort()
        for _, info in i:
            self._putimage(info)
            del info[&#34;data&#34;]
            if &#34;smask&#34; in info:
                del info[&#34;smask&#34;]

    def _putimage(self, info):
        if &#34;data&#34; in info:
            self._newobj()
            info[&#34;n&#34;] = self.n
            self._out(&#34;&lt;&lt;/Type /XObject&#34;)
            self._out(&#34;/Subtype /Image&#34;)
            self._out(&#34;/Width &#34; + str(info[&#34;w&#34;]))
            self._out(&#34;/Height &#34; + str(info[&#34;h&#34;]))

            if info[&#34;cs&#34;] == &#34;Indexed&#34;:
                self._out(
                    &#34;/ColorSpace [/Indexed /DeviceRGB &#34;
                    + str(len(info[&#34;pal&#34;]) // 3 - 1)
                    + &#34; &#34;
                    + str(self.n + 1)
                    + &#34; 0 R]&#34;
                )
            else:
                self._out(&#34;/ColorSpace /&#34; + info[&#34;cs&#34;])
                if info[&#34;cs&#34;] == &#34;DeviceCMYK&#34;:
                    self._out(&#34;/Decode [1 0 1 0 1 0 1 0]&#34;)

            self._out(&#34;/BitsPerComponent &#34; + str(info[&#34;bpc&#34;]))

            if &#34;f&#34; in info:
                self._out(&#34;/Filter /&#34; + info[&#34;f&#34;])
            if &#34;dp&#34; in info:
                self._out(&#34;/DecodeParms &lt;&lt;&#34; + info[&#34;dp&#34;] + &#34;&gt;&gt;&#34;)

            if &#34;trns&#34; in info and isinstance(info[&#34;trns&#34;], list):
                trns = &#34;&#34;
                for i in range(0, len(info[&#34;trns&#34;])):
                    trns += str(info[&#34;trns&#34;][i]) + &#34; &#34; + str(info[&#34;trns&#34;][i]) + &#34; &#34;
                self._out(&#34;/Mask [&#34; + trns + &#34;]&#34;)

            if &#34;smask&#34; in info:
                self._out(&#34;/SMask &#34; + str(self.n + 1) + &#34; 0 R&#34;)

            self._out(&#34;/Length &#34; + str(len(info[&#34;data&#34;])) + &#34;&gt;&gt;&#34;)
            self._out(pdf_stream(info[&#34;data&#34;]))
            self._out(&#34;endobj&#34;)

            # Soft mask
            if &#34;smask&#34; in info:
                dp = (
                    &#34;/Predictor 15 /Colors 1 /BitsPerComponent 8 &#34;
                    + &#34;/Columns &#34;
                    + str(info[&#34;w&#34;])
                )
                smask = {
                    &#34;w&#34;: info[&#34;w&#34;],
                    &#34;h&#34;: info[&#34;h&#34;],
                    &#34;cs&#34;: &#34;DeviceGray&#34;,
                    &#34;bpc&#34;: 8,
                    &#34;f&#34;: info[&#34;f&#34;],
                    &#34;dp&#34;: dp,
                    &#34;data&#34;: info[&#34;smask&#34;],
                }
                self._putimage(smask)

            # Palette
            if info[&#34;cs&#34;] == &#34;Indexed&#34;:
                self._newobj()
                filter, pal = (
                    (&#34;/Filter /FlateDecode &#34;, zlib.compress(info[&#34;pal&#34;]))
                    if self.compress
                    else (&#34;&#34;, info[&#34;pal&#34;])
                )
                self._out(&#34;&lt;&lt;&#34; + filter + &#34;/Length &#34; + str(len(pal)) + &#34;&gt;&gt;&#34;)
                self._out(pdf_stream(pal))
                self._out(&#34;endobj&#34;)

    def _putxobjectdict(self):
        i = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.images.values()]
        i.sort()
        for idx, n in i:
            self._out(&#34;/I&#34; + str(idx) + &#34; &#34; + str(n) + &#34; 0 R&#34;)

    def _putresourcedict(self):
        self._out(&#34;/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]&#34;)
        self._out(&#34;/Font &lt;&lt;&#34;)
        f = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.fonts.values()]
        f.sort()
        for idx, n in f:
            self._out(&#34;/F&#34; + str(idx) + &#34; &#34; + pdf_ref(n))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;/XObject &lt;&lt;&#34;)
        self._putxobjectdict()
        self._out(&#34;&gt;&gt;&#34;)

    def _putresources(self):
        with self._trace_size(&#34;resources.fonts&#34;):
            self._putfonts()
        with self._trace_size(&#34;resources.images&#34;):
            self._putimages()

        # Resource dictionary
        with self._trace_size(&#34;resources.dict&#34;):
            self.offsets[2] = len(self.buffer)
            self._out(&#34;2 0 obj&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._putresourcedict()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

    def _putinfo(self):
        info_d = OrderedDict()
        info_d[pdf_name(&#34;title&#34;)] = enclose_in_parens(getattr(self, &#34;title&#34;, None))
        info_d[pdf_name(&#34;subject&#34;)] = enclose_in_parens(getattr(self, &#34;subject&#34;, None))
        info_d[pdf_name(&#34;author&#34;)] = enclose_in_parens(getattr(self, &#34;author&#34;, None))
        info_d[pdf_name(&#34;keywords&#34;)] = enclose_in_parens(
            getattr(self, &#34;keywords&#34;, None)
        )
        info_d[pdf_name(&#34;creator&#34;)] = enclose_in_parens(getattr(self, &#34;creator&#34;, None))

        if hasattr(self, &#34;creation_date&#34;):
            try:
                creation_date = self.creation_date
                date_string = creation_date.strftime(&#34;%Y%m%d%H%M%S&#34;)
            except Exception as error:
                raise FPDFException(
                    &#34;Could not format date: &#34; + str(creation_date)
                ) from error
        else:
            date_string = datetime.now().strftime(&#34;%Y%m%d%H%M%S&#34;)
        info_d[pdf_name(&#34;CreationDate&#34;)] = enclose_in_parens(&#34;D:&#34; + date_string)

        self._out(pdf_d(info_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;, has_empty_fields=True))

    def _putcatalog(self):
        catalog_d = OrderedDict()
        catalog_d[pdf_name(&#34;type&#34;)] = pdf_name(&#34;catalog&#34;)
        catalog_d[pdf_name(&#34;pages&#34;)] = pdf_ref(1)

        zoom_configs = {
            &#34;default&#34;: [&#34;/Fit&#34;],  # TODO FIXME
            &#34;fullpage&#34;: [&#34;/Fit&#34;],
            &#34;fullwidth&#34;: [&#34;/FitH&#34;, &#34;null&#34;],
            &#34;real&#34;: [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, &#34;1&#34;],
        }
        zoom_config = [pdf_ref(3)]
        zoom_config.extend(zoom_configs.get(self.zoom_mode, []))

        # zoom_config is a number, not one of the allowed strings
        if not zoom_config:
            zoom_config = [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, str(self.zoom_mode / 100)]

        catalog_d[pdf_name(&#34;OpenAction&#34;)] = pdf_l(zoom_config)

        layout_names = {
            &#34;single&#34;: pdf_name(&#34;SinglePage&#34;),
            &#34;continuous&#34;: pdf_name(&#34;OneColumn&#34;),
            &#34;two&#34;: pdf_name(&#34;TwoColumnLeft&#34;),
        }

        if self.layout_mode in layout_names:
            catalog_d[pdf_name(&#34;PageLayout&#34;)] = layout_names[self.layout_mode]

        self._out(pdf_d(catalog_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;))

    def _putheader(self):
        self._out(&#34;%PDF-&#34; + self.pdf_version)

    def _puttrailer(self):
        self._out(&#34;/Size &#34; + str(self.n + 1))
        self._out(&#34;/Root &#34; + pdf_ref(self.n))
        self._out(&#34;/Info &#34; + pdf_ref(self.n - 1))

    def _enddoc(self):
        LOGGER.debug(&#34;Final doc sections size summary:&#34;)
        with self._trace_size(&#34;header&#34;):
            self._putheader()
        with self._trace_size(&#34;pages&#34;):
            self._putpages()
        self._putresources()  # trace_size is performed inside
        # Info
        with self._trace_size(&#34;info&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putinfo()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Catalog
        with self._trace_size(&#34;catalog&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putcatalog()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Cross-ref
        with self._trace_size(&#34;xref&#34;):
            o = len(self.buffer)
            self._out(&#34;xref&#34;)
            self._out(&#34;0 &#34; + (str(self.n + 1)))
            self._out(&#34;0000000000 65535 f &#34;)
            for i in range(1, self.n + 1):
                self._out(sprintf(&#34;%010d 00000 n &#34;, self.offsets[i]))
        # Trailer
        with self._trace_size(&#34;trailer&#34;):
            self._out(&#34;trailer&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._puttrailer()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;startxref&#34;)
            self._out(o)
        self._out(&#34;%%EOF&#34;)
        self.state = 3

    def _beginpage(self, orientation, format, same):
        self.page += 1
        self.pages[self.page] = {&#34;content&#34;: bytearray()}
        self.state = 2
        self.x = self.l_margin
        self.y = self.t_margin
        self.font_family = &#34;&#34;
        self.font_stretching = 100
        if not same:
            # Page format
            if format:
                # Change page format
                fw_pt, fh_pt = get_page_format(format, self.k)
            else:
                # Set to default format
                fw_pt = self.dw_pt
                fh_pt = self.dh_pt
            # Page orientation
            if not orientation:
                orientation = self.def_orientation
            else:
                orientation = orientation[0].upper()
            if orientation == &#34;P&#34;:
                self.w_pt = fw_pt
                self.h_pt = fh_pt
            else:
                self.w_pt = fh_pt
                self.h_pt = fw_pt
            self.w = self.w_pt / self.k
            self.h = self.h_pt / self.k
            self.page_break_trigger = self.h - self.b_margin
            self.cur_orientation = orientation
        self.pages[self.page][&#34;w_pt&#34;] = self.w_pt
        self.pages[self.page][&#34;h_pt&#34;] = self.h_pt

    def _endpage(self):
        # End of page contents
        self.state = 1

    def _newobj(self):
        # Begin a new object
        self.n += 1
        self.offsets[self.n] = len(self.buffer)
        self._out(str(self.n) + &#34; 0 obj&#34;)

    def _dounderline(self, x, y, txt):
        # Underline text
        up = self.current_font[&#34;up&#34;]
        ut = self.current_font[&#34;ut&#34;]
        w = self.get_string_width(txt, True) + self.ws * txt.count(&#34; &#34;)
        return sprintf(
            &#34;%.2f %.2f %.2f %.2f re f&#34;,
            x * self.k,
            (self.h - (y - up / 1000.0 * self.font_size)) * self.k,
            w * self.k,
            -ut / 1000.0 * self.font_size_pt,
        )

    def _out(self, s):
        # Add a line to the document
        if not isinstance(s, bytes):
            if not isinstance(s, str):
                s = str(s)
            s = s.encode(&#34;latin1&#34;)
        if self.state == 2:
            self.pages[self.page][&#34;content&#34;] += s + b&#34;\n&#34;
        else:
            self.buffer += s + b&#34;\n&#34;

    @check_page
    def interleaved2of5(self, txt, x, y, w=1.0, h=10.0):
        &#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;
        narrow = w / 3.0
        wide = w

        # wide/narrow codes for the digits
        bar_char = {
            &#34;0&#34;: &#34;nnwwn&#34;,
            &#34;1&#34;: &#34;wnnnw&#34;,
            &#34;2&#34;: &#34;nwnnw&#34;,
            &#34;3&#34;: &#34;wwnnn&#34;,
            &#34;4&#34;: &#34;nnwnw&#34;,
            &#34;5&#34;: &#34;wnwnn&#34;,
            &#34;6&#34;: &#34;nwwnn&#34;,
            &#34;7&#34;: &#34;nnnww&#34;,
            &#34;8&#34;: &#34;wnnwn&#34;,
            &#34;9&#34;: &#34;nwnwn&#34;,
            &#34;A&#34;: &#34;nn&#34;,
            &#34;Z&#34;: &#34;wn&#34;,
        }

        self.set_fill_color(0)
        code = txt
        # add leading zero if code-length is odd
        if len(code) % 2 != 0:
            code = &#34;0&#34; + code

        # add start and stop codes
        code = &#34;AA&#34; + code.lower() + &#34;ZA&#34;

        for i in range(0, len(code), 2):
            # choose next pair of digits
            char_bar = code[i]
            char_space = code[i + 1]
            # check whether it is a valid digit
            if char_bar not in bar_char.keys():
                raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_bar)
            if not char_space in bar_char.keys():
                raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_space)

            # create a wide/narrow-seq (first digit=bars, second digit=spaces)
            seq = &#34;&#34;
            for s in range(0, len(bar_char[char_bar])):
                seq += bar_char[char_bar][s] + bar_char[char_space][s]

            for bar, char in enumerate(seq):
                # set line_width depending on value
                line_width = narrow if char == &#34;n&#34; else wide

                # draw every second value, the other is represented by space
                if bar % 2 == 0:
                    self.rect(x, y, line_width, h, &#34;F&#34;)

                x += line_width

    @check_page
    def code39(self, txt, x, y, w=1.5, h=5.0):
        &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
        dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3.0}
        chars = {
            &#34;0&#34;: &#34;nnnwwnwnn&#34;,
            &#34;1&#34;: &#34;wnnwnnnnw&#34;,
            &#34;2&#34;: &#34;nnwwnnnnw&#34;,
            &#34;3&#34;: &#34;wnwwnnnnn&#34;,
            &#34;4&#34;: &#34;nnnwwnnnw&#34;,
            &#34;5&#34;: &#34;wnnwwnnnn&#34;,
            &#34;6&#34;: &#34;nnwwwnnnn&#34;,
            &#34;7&#34;: &#34;nnnwnnwnw&#34;,
            &#34;8&#34;: &#34;wnnwnnwnn&#34;,
            &#34;9&#34;: &#34;nnwwnnwnn&#34;,
            &#34;A&#34;: &#34;wnnnnwnnw&#34;,
            &#34;B&#34;: &#34;nnwnnwnnw&#34;,
            &#34;C&#34;: &#34;wnwnnwnnn&#34;,
            &#34;D&#34;: &#34;nnnnwwnnw&#34;,
            &#34;E&#34;: &#34;wnnnwwnnn&#34;,
            &#34;F&#34;: &#34;nnwnwwnnn&#34;,
            &#34;G&#34;: &#34;nnnnnwwnw&#34;,
            &#34;H&#34;: &#34;wnnnnwwnn&#34;,
            &#34;I&#34;: &#34;nnwnnwwnn&#34;,
            &#34;J&#34;: &#34;nnnnwwwnn&#34;,
            &#34;K&#34;: &#34;wnnnnnnww&#34;,
            &#34;L&#34;: &#34;nnwnnnnww&#34;,
            &#34;M&#34;: &#34;wnwnnnnwn&#34;,
            &#34;N&#34;: &#34;nnnnwnnww&#34;,
            &#34;O&#34;: &#34;wnnnwnnwn&#34;,
            &#34;P&#34;: &#34;nnwnwnnwn&#34;,
            &#34;Q&#34;: &#34;nnnnnnwww&#34;,
            &#34;R&#34;: &#34;wnnnnnwwn&#34;,
            &#34;S&#34;: &#34;nnwnnnwwn&#34;,
            &#34;T&#34;: &#34;nnnnwnwwn&#34;,
            &#34;U&#34;: &#34;wwnnnnnnw&#34;,
            &#34;V&#34;: &#34;nwwnnnnnw&#34;,
            &#34;W&#34;: &#34;wwwnnnnnn&#34;,
            &#34;X&#34;: &#34;nwnnwnnnw&#34;,
            &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
            &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
            &#34;-&#34;: &#34;nwnnnnwnw&#34;,
            &#34;.&#34;: &#34;wwnnnnwnn&#34;,
            &#34; &#34;: &#34;nwwnnnwnn&#34;,
            &#34;*&#34;: &#34;nwnnwnwnn&#34;,
            &#34;$&#34;: &#34;nwnwnwnnn&#34;,
            &#34;/&#34;: &#34;nwnwnnnwn&#34;,
            &#34;+&#34;: &#34;nwnnnwnwn&#34;,
            &#34;%&#34;: &#34;nnnwnwnwn&#34;,
        }
        self.set_fill_color(0)
        for c in txt.upper():
            if c not in chars:
                raise RuntimeError(&#39;Invalid char &#34;%s&#34; for Code39&#39; % c)
            for i, d in enumerate(chars[c]):
                if i % 2 == 0:
                    self.rect(x, y, dim[d], h, &#34;F&#34;)
                x += dim[d]
            x += dim[&#34;n&#34;]

    @check_page
    @contextmanager
    def rect_clip(self, x, y, w, h):
        self._out(
            sprintf(
                &#34;q %.2f %.2f %.2f %.2f re W n\n&#34;,
                x * self.k,
                (self.h - (y + h)) * self.k,
                w * self.k,
                h * self.k,
            )
        )
        yield
        self._out(&#34;Q\n&#34;)

    @contextmanager
    def _trace_size(self, label):
        prev_size = len(self.buffer)
        yield
        LOGGER.debug(&#34;- %s.size: %s&#34;, label, _sizeof_fmt(len(self.buffer) - prev_size))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fpdf.FPDF.accept_page_break"><code class="name">var <span class="ident">accept_page_break</span></code></dt>
<dd>
<div class="desc"><p>Accept automatic page break or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def accept_page_break(self):
    &#34;Accept automatic page break or not&#34;
    return self.auto_page_break</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fpdf.FPDF.add_font"><code class="name flex">
<span>def <span class="ident">add_font</span></span>(<span>self, family, style='', fname=None, uni=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a TrueType or Type1 font</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_font(self, family, style=&#34;&#34;, fname=None, uni=False):
    &#34;Add a TrueType or Type1 font&#34;
    if not fname:
        fname = family.replace(&#34; &#34;, &#34;&#34;) + style.lower() + &#34;.pkl&#34;

    if family.lower() == &#34;arial&#34;:
        warnings.warn(&#34;Substitutting Arial by core font Helvetica&#34;)
        family = &#34;helvetica&#34;
    style = style.upper()
    if style == &#34;IB&#34;:
        style = &#34;BI&#34;
    fontkey = family + style

    # Font already added!
    if fontkey in self.fonts:
        return
    if uni:
        if os.path.exists(fname):
            ttffilename = fname
        elif FPDF_FONT_DIR and os.path.exists(os.path.join(FPDF_FONT_DIR, fname)):
            ttffilename = os.path.join(FPDF_FONT_DIR, fname)
        elif SYSTEM_TTFONTS and os.path.exists(os.path.join(SYSTEM_TTFONTS, fname)):
            ttffilename = os.path.join(SYSTEM_TTFONTS, fname)
        else:
            raise RuntimeError(&#34;TTF Font file not found: %s&#34; % fname)
        if FPDF_CACHE_MODE == 0:
            unifilename = os.path.splitext(ttffilename)[0] + &#34;.pkl&#34;
        elif FPDF_CACHE_MODE == 2:
            unifilename = os.path.join(
                FPDF_CACHE_DIR, _hashpath(ttffilename) + &#34;.pkl&#34;
            )
        else:
            unifilename = None

        font_dict = load_cache(unifilename)
        if font_dict is None:
            ttf = TTFontFile()
            ttf.getMetrics(ttffilename)
            desc = {
                &#34;Ascent&#34;: int(round(ttf.ascent, 0)),
                &#34;Descent&#34;: int(round(ttf.descent, 0)),
                &#34;CapHeight&#34;: int(round(ttf.capHeight, 0)),
                &#34;Flags&#34;: ttf.flags,
                &#34;FontBBox&#34;: &#34;[%s %s %s %s]&#34;
                % (
                    int(round(ttf.bbox[0], 0)),
                    int(round(ttf.bbox[1], 0)),
                    int(round(ttf.bbox[2], 0)),
                    int(round(ttf.bbox[3], 0)),
                ),
                &#34;ItalicAngle&#34;: int(ttf.italicAngle),
                &#34;StemV&#34;: int(round(ttf.stemV, 0)),
                &#34;MissingWidth&#34;: int(round(ttf.defaultWidth, 0)),
            }

            # Generate metrics .pkl file
            font_dict = {
                &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;desc&#34;: desc,
                &#34;up&#34;: round(ttf.underlinePosition),
                &#34;ut&#34;: round(ttf.underlineThickness),
                &#34;ttffile&#34;: ttffilename,
                &#34;fontkey&#34;: fontkey,
                &#34;originalsize&#34;: os.stat(ttffilename).st_size,
                &#34;cw&#34;: ttf.charWidths,
            }

            if unifilename:
                try:
                    with open(unifilename, &#34;wb&#34;) as fh:
                        pickle.dump(font_dict, fh)
                except IOError as e:
                    if e.errno != errno.EACCES:
                        raise  # Not a permission error.
            del ttf

        # include numbers in the subset! (if alias present)
        have_page_alias = lambda: hasattr(self, &#34;str_alias_nb_pages&#34;)
        sbarr = list(range(0, 57 if have_page_alias() else 32))

        self.fonts[fontkey] = {
            &#34;i&#34;: len(self.fonts) + 1,
            &#34;type&#34;: font_dict[&#34;type&#34;],
            &#34;name&#34;: font_dict[&#34;name&#34;],
            &#34;desc&#34;: font_dict[&#34;desc&#34;],
            &#34;up&#34;: font_dict[&#34;up&#34;],
            &#34;ut&#34;: font_dict[&#34;ut&#34;],
            &#34;cw&#34;: font_dict[&#34;cw&#34;],
            &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
            &#34;fontkey&#34;: fontkey,
            &#34;subset&#34;: sbarr,
            &#34;unifilename&#34;: unifilename,
        }
        self.font_files[fontkey] = {
            &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
            &#34;type&#34;: &#34;TTF&#34;,
            &#34;ttffile&#34;: ttffilename,
        }
        self.font_files[fname] = {&#34;type&#34;: &#34;TTF&#34;}
    else:
        with open(fname, &#34;rb&#34;) as fontfile:
            font_dict = pickle.load(fontfile)
        self.fonts[fontkey] = {&#34;i&#34;: len(self.fonts) + 1}
        self.fonts[fontkey].update(font_dict)
        diff = font_dict.get(&#34;diff&#34;)
        if diff:
            # Search existing encodings
            d = 0
            nb = len(self.diffs)
            for i in range(1, nb + 1):
                if self.diffs[i] == diff:
                    d = i
                    break
            if d == 0:
                d = nb + 1
                self.diffs[d] = diff
            self.fonts[fontkey][&#34;diff&#34;] = d
        filename = font_dict.get(&#34;filename&#34;)
        if filename:
            if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                originalsize = font_dict[&#34;originalsize&#34;]
                self.font_files[filename] = {&#34;length1&#34;: originalsize}
            else:
                self.font_files[filename] = {
                    &#34;length1&#34;: font_dict[&#34;size1&#34;],
                    &#34;length2&#34;: font_dict[&#34;size2&#34;],
                }</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new internal link</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_link(self):
    &#34;Create a new internal link&#34;
    n = len(self.links) + 1
    self.links[n] = (0, 0)
    return n</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self, orientation='', format='', same=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a new page, if same page format will be same as previous</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page(self, orientation=&#34;&#34;, format=&#34;&#34;, same=False):
    &#34;Start a new page, if same page format will be same as previous&#34;
    if self.state == 0:
        self.open()
    family = self.font_family
    style = self.font_style + &#34;U&#34; if self.underline else self.font_style
    size = self.font_size_pt
    lw = self.line_width
    dc = self.draw_color
    fc = self.fill_color
    tc = self.text_color
    cf = self.color_flag
    stretching = self.font_stretching
    if self.page &gt; 0:
        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0
        # close page
        self._endpage()

    # Start new page
    self._beginpage(orientation, format, same)
    self._out(&#34;2 J&#34;)  # Set line cap style to square
    self.line_width = lw  # Set line width
    self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

    # Set font
    if family:
        self.set_font(family, style, size)

    # Set colors
    self.draw_color = dc
    if dc != &#34;0 G&#34;:
        self._out(dc)
    self.fill_color = fc
    if fc != &#34;0 g&#34;:
        self._out(fc)
    self.text_color = tc
    self.color_flag = cf

    # BEGIN Page header
    self.header()

    if self.line_width != lw:  # Restore line width
        self.line_width = lw
        self._out(sprintf(&#34;%.2f w&#34;, lw * self.k))

    if family:
        self.set_font(family, style, size)  # Restore font

    if self.draw_color != dc:  # Restore colors
        self.draw_color = dc
        self._out(dc)
    if self.fill_color != fc:
        self.fill_color = fc
        self._out(fc)
    self.text_color = tc
    self.color_flag = cf

    if stretching != 100:  # Restore stretching
        self.set_stretching(stretching)
    # END Page header</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.alias_nb_pages"><code class="name flex">
<span>def <span class="ident">alias_nb_pages</span></span>(<span>self, alias='{nb}')</span>
</code></dt>
<dd>
<div class="desc"><p>Define an alias for total number of pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alias_nb_pages(self, alias=&#34;{nb}&#34;):
    &#34;Define an alias for total number of pages&#34;
    self.str_alias_nb_pages = alias
    return alias</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.cell"><code class="name flex">
<span>def <span class="ident">cell</span></span>(<span>self, w, h=0, txt='', border=0, ln=0, align='', fill=0, link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output a cell, return boolean if triggered auto page break</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def cell(self, w, h=0, txt=&#34;&#34;, border=0, ln=0, align=&#34;&#34;, fill=0, link=&#34;&#34;):
    &#34;Output a cell, return boolean if triggered auto page break&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    if isinstance(border, int) and border not in (0, 1):
        warnings.warn(
            &#39;Integer values for &#34;border&#34; parameter other than 1 are currently ignored&#39;
        )
        border = 1
    page_break_triggered = False
    txt = self.normalize_text(txt)
    k = self.k
    if (
        self.y + h &gt; self.page_break_trigger
        and not self.in_footer
        and self.accept_page_break
    ):

        # Automatic page break
        page_break_triggered = True
        x = self.x
        ws = self.ws
        if ws &gt; 0:
            self.ws = 0
            self._out(&#34;0 Tw&#34;)
        self.add_page(same=True)
        self.x = x  # restore x but not y after drawing header

        if ws &gt; 0:
            self.ws = ws
            self._out(sprintf(&#34;%.3f Tw&#34;, ws * k))
    if w == 0:
        w = self.w - self.r_margin - self.x
    s = &#34;&#34;

    if fill == 1 or border == 1:
        if fill == 1:
            if border == 1:
                op = &#34;B&#34;
            else:
                op = &#34;f&#34;
        else:
            op = &#34;S&#34;
        s = sprintf(
            &#34;%.2f %.2f %.2f %.2f re %s &#34;,
            self.x * k,
            (self.h - self.y) * k,
            w * k,
            -h * k,
            op,
        )

    if isinstance(border, str):
        x = self.x
        y = self.y
        if &#34;L&#34; in border:
            s += sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                x * k,
                (self.h - y) * k,
                x * k,
                (self.h - (y + h)) * k,
            )
        if &#34;T&#34; in border:
            s += sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                x * k,
                (self.h - y) * k,
                (x + w) * k,
                (self.h - y) * k,
            )
        if &#34;R&#34; in border:
            s += sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                (x + w) * k,
                (self.h - y) * k,
                (x + w) * k,
                (self.h - (y + h)) * k,
            )
        if &#34;B&#34; in border:
            s += sprintf(
                &#34;%.2f %.2f m %.2f %.2f l S &#34;,
                x * k,
                (self.h - (y + h)) * k,
                (x + w) * k,
                (self.h - (y + h)) * k,
            )

    if txt != &#34;&#34;:
        if align == &#34;R&#34;:
            dx = w - self.c_margin - self.get_string_width(txt, True)
        elif align == &#34;C&#34;:
            dx = (w - self.get_string_width(txt, True)) / 2.0
        else:
            dx = self.c_margin
        if self.color_flag:
            s += &#34;q &#34; + self.text_color + &#34; &#34;

        # If multibyte, Tw has no effect - do word spacing using an
        # adjustment before each space
        if self.ws and self.unifontsubset:
            for char in txt:
                self.current_font[&#34;subset&#34;].append(ord(char))
            space = escape_parens(&#34; &#34;.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))

            s += sprintf(
                &#34;BT 0 Tw %.2F %.2F Td [&#34;,
                (self.x + dx) * k,
                (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
            )

            t = txt.split(&#34; &#34;)
            numt = len(t)
            for i in range(numt):
                tx = t[i]
                tx = enclose_in_parens(
                    escape_parens(tx.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                )
                s += sprintf(&#34;%s &#34;, tx)
                if (i + 1) &lt; numt:
                    adj = -(self.ws * self.k) * 1000 / self.font_size_pt
                    s += sprintf(&#34;%d(%s) &#34;, adj, space)
            s += &#34;] TJ&#34;
            s += &#34; ET&#34;
        else:
            if self.unifontsubset:
                txt2 = escape_parens(txt.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                for char in txt:
                    self.current_font[&#34;subset&#34;].append(ord(char))
            else:
                txt2 = escape_parens(txt)

            s += sprintf(
                &#34;BT %.2f %.2f Td (%s) Tj ET&#34;,
                (self.x + dx) * k,
                (self.h - (self.y + (0.5 * h) + (0.3 * self.font_size))) * k,
                txt2,
            )

        if self.underline:
            s += &#34; &#34; + self._dounderline(
                self.x + dx, self.y + (0.5 * h) + (0.3 * self.font_size), txt
            )
        if self.color_flag:
            s += &#34; Q&#34;
        if link:
            self.link(
                self.x + dx,
                self.y + (0.5 * h) - (0.5 * self.font_size),
                self.get_string_width(txt, True),
                self.font_size,
                link,
            )
    if s:
        self._out(s)
    self.lasth = h

    if ln &gt; 0:
        self.y += h  # Go to next line
        if ln == 1:
            self.x = self.l_margin
    else:
        self.x += w

    return page_break_triggered</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminate document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;Terminate document&#34;
    if self.state == 3:
        return
    if self.page == 0:
        self.add_page()

    # Page footer
    self.in_footer = 1
    self.footer()
    self.in_footer = 0

    self._endpage()  # close page
    self._enddoc()  # close document</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.code39"><code class="name flex">
<span>def <span class="ident">code39</span></span>(<span>self, txt, x, y, w=1.5, h=5.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Barcode 3of9</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def code39(self, txt, x, y, w=1.5, h=5.0):
    &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
    dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3.0}
    chars = {
        &#34;0&#34;: &#34;nnnwwnwnn&#34;,
        &#34;1&#34;: &#34;wnnwnnnnw&#34;,
        &#34;2&#34;: &#34;nnwwnnnnw&#34;,
        &#34;3&#34;: &#34;wnwwnnnnn&#34;,
        &#34;4&#34;: &#34;nnnwwnnnw&#34;,
        &#34;5&#34;: &#34;wnnwwnnnn&#34;,
        &#34;6&#34;: &#34;nnwwwnnnn&#34;,
        &#34;7&#34;: &#34;nnnwnnwnw&#34;,
        &#34;8&#34;: &#34;wnnwnnwnn&#34;,
        &#34;9&#34;: &#34;nnwwnnwnn&#34;,
        &#34;A&#34;: &#34;wnnnnwnnw&#34;,
        &#34;B&#34;: &#34;nnwnnwnnw&#34;,
        &#34;C&#34;: &#34;wnwnnwnnn&#34;,
        &#34;D&#34;: &#34;nnnnwwnnw&#34;,
        &#34;E&#34;: &#34;wnnnwwnnn&#34;,
        &#34;F&#34;: &#34;nnwnwwnnn&#34;,
        &#34;G&#34;: &#34;nnnnnwwnw&#34;,
        &#34;H&#34;: &#34;wnnnnwwnn&#34;,
        &#34;I&#34;: &#34;nnwnnwwnn&#34;,
        &#34;J&#34;: &#34;nnnnwwwnn&#34;,
        &#34;K&#34;: &#34;wnnnnnnww&#34;,
        &#34;L&#34;: &#34;nnwnnnnww&#34;,
        &#34;M&#34;: &#34;wnwnnnnwn&#34;,
        &#34;N&#34;: &#34;nnnnwnnww&#34;,
        &#34;O&#34;: &#34;wnnnwnnwn&#34;,
        &#34;P&#34;: &#34;nnwnwnnwn&#34;,
        &#34;Q&#34;: &#34;nnnnnnwww&#34;,
        &#34;R&#34;: &#34;wnnnnnwwn&#34;,
        &#34;S&#34;: &#34;nnwnnnwwn&#34;,
        &#34;T&#34;: &#34;nnnnwnwwn&#34;,
        &#34;U&#34;: &#34;wwnnnnnnw&#34;,
        &#34;V&#34;: &#34;nwwnnnnnw&#34;,
        &#34;W&#34;: &#34;wwwnnnnnn&#34;,
        &#34;X&#34;: &#34;nwnnwnnnw&#34;,
        &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
        &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
        &#34;-&#34;: &#34;nwnnnnwnw&#34;,
        &#34;.&#34;: &#34;wwnnnnwnn&#34;,
        &#34; &#34;: &#34;nwwnnnwnn&#34;,
        &#34;*&#34;: &#34;nwnnwnwnn&#34;,
        &#34;$&#34;: &#34;nwnwnwnnn&#34;,
        &#34;/&#34;: &#34;nwnwnnnwn&#34;,
        &#34;+&#34;: &#34;nwnnnwnwn&#34;,
        &#34;%&#34;: &#34;nnnwnwnwn&#34;,
    }
    self.set_fill_color(0)
    for c in txt.upper():
        if c not in chars:
            raise RuntimeError(&#39;Invalid char &#34;%s&#34; for Code39&#39; % c)
        for i, d in enumerate(chars[c]):
            if i % 2 == 0:
                self.rect(x, y, dim[d], h, &#34;F&#34;)
            x += dim[d]
        x += dim[&#34;n&#34;]</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.dashed_line"><code class="name flex">
<span>def <span class="ident">dashed_line</span></span>(<span>self, x1, y1, x2, y2, dash_length=1, space_length=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a dashed line. Same interface as line() except:
- dash_length: Length of the dash
- space_length: Length of the space between dashes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
    &#34;&#34;&#34;Draw a dashed line. Same interface as line() except:
    - dash_length: Length of the dash
    - space_length: Length of the space between dashes&#34;&#34;&#34;
    self._set_dash(dash_length, space_length)
    self.line(x1, y1, x2, y2)
    self._set_dash()</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def ellipse(self, x, y, w, h, style=None):
    &#34;Draw a ellipse&#34;
    style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
    op = style_to_operators.get(style, &#34;S&#34;)

    cx = x + w / 2.0
    cy = y + h / 2.0
    rx = w / 2.0
    ry = h / 2.0

    lx = 4.0 / 3.0 * (math.sqrt(2) - 1) * rx
    ly = 4.0 / 3.0 * (math.sqrt(2) - 1) * ry

    self._out(
        sprintf(
            &#34;%.2f %.2f m %.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
            (cx + rx) * self.k,
            (self.h - cy) * self.k,
            (cx + rx) * self.k,
            (self.h - (cy - ly)) * self.k,
            (cx + lx) * self.k,
            (self.h - (cy - ry)) * self.k,
            cx * self.k,
            (self.h - (cy - ry)) * self.k,
        )
    )
    self._out(
        sprintf(
            &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
            (cx - lx) * self.k,
            (self.h - (cy - ry)) * self.k,
            (cx - rx) * self.k,
            (self.h - (cy - ly)) * self.k,
            (cx - rx) * self.k,
            (self.h - cy) * self.k,
        )
    )
    self._out(
        sprintf(
            &#34;%.2f %.2f %.2f %.2f %.2f %.2f c&#34;,
            (cx - rx) * self.k,
            (self.h - (cy + ly)) * self.k,
            (cx - lx) * self.k,
            (self.h - (cy + ry)) * self.k,
            cx * self.k,
            (self.h - (cy + ry)) * self.k,
        )
    )
    self._out(
        sprintf(
            &#34;%.2f %.2f %.2f %.2f %.2f %.2f c %s&#34;,
            (cx + lx) * self.k,
            (self.h - (cy + ry)) * self.k,
            (cx + rx) * self.k,
            (self.h - (cy + ly)) * self.k,
            (cx + rx) * self.k,
            (self.h - cy) * self.k,
            op,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.footer"><code class="name flex">
<span>def <span class="ident">footer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Footer to be implemented in your own inherited class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def footer(self):
    &#34;Footer to be implemented in your own inherited class&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.get_string_width"><code class="name flex">
<span>def <span class="ident">get_string_width</span></span>(<span>self, s, normalized=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get width of a string in the current font</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string_width(self, s, normalized=False):
    &#34;Get width of a string in the current font&#34;
    # normalized is parameter for internal use
    s = s if normalized else self.normalize_text(s)
    cw = self.current_font[&#34;cw&#34;]
    w = 0
    l = len(s)
    if self.unifontsubset:
        for char in s:
            char = ord(char)
            if len(cw) &gt; char:
                w += cw[char]
            elif self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]:
                w += self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]
            else:
                w += 500
    else:
        for i in range(0, l):
            w += cw.get(s[i], 0)
    if self.font_stretching != 100:
        w = w * self.font_stretching / 100.0
    return w * self.font_size / 1000.0</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.get_x"><code class="name flex">
<span>def <span class="ident">get_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get x position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x(self):
    &#34;Get x position&#34;
    return self.x</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get y position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_y(self):
    &#34;Get y position&#34;
    return self.y</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Header to be implemented in your own inherited class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self):
    &#34;Header to be implemented in your own inherited class&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self, name, x=None, y=None, w=0, h=0, type='', link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Put an image on the page</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>either a string representing a file path to an image, or a instance of <code>PIL.Image.Image</code></dd>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>optional horizontal position where to put the image on the page</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>optional vertical position where to put the image on the page</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>int</code></dt>
<dd>optional width of the image</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>int</code></dt>
<dd>optional height of the image</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused, will be removed in a later version</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link, internal or external, to add on the image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def image(
    self,
    name,
    x=None,
    y=None,
    w=0,
    h=0,
    type=&#34;&#34;,
    link=&#34;&#34;,
):
    &#34;&#34;&#34;
    Put an image on the page

    Args:
        name: either a string representing a file path to an image, or a instance of `PIL.Image.Image`
        x (int): optional horizontal position where to put the image on the page
        y (int): optional vertical position where to put the image on the page
        w (int): optional width of the image
        h (int): optional height of the image
        type (str): [**DEPRECATED**] unused, will be removed in a later version
        link (str): optional link, internal or external, to add on the image
    &#34;&#34;&#34;
    if type:
        warnings.warn(
            &#39;&#34;type&#34; is unused and will soon be deprecated&#39;,
            PendingDeprecationWarning,
        )
    if isinstance(name, str):
        img = load_resource(name)
    else:
        name, img = uuid4(), name
    if name not in self.images:
        info = get_img_info(img)
        info[&#34;i&#34;] = len(self.images) + 1
        self.images[name] = info
    else:
        info = self.images[name]

    # Automatic width and height calculation if needed
    if w == 0 and h == 0:
        # Put image at 72 dpi
        w = info[&#34;w&#34;] / self.k
        h = info[&#34;h&#34;] / self.k
    elif w == 0:
        w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
    elif h == 0:
        h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

    # Flowing mode
    if y is None:
        if (
            self.y + h &gt; self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        ):
            # Automatic page break
            x = self.x
            self.add_page(same=True)
            self.x = x
        y = self.y
        self.y += h

    if x is None:
        x = self.x
    self._out(
        sprintf(
            &#34;q %.2f 0 0 %.2f %.2f %.2f cm /I%d Do Q&#34;,
            w * self.k,
            h * self.k,
            x * self.k,
            (self.h - (y + h)) * self.k,
            info[&#34;i&#34;],
        )
    )
    if link:
        self.link(x, y, w, h, link)

    return info</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.interleaved2of5"><code class="name flex">
<span>def <span class="ident">interleaved2of5</span></span>(<span>self, txt, x, y, w=1.0, h=10.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Barcode I2of5 (numeric), adds a 0 if odd length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def interleaved2of5(self, txt, x, y, w=1.0, h=10.0):
    &#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;
    narrow = w / 3.0
    wide = w

    # wide/narrow codes for the digits
    bar_char = {
        &#34;0&#34;: &#34;nnwwn&#34;,
        &#34;1&#34;: &#34;wnnnw&#34;,
        &#34;2&#34;: &#34;nwnnw&#34;,
        &#34;3&#34;: &#34;wwnnn&#34;,
        &#34;4&#34;: &#34;nnwnw&#34;,
        &#34;5&#34;: &#34;wnwnn&#34;,
        &#34;6&#34;: &#34;nwwnn&#34;,
        &#34;7&#34;: &#34;nnnww&#34;,
        &#34;8&#34;: &#34;wnnwn&#34;,
        &#34;9&#34;: &#34;nwnwn&#34;,
        &#34;A&#34;: &#34;nn&#34;,
        &#34;Z&#34;: &#34;wn&#34;,
    }

    self.set_fill_color(0)
    code = txt
    # add leading zero if code-length is odd
    if len(code) % 2 != 0:
        code = &#34;0&#34; + code

    # add start and stop codes
    code = &#34;AA&#34; + code.lower() + &#34;ZA&#34;

    for i in range(0, len(code), 2):
        # choose next pair of digits
        char_bar = code[i]
        char_space = code[i + 1]
        # check whether it is a valid digit
        if char_bar not in bar_char.keys():
            raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_bar)
        if not char_space in bar_char.keys():
            raise RuntimeError(&#39;Char &#34;%s&#34; invalid for I25: &#39; % char_space)

        # create a wide/narrow-seq (first digit=bars, second digit=spaces)
        seq = &#34;&#34;
        for s in range(0, len(bar_char[char_bar])):
            seq += bar_char[char_bar][s] + bar_char[char_space][s]

        for bar, char in enumerate(seq):
            # set line_width depending on value
            line_width = narrow if char == &#34;n&#34; else wide

            # draw every second value, the other is represented by space
            if bar % 2 == 0:
                self.rect(x, y, line_width, h, &#34;F&#34;)

            x += line_width</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>self, x1, y1, x2, y2)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def line(self, x1, y1, x2, y2):
    &#34;Draw a line&#34;
    self._out(
        sprintf(
            &#34;%.2f %.2f m %.2f %.2f l S&#34;,
            x1 * self.k,
            (self.h - y1) * self.k,
            x2 * self.k,
            (self.h - y2) * self.k,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, x, y, w, h, link, alt_text='')</span>
</code></dt>
<dd>
<div class="desc"><p>Put a link on the page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, x, y, w, h, link, alt_text=&#34;&#34;):
    &#34;Put a link on the page&#34;
    if self.page not in self.page_links:
        self.page_links[self.page] = []
    self.page_links[self.page] += [
        (x * self.k, self.h_pt - y * self.k, w * self.k, h * self.k, link, alt_text)
    ]</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.ln"><code class="name flex">
<span>def <span class="ident">ln</span></span>(<span>self, h=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Line Feed; default value is last cell height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def ln(self, h=None):
    &#34;Line Feed; default value is last cell height&#34;
    self.x = self.l_margin
    if h is None:
        self.y += self.lasth
    else:
        self.y += h</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.multi_cell"><code class="name flex">
<span>def <span class="ident">multi_cell</span></span>(<span>self, w, h, txt='', border=0, align='J', fill=0, split_only=False, link='', ln=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Output text with automatic or explicit line breaks,
returns boolean if page break triggered in output mode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ln</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>controls cell positioning:</p>
<ul>
<li>0: stack cells horizontally, with respect to <code>.x</code> &amp; <code>.y</code></li>
<li>1: one cell per line, aligned on the left with respect to <code>.l_margin</code></li>
<li>2: one cell per line</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def multi_cell(
    self, w, h, txt=&#34;&#34;, border=0, align=&#34;J&#34;, fill=0, split_only=False, link=&#34;&#34;, ln=0
):
    &#34;&#34;&#34;
    Output text with automatic or explicit line breaks,
    returns boolean if page break triggered in output mode.

    Args:
        ln (int): controls cell positioning:

          - 0: stack cells horizontally, with respect to `.x` &amp; `.y`
          - 1: one cell per line, aligned on the left with respect to `.l_margin`
          - 2: one cell per line
    &#34;&#34;&#34;
    page_break_triggered = False
    if split_only:
        _out, _add_page = self._out, self.add_page
        self._out = lambda *args, **kwargs: None
        self.add_page = lambda *args, **kwargs: None

    # Store this information for manipulating position.
    location = (self.get_x(), self.get_y())

    # If width is 0, set width to available width between margins
    if w == 0:
        w = self.w - self.r_margin - self.x
    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size

    # Calculate text length
    txt = self.normalize_text(txt)
    s = txt.replace(&#34;\r&#34;, &#34;&#34;)
    normalized_string_length = len(s)
    if normalized_string_length &gt; 0 and s[-1] == &#34;\n&#34;:
        normalized_string_length -= 1

    b = 0
    if border:
        if border == 1:
            border = &#34;LTRB&#34;
            b = &#34;LRT&#34;
            b2 = &#34;LR&#34;
        else:
            b2 = &#34;&#34;
            if &#34;L&#34; in border:
                b2 += &#34;L&#34;
            if &#34;R&#34; in border:
                b2 += &#34;R&#34;
            if &#34;T&#34; in border:
                b = b2 + &#34;T&#34;
            else:
                b = b2

    character_widths = self.current_font[&#34;cw&#34;]
    text_cells = []
    sep = -1
    i = 0
    j = 0
    l = 0
    ns = 0
    nl = 1
    while i &lt; normalized_string_length:
        # Get next character
        c = s[i]

        # Explicit line break
        if c == &#34;\n&#34;:
            if self.ws &gt; 0:
                self.ws = 0
                self._out(&#34;0 Tw&#34;)

            new_page = self.cell(
                w,
                h=h,
                txt=substr(s, j, i - j),
                border=b,
                ln=2,
                align=align,
                fill=fill,
                link=link,
            )
            page_break_triggered = page_break_triggered or new_page
            text_cells.append(substr(s, j, i - j))

            i += 1
            sep = -1
            j = i
            l = 0
            ns = 0
            nl += 1
            if border and nl == 2:
                b = b2
            continue

        if c == &#34; &#34;:
            sep = i
            ls = l
            ns += 1
        if self.unifontsubset:
            l += self.get_string_width(c, True) / self.font_size * 1000.0
        else:
            l += character_widths.get(c, 0)

        # Automatic line break
        if l &gt; wmax:
            if sep == -1:
                if i == j:
                    i += 1
                if self.ws &gt; 0:
                    self.ws = 0
                    self._out(&#34;0 Tw&#34;)

                new_page = self.cell(
                    w,
                    h=h,
                    txt=substr(s, j, i - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, i - j))

            else:
                if align == &#34;J&#34;:
                    if ns &gt; 1:
                        self.ws = (wmax - ls) / 1000.0 * self.font_size / (ns - 1)
                    else:
                        self.ws = 0
                    self._out(sprintf(&#34;%.3f Tw&#34;, self.ws * self.k))

                new_page = self.cell(
                    w,
                    h=h,
                    txt=substr(s, j, sep - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, sep - j))

                i = sep + 1
            sep = -1
            j = i
            l = 0
            ns = 0
            nl += 1
            if border and nl == 2:
                b = b2
        else:
            i += 1

    # Last chunk
    if self.ws &gt; 0:
        self.ws = 0
        self._out(&#34;0 Tw&#34;)
    if border and &#34;B&#34; in border:
        b += &#34;B&#34;

    new_page = self.cell(
        w,
        h=h,
        txt=substr(s, j, i - j),
        border=b,
        ln=2,
        align=align,
        fill=fill,
        link=link,
    )
    page_break_triggered = page_break_triggered or new_page
    text_cells.append(substr(s, j, i - j))

    location_options = {
        0: lambda: self.set_xy(self.x + w, self.y),
        1: lambda: self.set_x(self.l_margin),  # could control y
        2: lambda: None,
    }
    location_options.get(ln, lambda: None)()

    if split_only:
        # restore writing functions
        self._out, self.add_page = _out, _add_page
        self.set_xy(*location)  # restore location
        return text_cells

    return page_break_triggered</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.normalize_text"><code class="name flex">
<span>def <span class="ident">normalize_text</span></span>(<span>self, txt)</span>
</code></dt>
<dd>
<div class="desc"><p>Check that text input is in the correct format/encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_text(self, txt):
    &#34;Check that text input is in the correct format/encoding&#34;
    # - for TTF unicode fonts: unicode object (utf8 encoding)
    # - for built-in fonts: string instances (encoding: latin-1, cp1252)
    if not self.unifontsubset and self.core_fonts_encoding:
        return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
    return txt</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Begin document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self):
    &#34;Begin document&#34;
    self.state = 1</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.output"><code class="name flex">
<span>def <span class="ident">output</span></span>(<span>self, name='', dest='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output PDF to some destination</p>
<p>By default the PDF is written to sys.stdout. If a name is given, the
PDF is written to a new file. If dest='S' is given, the PDF data is
returned as a byte string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output(self, name=&#34;&#34;, dest=&#34;&#34;):
    &#34;&#34;&#34;Output PDF to some destination

    By default the PDF is written to sys.stdout. If a name is given, the
    PDF is written to a new file. If dest=&#39;S&#39; is given, the PDF data is
    returned as a byte string.&#34;&#34;&#34;
    # pylint: disable=inconsistent-return-statements
    # Finish document if necessary
    if self.state &lt; 3:
        self.close()
    dest = dest.upper()
    if dest == &#34;&#34;:
        dest = &#34;I&#34; if name == &#34;&#34; else &#34;F&#34;
    if dest in (&#34;I&#34;, &#34;D&#34;):
        # Python &lt; 3 writes byte data transparently without &#34;buffer&#34;
        stdout = getattr(sys.stdout, &#34;buffer&#34;, sys.stdout)
        stdout.write(self.buffer)
        return None
    if dest == &#34;F&#34;:
        # Save to local file
        with open(name, &#34;wb&#34;) as f:
            f.write(self.buffer)
        return None
    # Return as a byte string
    if dest == &#34;S&#34;:
        return self.buffer
    raise FPDFException(&#34;Incorrect output destination: &#34; + dest)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.page_no"><code class="name flex">
<span>def <span class="ident">page_no</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current page number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_no(self):
    &#34;Get current page number&#34;
    return self.page</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a rectangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def rect(self, x, y, w, h, style=None):
    &#34;Draw a rectangle&#34;
    style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
    op = style_to_operators.get(style, &#34;S&#34;)
    self._out(
        sprintf(
            &#34;%.2f %.2f %.2f %.2f re %s&#34;,
            x * self.k,
            (self.h - y) * self.k,
            w * self.k,
            -h * self.k,
            op,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.rect_clip"><code class="name flex">
<span>def <span class="ident">rect_clip</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rect_clip(self, x, y, w, h):
    self._out(
        sprintf(
            &#34;q %.2f %.2f %.2f %.2f re W n\n&#34;,
            x * self.k,
            (self.h - (y + h)) * self.k,
            w * self.k,
            h * self.k,
        )
    )
    yield
    self._out(&#34;Q\n&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;2.1.0</p>
<p>Use <code>rotation</code> instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def rotate(self, angle, x=None, y=None):
    &#34;&#34;&#34;
    .. deprecated:: 2.1.0
      Use `rotation` instead.
    &#34;&#34;&#34;
    warnings.warn(
        &#34;rotate() can produces malformed PDFs and is deprecated. Use the rotation() context manager instead.&#34;,
        PendingDeprecationWarning,
    )
    if x is None:
        x = self.x
    if y is None:
        y = self.y

    if self.angle != 0:
        self._out(&#34;Q&#34;)
    self.angle = angle
    if angle != 0:
        angle *= math.pi / 180
        c = math.cos(angle)
        s = math.sin(angle)
        cx = x * self.k
        cy = (self.h - y) * self.k
        s = sprintf(
            &#34;q %.5F %.5F %.5F %.5F %.2F %.2F &#34; + &#34;cm 1 0 0 1 %.2F %.2F cm&#34;,
            c,
            s,
            -s,
            c,
            cx,
            cy,
            -cx,
            -cy,
        )
        self._out(s)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.rotation"><code class="name flex">
<span>def <span class="ident">rotation</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to perform a rotation around a given center.</p>
<p>The rotation affects all elements which are printed inside the indented context
(with the exception of clickable areas).</p>
<h2 id="notes">Notes</h2>
<p>Only the rendering is altered. The <code>get_x()</code> and <code>get_y()</code> methods are not affected,
nor the automatic page break mechanism.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rotation(self, angle, x=None, y=None):
    &#34;&#34;&#34;
    This method allows to perform a rotation around a given center.

    The rotation affects all elements which are printed inside the indented context
    (with the exception of clickable areas).

    Notes
    -----

    Only the rendering is altered. The `get_x()` and `get_y()` methods are not affected,
    nor the automatic page break mechanism.
    &#34;&#34;&#34;
    if x is None:
        x = self.x
    if y is None:
        y = self.y
    angle *= math.pi / 180
    c, s = math.cos(angle), math.sin(angle)
    cx, cy = x * self.k, (self.h - y) * self.k
    self._out(
        sprintf(
            &#34;q %.5F %.5F %.5F %.5F %.2F %.2F cm 1 0 0 1 %.2F %.2F cm\n&#34;,
            c,
            s,
            -s,
            c,
            cx,
            cy,
            -cx,
            -cy,
        )
    )
    yield
    self._out(&#34;Q\n&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_author"><code class="name flex">
<span>def <span class="ident">set_author</span></span>(<span>self, author)</span>
</code></dt>
<dd>
<div class="desc"><p>Author of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_author(self, author):
    &#34;Author of document&#34;
    self.author = author</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_auto_page_break"><code class="name flex">
<span>def <span class="ident">set_auto_page_break</span></span>(<span>self, auto, margin=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set auto page break mode and triggering margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_auto_page_break(self, auto, margin=0):
    &#34;Set auto page break mode and triggering margin&#34;
    self.auto_page_break = auto
    self.b_margin = margin
    self.page_break_trigger = self.h - margin</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_compression"><code class="name flex">
<span>def <span class="ident">set_compression</span></span>(<span>self, compress)</span>
</code></dt>
<dd>
<div class="desc"><p>Set page compression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compression(self, compress):
    &#34;Set page compression&#34;
    self.compress = compress</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_creation_date"><code class="name flex">
<span>def <span class="ident">set_creation_date</span></span>(<span>self, date=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets Creation of Date time, or current time if None given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creation_date(self, date=None):
    &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
    self.creation_date = datetime.now() if date is None else date</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_creator"><code class="name flex">
<span>def <span class="ident">set_creator</span></span>(<span>self, creator)</span>
</code></dt>
<dd>
<div class="desc"><p>Creator of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creator(self, creator):
    &#34;Creator of document&#34;
    self.creator = creator</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_display_mode"><code class="name flex">
<span>def <span class="ident">set_display_mode</span></span>(<span>self, zoom, layout='continuous')</span>
</code></dt>
<dd>
<div class="desc"><p>Set display mode in viewer</p>
<p>The "zoom" argument may be 'fullpage', 'fullwidth', 'real',
'default', or a number, interpreted as a percentage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
    &#34;&#34;&#34;Set display mode in viewer

    The &#34;zoom&#34; argument may be &#39;fullpage&#39;, &#39;fullwidth&#39;, &#39;real&#39;,
    &#39;default&#39;, or a number, interpreted as a percentage.
    &#34;&#34;&#34;
    if zoom in [&#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;]:
        self.zoom_mode = zoom
    elif not isinstance(zoom, str):
        self.zoom_mode = zoom
    else:
        raise FPDFException(&#34;Incorrect zoom display mode: &#34; + zoom)

    if layout in [&#34;single&#34;, &#34;continuous&#34;, &#34;two&#34;, &#34;default&#34;]:
        self.layout_mode = layout
    else:
        raise FPDFException(&#34;Incorrect layout display mode: &#34; + layout)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_doc_option"><code class="name flex">
<span>def <span class="ident">set_doc_option</span></span>(<span>self, opt, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set document option</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_doc_option(self, opt, value):
    &#34;Set document option&#34;
    if opt == &#34;core_fonts_encoding&#34;:
        self.core_fonts_encoding = value
    else:
        raise FPDFException(&#39;Unknown document option &#34;%s&#34;&#39; % str(opt))</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_draw_color"><code class="name flex">
<span>def <span class="ident">set_draw_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for all stroking operations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_draw_color(self, r, g=-1, b=-1):
    &#34;Set color for all stroking operations&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.draw_color = sprintf(&#34;%.3f G&#34;, r / 255.0)
    else:
        self.draw_color = sprintf(
            &#34;%.3f %.3f %.3f RG&#34;, r / 255.0, g / 255.0, b / 255.0
        )
    if self.page &gt; 0:
        self._out(self.draw_color)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_fill_color"><code class="name flex">
<span>def <span class="ident">set_fill_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for all filling operations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fill_color(self, r, g=-1, b=-1):
    &#34;Set color for all filling operations&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.fill_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
    else:
        self.fill_color = sprintf(
            &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
        )
    self.color_flag = self.fill_color != self.text_color
    if self.page &gt; 0:
        self._out(self.fill_color)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self, family, style='', size=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Select a font; size given in points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font(self, family, style=&#34;&#34;, size=0):
    &#34;Select a font; size given in points&#34;
    if family == &#34;&#34;:
        family = self.font_family
    if family.lower() == &#34;arial&#34;:
        warnings.warn(&#34;Substitutting Arial by core font Helvetica&#34;)
        family = &#34;helvetica&#34;
    elif family in (&#34;symbol&#34;, &#34;zapfdingbats&#34;):
        style = &#34;&#34;
    style = style.upper()
    if &#34;U&#34; in style:
        self.underline = 1
        style = style.replace(&#34;U&#34;, &#34;&#34;)
    else:
        self.underline = 0
    if style == &#34;IB&#34;:
        style = &#34;BI&#34;
    if size == 0:
        size = self.font_size_pt

    # Test if font is already selected
    if (
        self.font_family == family
        and self.font_style == style
        and self.font_size_pt == size
    ):
        return

    # Test if used for the first time
    fontkey = family + style
    if fontkey not in self.fonts:
        if fontkey not in self.core_fonts or fontkey not in fpdf_charwidths:
            raise FPDFException(&#34;Undefined font: &#34; + fontkey)
        i = len(self.fonts) + 1
        self.fonts[fontkey] = {
            &#34;i&#34;: i,
            &#34;type&#34;: &#34;core&#34;,
            &#34;name&#34;: self.core_fonts[fontkey],
            &#34;up&#34;: -100,
            &#34;ut&#34;: 50,
            &#34;cw&#34;: fpdf_charwidths[fontkey],
        }

    # Select it
    self.font_family = family
    self.font_style = style
    self.font_size_pt = size
    self.font_size = size / self.k
    self.current_font = self.fonts[fontkey]
    self.unifontsubset = self.current_font[&#34;type&#34;] == &#34;TTF&#34;
    if self.page &gt; 0:
        self._out(
            sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
        )</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_font_size"><code class="name flex">
<span>def <span class="ident">set_font_size</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Set font size in points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font_size(self, size):
    &#34;Set font size in points&#34;
    if self.font_size_pt == size:
        return
    self.font_size_pt = size
    self.font_size = size / self.k
    if self.page &gt; 0:
        self._out(
            sprintf(&#34;BT /F%d %.2f Tf ET&#34;, self.current_font[&#34;i&#34;], self.font_size_pt)
        )</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_keywords"><code class="name flex">
<span>def <span class="ident">set_keywords</span></span>(<span>self, keywords)</span>
</code></dt>
<dd>
<div class="desc"><p>Keywords of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_keywords(self, keywords):
    &#34;Keywords of document&#34;
    self.keywords = keywords</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_left_margin"><code class="name flex">
<span>def <span class="ident">set_left_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set left margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_left_margin(self, margin):
    &#34;Set left margin&#34;
    self.l_margin = margin
    if self.page &gt; 0 and self.x &lt; margin:
        self.x = margin</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_line_width"><code class="name flex">
<span>def <span class="ident">set_line_width</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Set line width</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_line_width(self, width):
    &#34;Set line width&#34;
    self.line_width = width
    if self.page &gt; 0:
        self._out(sprintf(&#34;%.2f w&#34;, width * self.k))</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_link"><code class="name flex">
<span>def <span class="ident">set_link</span></span>(<span>self, link, y=0, page=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set destination of internal link</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_link(self, link, y=0, page=-1):
    &#34;Set destination of internal link&#34;
    if y == -1:
        y = self.y
    if page == -1:
        page = self.page

    self.links[link] = [page, y]</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_margins"><code class="name flex">
<span>def <span class="ident">set_margins</span></span>(<span>self, left, top, right=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set left, top and right margins</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_margins(self, left, top, right=-1):
    &#34;Set left, top and right margins&#34;
    self.l_margin = left
    self.t_margin = top
    if right == -1:
        right = left
    self.r_margin = right</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_right_margin"><code class="name flex">
<span>def <span class="ident">set_right_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set right margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_right_margin(self, margin):
    &#34;Set right margin&#34;
    self.r_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_stretching"><code class="name flex">
<span>def <span class="ident">set_stretching</span></span>(<span>self, factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Set from stretch factor percents (default: 100.0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stretching(self, factor):
    &#34;Set from stretch factor percents (default: 100.0)&#34;
    if self.font_stretching == factor:
        return
    self.font_stretching = factor
    if self.page &gt; 0:
        self._out(sprintf(&#34;BT %.2f Tz ET&#34;, self.font_stretching))</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_subject"><code class="name flex">
<span>def <span class="ident">set_subject</span></span>(<span>self, subject)</span>
</code></dt>
<dd>
<div class="desc"><p>Subject of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_subject(self, subject):
    &#34;Subject of document&#34;
    self.subject = subject</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text_color(self, r, g=-1, b=-1):
    &#34;Set color for text&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.text_color = sprintf(&#34;%.3f g&#34;, r / 255.0)
    else:
        self.text_color = sprintf(
            &#34;%.3f %.3f %.3f rg&#34;, r / 255.0, g / 255.0, b / 255.0
        )
    self.color_flag = self.fill_color != self.text_color</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_title"><code class="name flex">
<span>def <span class="ident">set_title</span></span>(<span>self, title)</span>
</code></dt>
<dd>
<div class="desc"><p>Title of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_title(self, title):
    &#34;Title of document&#34;
    self.title = title</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_top_margin"><code class="name flex">
<span>def <span class="ident">set_top_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set top margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_top_margin(self, margin):
    &#34;Set top margin&#34;
    self.t_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_x"><code class="name flex">
<span>def <span class="ident">set_x</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Set x position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x(self, x):
    &#34;Set x position&#34;
    if x &gt;= 0:
        self.x = x
    else:
        self.x = self.w + x</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_xy"><code class="name flex">
<span>def <span class="ident">set_xy</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Set x and y positions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_xy(self, x, y):
    &#34;Set x and y positions&#34;
    self.set_y(y)
    self.set_x(x)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.set_y"><code class="name flex">
<span>def <span class="ident">set_y</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Set y position and reset x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_y(self, y):
    &#34;Set y position and reset x&#34;
    self.x = self.l_margin
    if y &gt;= 0:
        self.y = y
    else:
        self.y = self.h + y</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, x, y, txt='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def text(self, x, y, txt=&#34;&#34;):
    &#34;Output a string&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    txt = self.normalize_text(txt)
    if self.unifontsubset:
        txt2 = escape_parens(txt).encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;)
        for char in txt:
            self.current_font[&#34;subset&#34;].append(ord(char))
    else:
        txt2 = escape_parens(txt)
    s = sprintf(
        &#34;BT %.2f %.2f Td (%s) Tj ET&#34;, x * self.k, (self.h - y) * self.k, txt2
    )
    if self.underline and txt != &#34;&#34;:
        s += &#34; &#34; + self._dounderline(x, y, txt)
    if self.color_flag:
        s = &#34;q &#34; + self.text_color + &#34; &#34; + s + &#34; Q&#34;
    self._out(s)</code></pre>
</details>
</dd>
<dt id="fpdf.fpdf.FPDF.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, h, txt='', link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output text in flowing mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def write(self, h, txt=&#34;&#34;, link=&#34;&#34;):
    &#34;Output text in flowing mode&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    txt = self.normalize_text(txt)
    cw = self.current_font[&#34;cw&#34;]
    w = self.w - self.r_margin - self.x
    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
    s = txt.replace(&#34;\r&#34;, &#34;&#34;)
    nb = len(s)
    sep = -1
    i = 0
    j = 0
    l = 0
    nl = 1
    while i &lt; nb:
        # Get next character
        c = s[i]
        if c == &#34;\n&#34;:
            # Explicit line break
            self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
            i += 1
            sep = -1
            j = i
            l = 0
            if nl == 1:
                self.x = self.l_margin
                w = self.w - self.r_margin - self.x
                wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
            nl += 1
            continue
        if c == &#34; &#34;:
            sep = i
        if self.unifontsubset:
            l += self.get_string_width(c, True) / self.font_size * 1000.0
        else:
            l += cw.get(c, 0)
        if l &gt; wmax:
            # Automatic line break
            if sep == -1:
                if self.x &gt; self.l_margin:
                    # Move to next line
                    self.x = self.l_margin
                    self.y += h
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
                    i += 1
                    nl += 1
                    continue
                if i == j:
                    i += 1
                self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, 0, link)
            else:
                self.cell(w, h, substr(s, j, sep - j), 0, 2, &#34;&#34;, 0, link)
                i = sep + 1
            sep = -1
            j = i
            l = 0
            if nl == 1:
                self.x = self.l_margin
                w = self.w - self.r_margin - self.x
                wmax = (w - 2 * self.c_margin) * 1000.0 / self.font_size
            nl += 1
        else:
            i += 1
    # Last chunk
    if i != j:
        self.cell(l / 1000.0 * self.font_size, h, substr(s, j), 0, 0, &#34;&#34;, 0, link)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.fpdf.get_page_format" href="#fpdf.fpdf.get_page_format">get_page_format</a></code></li>
<li><code><a title="fpdf.fpdf.load_cache" href="#fpdf.fpdf.load_cache">load_cache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.fpdf.FPDF" href="#fpdf.fpdf.FPDF">FPDF</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fpdf.FPDF.accept_page_break" href="#fpdf.fpdf.FPDF.accept_page_break">accept_page_break</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_font" href="#fpdf.fpdf.FPDF.add_font">add_font</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_link" href="#fpdf.fpdf.FPDF.add_link">add_link</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_page" href="#fpdf.fpdf.FPDF.add_page">add_page</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.alias_nb_pages" href="#fpdf.fpdf.FPDF.alias_nb_pages">alias_nb_pages</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.cell" href="#fpdf.fpdf.FPDF.cell">cell</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.close" href="#fpdf.fpdf.FPDF.close">close</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.code39" href="#fpdf.fpdf.FPDF.code39">code39</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.dashed_line" href="#fpdf.fpdf.FPDF.dashed_line">dashed_line</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.ellipse" href="#fpdf.fpdf.FPDF.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.footer" href="#fpdf.fpdf.FPDF.footer">footer</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.get_string_width" href="#fpdf.fpdf.FPDF.get_string_width">get_string_width</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.get_x" href="#fpdf.fpdf.FPDF.get_x">get_x</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.get_y" href="#fpdf.fpdf.FPDF.get_y">get_y</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.header" href="#fpdf.fpdf.FPDF.header">header</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.image" href="#fpdf.fpdf.FPDF.image">image</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.interleaved2of5" href="#fpdf.fpdf.FPDF.interleaved2of5">interleaved2of5</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.line" href="#fpdf.fpdf.FPDF.line">line</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.link" href="#fpdf.fpdf.FPDF.link">link</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.ln" href="#fpdf.fpdf.FPDF.ln">ln</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.multi_cell" href="#fpdf.fpdf.FPDF.multi_cell">multi_cell</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.normalize_text" href="#fpdf.fpdf.FPDF.normalize_text">normalize_text</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.open" href="#fpdf.fpdf.FPDF.open">open</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.output" href="#fpdf.fpdf.FPDF.output">output</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.page_no" href="#fpdf.fpdf.FPDF.page_no">page_no</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.rect" href="#fpdf.fpdf.FPDF.rect">rect</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.rect_clip" href="#fpdf.fpdf.FPDF.rect_clip">rect_clip</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.rotate" href="#fpdf.fpdf.FPDF.rotate">rotate</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.rotation" href="#fpdf.fpdf.FPDF.rotation">rotation</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_author" href="#fpdf.fpdf.FPDF.set_author">set_author</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_auto_page_break" href="#fpdf.fpdf.FPDF.set_auto_page_break">set_auto_page_break</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_compression" href="#fpdf.fpdf.FPDF.set_compression">set_compression</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_creation_date" href="#fpdf.fpdf.FPDF.set_creation_date">set_creation_date</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_creator" href="#fpdf.fpdf.FPDF.set_creator">set_creator</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_display_mode" href="#fpdf.fpdf.FPDF.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_doc_option" href="#fpdf.fpdf.FPDF.set_doc_option">set_doc_option</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_draw_color" href="#fpdf.fpdf.FPDF.set_draw_color">set_draw_color</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_fill_color" href="#fpdf.fpdf.FPDF.set_fill_color">set_fill_color</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_font" href="#fpdf.fpdf.FPDF.set_font">set_font</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_font_size" href="#fpdf.fpdf.FPDF.set_font_size">set_font_size</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_keywords" href="#fpdf.fpdf.FPDF.set_keywords">set_keywords</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_left_margin" href="#fpdf.fpdf.FPDF.set_left_margin">set_left_margin</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_line_width" href="#fpdf.fpdf.FPDF.set_line_width">set_line_width</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_link" href="#fpdf.fpdf.FPDF.set_link">set_link</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_margins" href="#fpdf.fpdf.FPDF.set_margins">set_margins</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_right_margin" href="#fpdf.fpdf.FPDF.set_right_margin">set_right_margin</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_stretching" href="#fpdf.fpdf.FPDF.set_stretching">set_stretching</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_subject" href="#fpdf.fpdf.FPDF.set_subject">set_subject</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_text_color" href="#fpdf.fpdf.FPDF.set_text_color">set_text_color</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_title" href="#fpdf.fpdf.FPDF.set_title">set_title</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_top_margin" href="#fpdf.fpdf.FPDF.set_top_margin">set_top_margin</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_x" href="#fpdf.fpdf.FPDF.set_x">set_x</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_xy" href="#fpdf.fpdf.FPDF.set_xy">set_xy</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_y" href="#fpdf.fpdf.FPDF.set_y">set_y</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.text" href="#fpdf.fpdf.FPDF.text">text</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.write" href="#fpdf.fpdf.FPDF.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>